<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        
          <section>
              <section data-markdown>
                  # Introducing React
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
                </section>
                <section data-markdown>
                    # Agenda
                    
                    1. What is React, and why use it?
                    2. Key concepts in React
                    3. Creating a React app
                    4. Working with components
                    5. Adding props to components
                </section>
                <section data-markdown>
                    # What is React?
        
                    React is a JavaScript **library** for building user interfaces.
                </section>
                <section data-markdown>
                    # Why Use React?
                    
                    React makes it easier to reason about, construct, and maintain *stateless* and *stateful* UIs. Specifically, it is:
                    
                    - **Declarative:** We program the *what* not the *how*
                    - **Component-Based:** We build encapsulated pieces of UI to build larger more complex UIs
                    - **Learn Once, Write Everywhere:** React makes no assumption about how it will ultimately rendered, so we can use it for SSR with Node or to build mobile apps with React Native too
                </section>
                <section data-markdown>
                    # Who Uses React?
                    
                    - Facebook (created it)
                    - Instagram
                    - Netflix
                    - Alibaba
                    - Atlassian
                    - [...and many more!](https://github.com/facebook/react/wiki/Sites-Using-React)
                </section>
                
                  <section data-markdown>
                      # Key Concepts: Components, JSX & the Virtual DOM							
                  </section>
                  <section data-markdown>
                      # Components
                      
                      Because React is a **component-based view abstraction**, we need to start thinking about our UIs in terms of *components*.
                      
                      A component may be an input, a button, a list item, etc. It can also be anything wrapping a number of components to create a more complex piece of UI.
                      
                      We have to think carefully about how we will **manage state** in our components. (Redux will help with this next week.)
                  </section>
                  <section data-markdown>
                      .inline-images-border[
                      ![React mock-up](/public/img/slide-assets/thinking-in-react-mock.png)
                   ]
                   
                   .footnote.right[Image source: [Thinking in React](https://facebook.github.io/react/docs/thinking-in-react.html)]
                  </section>
                  <section data-markdown>
                      .inline-images-border[
                      ![React components](/public/img/slide-assets/thinking-in-react-components.png)
                   ]
                   
                   .footnote.right[Image source: [Thinking in React](https://facebook.github.io/react/docs/thinking-in-react.html)]
                  </section>
                  <section data-markdown>
                      # Exercise 1
                      
                      We're going to build a to-do app together with React...
                      
                      See the [lesson page](/lesson/react-components-and-props/) for more details.
                      
                  </section>
                  <section data-markdown>
                      .large[
                      **Insight:** React components are the programatic abstraction that makes it possible to create these chunks of UI.
                   ]
                  </section>
                  <section data-markdown>
                      # Elements & Components
                      
                      React elements are simply **JS objects used to describe how the HTML for the component should look **, i.e. it is an object-based representation of a DOM note. There are no methods on the object, just data.
                      
                      They can be created with plain JS or **JavaScript XML (JSX)**.
                      
                      Components, on the other hand, are **functions or classes that return React elements.**
                      
                      We use `ReactDOM.render()` to render a React element into a particular DOM element, and the return value of this method is the React component instance.
                  </section>
                  <section data-markdown>
                      # React Elements
                      
                      What a React element looks like:
                      
                      ```js
                      // Without JSX
                      let helloWorld = React.createElement(
                        "div",
                        null,
                        "Hello World!"
                      );
                      
                      // Using JSX
                      let helloWorld = <div>Hello World!</div>;
                      
                      // Both produce a JS object that looks something like this...
                      let helloWorld = {
                        key: null,
                        props: {
                          children: "Hello World!"
                        },
                        ref: null,
                        type: "div"
                      };
                      ```
                  </section>
                
                
                    <section data-markdown>
                        ### JSX?
                        
                        JSX is an XML syntax that can be used to construct the markup in React components.
                        
                        JSX makes it **easier to read and write** React components in our code, but React does work without JSX too.
                        
                        ---
                        class: center, middle
                        
                        .large[
                           Let's take a closer look at how we would create a React component both ways...
                        ]
                    </section>
                    <section data-markdown>
                        # Hello World: No JSX
                        
                        Without JSX...
                        
                        ```html
                        <div id="root"></div>
                        ```
                        
                        ```js
                        import React, { Component } from 'react';
                        import ReactDOM from 'react-dom';
                        
                        class App extends Component {
                          render() {
                            return (
                              ￼￼￼￼React.createElement('h1', {id: 'title'}, 'Hello, world!')
                            );
                          }
                        }
                        
                        ReactDOM.render(
                           React.createElement(App, null),
                           document.getElementById('root')
                        );
                        ```
                    </section>
                </section>
                <section data-markdown>
                    # Hello World: JSX
                    
                    With JSX now...
                    
                    ```html
                    <div id="root"></div>
                    ```
                    
                    ```js
                    import React, { Component } from 'react';
                    import ReactDOM from 'react-dom';
                    
                    class App extends Component {
                       render() {
                          return (
                             <h1 id="title">Hello, world!</h1>
                          );
                       }
                    }
                    
                    ReactDOM.render(<App />, document.getElementById('root'));
                    ```
                    
                    *More readable, less typing!*
                </section>
                <section data-markdown>
                    # Other Things to Note
                    
                    - We must import the `React` and `ReactDOM` libraries before we can create React components
                    - `React` provides us with a `Component` class to extend and create our own components (we can also create *functional stateless components* without the `Component` class)
                    - `render` method comes from `Component`, and is required
                    - If you want to return React elements on more than one line, you must wrap your return value in `()`
                    - Look ma, no quotes! (...because JSX isn't a string)
                    
                </section>
                <section data-markdown>
                    # JSX Gotchas
                    
                    - There must be **exactly one outer-most element returned** with your JSX (so you can't return sibling elements, only a parent with children)
                    - To add a comment in JSX use: `{/* a comment */}`
                    - If you need to add a `class` to an element, you must use `className`
                    - If you need to add a `for` attribute, you must use `htmlFor`
                    
                    *Conintued...*
                </section>
                <section data-markdown>
                    # More JSX Gotchas
                    
                    - Self-closing tags must have a `/` before the `>`
                    - Event listener names must be camel case (e.g. `onClick`)
                    - JSX must be transformed into real JS to be parsed by ES5 JS engines (we'll use Babel for that)
                </section>
                <section data-markdown>
                    Exercise 2
                    
                    Your turn! Time to create your first React component...
                    
                    Open a Codepen and try creating a React Component that simply adds the "So Much To Do" `<h1>` to an app.
                    
                    Note that in Codepen, you don't explicitly import `React` or `ReactDOM`, but you will need to go to the Settings tab in the JS panel to "Quick-add" these libraries to your pen.
                </section>
                <section data-markdown>
                    # The Virtual DOM
                    
                    - The virtual DOM is an **in-memory representation of real DOM elements** generated by React components before any changes are made to the page
                    - It exists on the top of the DOM or some other render target
                    - When changes are made to the virtual DOM, React figures out the best way to **batch those changes** to the underlying DOM structure
                </section>
                <section data-markdown>
                    .inline-images[
                    ![Virtual DOM Diff](/public/img/slide-assets/virtual-dom-diff.png)
                 ]
                </section>
                <section data-markdown>
                    .large[
                    [Or this diagram...](https://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/stack/book/Intro.html)
                  ]
                </section>
                <section data-markdown>
                    # Why This Matters
                    
                    - The DOM wasn't designed for creating dynamic UIs
                    - Web apps exist so that users can interact with them in a task-oriented way&mdash;this means that users can/will influence the state of the app, and we need some way to render those changes to the DOM
                    - The virtual DOM helps with performance in this regard (versus directly manipulating the DOM)
                </section>
                <section data-markdown>
                    # Creating a React App
                </section>
                <section data-markdown>
                    <blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Marc was almost ready to implement his &quot;hello world&quot; React app <a href="https://t.co/ptdg4yteF1">pic.twitter.com/ptdg4yteF1</a></p>&mdash; Thomas Fuchs (@thomasfuchs) <a href="https://twitter.com/thomasfuchs/status/708675139253174273">March 12, 2016</a></blockquote>
                    <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
                </section>
                <section data-markdown>
                    .large[
                    Some initial steps...
                 ]
                </section>
                <section data-markdown>
                    # Software Installation
                    
                    Facebook makes it easy to configure a build set-up for a basic React app with their **[Create React App](https://github.com/facebookincubator/create-react-app)**. To install it globally on your system, run:
                    
                    `npm install -g create-react-app`
                    
                    We'll also want to install the **[React Developer Tools for Chrome](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en)** to assist with debugging.
                </section>
                <section data-markdown>
                    # ToDo App Set-up
                    
                    In the exercises that follow, we're going to create a basic to-do app using React. To create you app, run the following command in an appropriate directory:
                    
                    `create-react-app react-todo`
                    
                    Now `cd` into your `react-todo` directory, and run:
                    
                    `npm start`
                    
                    You should now be able to access the app on **http://localhost:3000**.
                </section>
                <section data-markdown>
                    # What We Have Now
                    
                    A boilerplate React app with:
                    
                    - Babel transpiling (so we can use ES2015 and JSX)
                    - Webpack for bundling
                    - ESLint for catching mistakes
                    - A development server
                    
                    *All with zero configuration!!*
                </section>
                <section data-markdown>
                    # Working with Components
                </section>
                <section data-markdown>
                    # Conditional Rendering
                    
                    Sometimes we need to conditionally render content in a component:
                    
                    ```js
                    render() {
                      let hello = true;
                    
                      return (
                        <div>
                          <h1>Awesome App</h1>
                          { hello &&
                            <p>Hello, world!</p>
                          }
                        </div>
                      );
                    }
                    ```
                </section>
                <section data-markdown>
                    # Conditional Rendering
                    
                    Or with if-else:
                    
                    ```js
                    render() {
                      let hello = true;
                    
                      return (
                        <div>
                          <h1>Awesome App</h1>
                          { hello ? (
                            <p>Hello, world!</p>
                          ) : (
                            <p>Goodbye, world!</p>
                          )}
                        </div>
                      );
                    }
                    ```
                </section>
                <section data-markdown>
                    # Conditional Rendering
                    
                    We can be more verbose for clarity:
                    
                    ```js
                    render() {
                      let hello = true;
                      let greeting = null;
                    
                      if ( hello ) {
                        greeting = <p>Hello, world!</p>;
                      } else {
                        greeting = <p>Goodbye, world!</p>;
                      }
                    
                      return (
                        <div>
                          <h1>Awesome App</h1>
                          { greeting }
                        </div>
                      );
                    }
                    ```
                </section>
                <section data-markdown>
                    # Conditional Rendering
                    
                    This is a bit more compact:
                    
                    ```js
                    render() {
                      let hello = true;
                    
                      return (
                        <div>
                          <h1>Awesome App</h1>
                          <p>{ hello ? 'Hello, world!' : 'Goodbye, world!' }</p>
                        </div>
                      );
                    }
                    ```
                </section>
                <section data-markdown>
                    # Conditional Rendering
                    
                    React components can also use switch statements:
                    
                    ```js
                    render() {
                      let myValue = 2;
                    
                      switch( myValue ) {
                        case 1:
                          return <div>Only one</div>;
                        case 2:
                          return <div>More than one</div>;
                        default:
                          return null;
                      }
                    }
                    ```
                    
                    Returning `null` tells the component not to render.
                </section>
                <section data-markdown>
                    Iterating Over Arrays
                    
                    We will often want to create components that display data by iterating over a list of array items. This is easy to do in React using JS' built-in `.map()` method and an arrow function:
                    
                    ```js
                    class App extends Component {
                      render() {
                        const skills = ['React', 'Angular 2', 'Vue.js'];
                    
                        return (
                          <ul>
                            {skills.map((skill, i) => (<li key={i}>{skill}</li>))}
                          </ul>
                        );
                      }
                    }
                    ```
                    
                    Notice the use of `{}` to wrap JS expressions inside JSX.
                </section>
                <section data-markdown>
                    # Iterating Over Arrays
                    
                    Wondering what's up with the `key` attribute on the `<li>`?
                    
                    The `key` attribute helps React keep track of **dynamic children** (i.e. where child items may be added, removed, re-sorted, etc.).
                    
                    Even if your children aren't going to change in any way, **React will complain** to you in the browser console if you don't add a unique `key` for each item.
                    
                    **Note:** Using the array item's **index is not ideal** (because these can change), so other unique values should be used for keys if possible.
                    
                </section>
                <section data-markdown>
                    # Exercise 3
                    
                    Open `App.js` in your React app and delete the default content in the `render()`.
                    
                    In its place, set up an array as a constant called `todos` and add 'Learn React' as the only item.
                    
                    Next, use what you just learned about `.map()` and iterating over arrays in a component to list the to-do array item inside an unordered list element.
                    
                    You can also remove the default logo `import` and delete the file too.
                    /section>
                <section data-markdown>
                    # Types of Components
                    
                    There are two way we will create components:
                    
                    1. Using ES2015 classes
                    2. Using stateless functions
                </section>
                <section data-markdown>
                    # ES2015 Class
                    
                    We've already seen an example of a React component built using an ES2015 class:
                    
                    ```js
                    class App extends Component {
                       render() {
                          return (
                             <h1 id="title">Hello, world!</h1>
                          );
                       }
                    }
                    ```
                </section>
                <section data-markdown>
                  # Stateless Function
                  
                  In more recent versions of React, we can also build components using this syntax:
                  
                  ```js
                  const App = () => {
                    return (
                      <h1 id="title">Hello, world!</h1>
                    );
                  }
                  
                  // Or more succinctly...
                  const App = () => <h1 id="title">Hello, world!</h1>;
                  ```</section>
                <section data-markdown>
                    # What's the Diff?
                    
                    - Stateless functional components allow us to create components that are meant to be **pure functions of their props** (more on props in a moment!)
                    - They **do not retain internal state**
                    - They do not have the **component lifecycle methods** (i.e. no `render()`, etc.)
                    - Later this week we will use ES2015 classes to create **Container Components** and the stateless functional approach to create **Presentational Components**...
                </section>
                <section data-markdown>
                    # Naming Components
                    
                    When naming components, the convention is to use **PascalCase**. We also want to make sure we name our components in a way that makes sense given the larger context of our app.
                    
                    The key is to **be descriptive**, and start with a **base noun** so components can be easily categorized. For example:
                    
                    ```js
                    <PostsContainer />  ->  <Posts />
                    <Posts />           ->  <PostList />, <Post />
                    <Post />            ->  <PostListItem />, <PostDetails/>
                    ``` 
                </section>
                <section data-markdown>
                    # Exercise 4
                    
                    Add CSS to your app by copying the styles from **[the files in this gist](https://gist.github.com/mandiwise/d6c9cb0a6e9edc20e24b6cd973cdb6d7)**, clearing out the default styles in `App.css` and `index.css`, and pasting the copied styles respectively. Also wrap the `<ul>` in a `<div>` with a class of `todo-list` (remember how to treat class attributes in React).
                    
                    Finally, create a stateless functional component called `ToDo` and move your list item into it, then call `.map()` on the new `<ToDo>` component instead.
                    
                    Be sure to move the `key` attribute from your `<li>` onto the `<ToDo />` inside the `.map()` function. Your app will be broken now but we'll find out why in a minute!
                </section>
                <section data-markdown>
                    # Adding Props
                </section>
                <section data-markdown>
                    .large[
                    **Problem:**<br />We have a reference error in the `<ToDo />` component.
                 ]
                </section>
                <section data-markdown>
                    .large[
                    **Solution:**<br />Fix it with props!
                 ]
                </section>
                <section data-markdown>
                    # Props
                    
                    - **Arguments passed to React components** are called props
                    - Props allow us to provide **configuration values** for a given component
                    - They look a lot like plain ol' HTML attributes
                    - **ES2015 Components:** Arguments passed as props can be accessed using the `this.props` object
                    - **Functional Stateless Components:** `props` should be passed in as an argument to the arrow function (or destructuring may be used to access specific props directly)
                </section>
                <section data-markdown>
                    # Props Example
                    
                    Using a prop allows us to specify a unique greeting for each `<HelloWorld />` component:
                    
                    ```js
                    const HelloWorld = (props) => (
                       <h1>{props.greeting}</h1>
                    );
                    
                    // Or with destructuring...
                    // const HelloWorld = ({ greeting }) => (
                    //    <h1>{greeting}</h1>
                    // );
                    ```
                    
                    ```js
                    class App extends Component {
                       render() {
                          return (
                             <HelloWorld greeting="Hello world, of course!" />
                          );
                       }
                    }
                    ```
                </section>
                <section data-markdown>
                    # Exercise 5
                    
                    Based on what you just learned about props, fix the reference error in the `ToDo` component.
                    
                    Specifically, think about how you will pass the `todo` item from the the `App` component to the `ToDo` component as a prop called `item`.
                    
                    Try using the **destructuring approach** when accessing the `item` prop in the `ToDo` component.
                    
                    While you're at it, add `<h1>So Much To Do</h1>` to the top of your to-do list to give it a title.
                </section>
                <section data-markdown>
                    # Exercise 6
                    
                    Our to-do items will need to be a bit more complex than they are. Rather being derived from a simple array of string values, they will need to be derived from an **array of objects** where each object has an `id`, `title`, and `complete` property.
                    
                    ```js
                    render() {
                       // const todos = ['Learn React']; REMOVE THIS!
                       const todos = [
                          { id: 0, title: 'Learn React', complete: false }
                       ];
                       // ...
                    }
                    ```
                    
                    Make this change. Your app will be broken again...what needs to be updated in your `ToDo` component now?
                </section>
                <section data-markdown>
                    # Exercise 7
                    
                    Our app needs a couple more components. First, create a `ToDoCount` component with a `number` prop to display the number of to-dos in the list **with** the word "todo" or "todos" displayed depending on how many items are present.
                    
                    Next, create a `ClearButton` component with `removeCompleted` prop. This component's prop will be set to function that will fire on the button's `onClick` event.
                    
                    Once you've created your new components, add them to your `App` inside of a `<div>` with a class of `todo-admin`. You can pass any integer for the `number` prop and an empty string for the `removeCompleted` prop for now.
                </section>
                <section data-markdown>
                    # this.props.children
                    
                    Every component's `props` object has a property named `children`.
                    
                    Why do we need this? It's because not all components use self-closing tags. For example:
                    
                    ```html
                    <HelloWorld>I am a child of HelloWorld.</HelloWorld>
                    ```
                    
                    In this example, `this.props.children` would equal "I am a child of HelloWorld."
                </section>
                <section data-markdown>
                    # this.props.children
                    
                    We can also render components inside of other components:
                    
                    ```js
                    class HelloWorld extends React.Component {
                      render() {
                        return (
                          <div>
                            {this.props.children}
                          </div>
                        );
                      }
                    }
                    
                    class App extends React.Component {
                      render() {
                        return (
                          <HelloWorld>
                            <h1 id="title">Hello, world!</h1>
                          </HelloWorld>
                        );
                      }
                    }
                    ```
                </section>
                <section data-markdown>
                    # Proptypes
                    
                    Proptypes are a feature of React that allow us validate whether props were set on a component as expected, e.g. if a prop:
                    
                    - is required
                    - contains a primitive type
                    - is an array containing only items of a specified type
                    - is an object with a specific shape
                    - satisfies a condition set out in a custom validator
                    - **[...etc.](https://facebook.github.io/react/docs/typechecking-with-proptypes.html)**
                </section>
                <section data-markdown>
                    # Using Proptypes
                    
                    To use proptypes, you'll need to import `Proptypes` from `prop-types` in your `App.js` file:
                    
                    ```bash
                    npm install --save prop-types
                    ```
                    
                    ```js
                    import React, { Component } from 'react';
                    import PropTypes from 'prop-types';
                    
                    class HelloWorld extends Component {
                       // the component's code...
                    }
                    
                    HelloWorld.propTypes = {
                       greeting: PropTypes.string.isRequired
                    };
                    ```
                    
                    What do you think this `propType` necessitates when using the component?
                </section>
                <section data-markdown>
                    # Default Props
                    
                    We can also set defaults for our components props, which will take effect if no prop is set where the component is used:
                    
                    ```js
                    import React, { Component } from 'react';
                    import PropTypes from 'prop-types';
                    
                    class HelloWorld extends Component {
                       // the component's code...
                    }
                    
                    HelloWorld.propTypes = {
                       greeting: PropTypes.string
                    };
                    
                    HelloWorld.defaultProps = {
                      greeting: 'Hello, world!'
                    };
                    ```
                </section>
                <section data-markdown>
                    # Exercise 8
                    
                    Add proptypes for the `ToDo`, `ToDoCount`, and `ClearButton` components.
                    
                    We need our `todo` prop to be an object with a specific set of properties, so you will need to use `PropTypes.shape()` for that. Use the React doc's reference on **[Prop Validation](https://facebook.github.io/react/docs/typechecking-with-proptypes.html)** to find out how to do this.
                    
                    Make all of the props for all components **required**.
                    
                    **Note:** You will end up with a warning in your console for one of your props if you successfully completed the exercise. Why does this happen?
                </section>
                <section data-markdown>
                    # Looking Ahead
                    
                    Preparing for tomorrow's exercises, our `ToDo` component will need to be more than a simple list item&mdash;it will need to include a checkbox input as well. Make the following adjustment to the mark-up rendered by the `ToDo` component:
                    
                    ```js
                    const ToDo = ({item}) => (
                       <li>{item.title}
                          <input
                             type="checkbox"
                             id={item.id}
                             checked={item.complete} />
                          <label htmlFor={item.id}></label>
                          <button>
                             <i className="fa fa-trash"></i>
                          </button>
                       </li>
                    );
                    ```
                </section>
                <section data-markdown>
                    # To-Do App To-Dos
                    
                    Tomorrow we will need to:
                    
                    - Create an input for adding new to-do items
                    - Add functions to add and remove to-do items
                    - Add a function for marking a to-do as complete
                    - Add a function to clear all of the completed to-dos from the list at once
                </section>
                <section data-markdown>
                    # What We've Learned
                    
                    - What React is
                    - How to use it in a project and how to use the "Create React App" tool
                    - What JSX and the Virtual DOM are
                    - How to create React components
                    - How to add props to React components
                    
                </section>
                <section data-markdown>
        
                  # Questions?
                </section>
          </section>




          <section>
              <section data-markdown>
                  # React State and Events
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Setting a component's initial state
                  2. Changing state in response to events
                  3. Working with component refs
                  4. Using React's "lifecycle methods"
              </section>
              <section data-markdown>
                  # Today's To-Do To-Dos
                  
                  - Create an input for adding new to-do items
                  - Add functions to add and remove to-do items
                  - Add a function for marking a to-do as complete
                  - Add a function to clear all of the completed to-dos from the list at once
              </section>
              <section data-markdown>
                  # Setting Initial Component State
              </section>
              <section data-markdown>
                  ### What is application state?
                  
                  **State** is where we store data that will change over time.
              </section>
              <section data-markdown>
                  .large[
                  What are some examples of how state will change in the Boomtown app?
               ]
              </section>
              <section data-markdown>
                  # State in React
                  
                  Recall that in React we don't manipulate the DOM directly.
                  
                  When we need to update the state of our app, we update a component's **state object** and then let React take care of rendering the updates to the DOM.
                  
                  We can access a component's state object via `this.state`.
              </section>
              <section data-markdown>
                  # One-way Data Flow
                  
                  React is all about **one-way data flow** down the component hierarchy (vs. two-way data binding that you may have heard of in AngularJS, etc.).
                  
                  Two-way data binding means that when properties in the model get updated so does the UI, and similarly, when a UI element is updated the model changes too.
                  
                  One-way data flow means that the model is the single source of truth. Only the model has access to change the app's state.
              </section>
              <section data-markdown>
                  # State Example
                  
                  We often want to conditionally change an app's UI depending on application state:
                  
                  ```js
                  class App extends Component {
                    // other code...
                  
                    render() {
                      let mood = this.state.happy ? 'Hello, world!' : 'Scram, world!';
                  
                      return (
                        <h1 id="title">{mood}</h1>
                     );
                    }
                  }
                  ```
                  
                  *But where do we set our `happy` state?*
              </section>
              <section data-markdown>
                  # State Example
                  
                  We set a component's initial state in the class `constructor`:
                  
                  ```js
                  class App extends Component {
                    constructor() {
                      super();
                      // set state here...
                     }
                  
                    // render things here...
                  }
                  ```
                  
                  **Note:** In ES2015 class constructors, `this` cannot be used until `super` is called.
                  
                  **Also Note:** When writing React in ES5 you set state in the `getInitialState` method instead of a class `constructor`.
              </section>
              <section data-markdown>
                  # State Example
                  
                  Now we can set our application initial state in `this.state` in the class `constructor`:
                  
                  ```js
                  class App extends Component {
                    constructor() {
                      super();
                  
                      this.state = {
                        happy: true
                      }
                    }
                  
                    render() {
                      let mood = this.state.happy ? 'Hello, world!' : 'Scram, world!';
                  
                      return (
                        <h1 id="title">{mood}</h1>
                      );
                    }
                  }
                  ```
              </section>
              <section data-markdown>
                  .large[
                  **Insight:** Components are just state machines.
               ]
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  We want our first placeholder to-do item to be set in our app's initial state (not as a constant inside the `render` method).
                  
                  Create a constructor in your `App` component and set a property called `todos` to the array of the single placeholder to-do object. Remove the `todos` const from `render`.
                  
                  Set another property (separate from `todos`) called `lastId` and set to the integer `0`. We will need be using this later.
                  
                  Once again, our app will be broken now. How do we fix this?
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Now that our `todos` are stored in our `App`'s state, let's make the `ToDoCount`'s `number` prop dynamic.
                  
                  To do that, we will need to get the length of the array in `this.state.todos` and populate the `number` prop with that count dynamically when the `App` component is rendered.
                  
                  Try implementing this now.
              </section>
              <section data-markdown>
                  .large[
                  **Important!** We can't set state in **stateless** functional components (of course).
               ]
              </section>
              <section data-markdown>
                  # Events in React
              </section>
              <section data-markdown>
                  # What Changes State?
                  
                  Apps are task-oriented by nature. There are many actions that a user could take to alter that state of an application. Interactions that may alter state include:
                  
                  - Clicking a button or link
                  - Submitting a form
                  - Sending Ajax request
                  - ...etc.
                  
                  The **event handlers** we create will control how state is updated in our components.
                  
              </section>
              <section data-markdown>
                  # Synthetic Events
                  
                  **Synthetic events** in React help us make sure that events have consistent properties across browsers.
                  
                  React passes our event handlers through instances of `SyntheticEvent`, which helps consolidate browser behaviours into one API. Cross-browser compatibility FTW.
                  
                  Check out the docs for a full list of **[supported events in React](https://facebook.github.io/react/docs/events.html?#supported-events)**.
              </section>
              <section data-markdown>
                  # Updating State
                  
                  Our to-do app won't be very useful until we can add, check-off, and remove to-dos from the list. To do that, we will need some way to update component state.
                  
                  **Important!** Outside of a component's class `constructor`, we don't assign (or re-assign) to the state object directly.
                  
                  Instead, we will call `this.setState()` and pass it an appropriate object as an argument.
                  
                  Calling `this.setState()` **will only update the properties passed as  an argument**, not replace the entire state object.
              </section>
              <section data-markdown>
                  # Updating State
                  
                  What `this.setState()` looks like in action:
                  
                  ```js
                  class App extends Component {
                    constructor() {
                      super();
                  
                      this.state = {
                        happy: true
                      }
                    }
                  
                    toggleMood() {
                      // this.state.happy = false; DO NOT DO!
                      this.setState({ happy: ! this.state.happy }); // DO DO!!
                    }
                  
                    // other code...
                  }
                  ```
                  
                  **Where might we call `toggleMood()`?**
              </section>
              <section data-markdown>
                  .large[
                  **Insight:** Whenever state changes in a component, React will re-render the component for us.
               ]
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Let's write a method for our component to toggle the state of the checkbox when it is clicked (i.e. checked or not checked). To do this you'll need to add a `toggleComplete` method to the `App` component. It should take `item` as a parameter.
                  
                  Whether a to-do is complete is determined by whether the `complete` property in its state object is `true` or `false`.
                  
                  Using `.map()` on `this.state.todos`, you will need to selectively set the toggled to-do's `complete` property to the alternative, and then update the component state with the newly mapped array of objects in `todos`.
              </section>
              <section data-markdown>
                  .large[
                  Our `toggleComplete` method doesn't do much for us yet...
               ]
              </section>
              <section data-markdown>
                  .large[
                  **Challenge:** How do we use `App`'s `toggleComplete` method to update a `ToDo`'s state based on some event?
               ]
              </section>
              <section data-markdown>
                  # Props vs. State
                  
                  - `props` are set by parent components
                  - A component **cannot** change it's own props (it can set a child component's `props` though)
                  - `props` are only set at element definition time
                  - A component's state can change from within (and when it does, the virtual DOM is re-rendered)
                  - State can be used to define props for child components
              </section>
            <section data-markdown>
                # Next Steps
                
                We will need to add a `toggleComplete` prop to our `ToDo` component inside `App`:
                
                ```js
                render() {
                   // other code...
                   return (
                      // ...
                      <ul>
                      { this.state.todos.map((todo) => (
                         <ToDo
                            key={todo.id}
                            item={todo}
                            toggleComplete={this.toggleComplete.bind(this, todo)} 
                          />
                      ))}
                      </ul>
                      // ...
                   );
                }
                ```
            </section>
            <section data-markdown>
                # Binding?
                
                Methods don't automatically bind `this` to an instance in ES2015. This means we need to explicitly use `.bind()` or an arrow function to bind event handlers.
                
                Calling `.bind()` on the `toggleComplete` method and passing in `this` as the first argument allows us to maintain the appropriate scope context for the current instance.
                
                And why do we pass `todo` as a second argument after supplying the context of `this` as the first argument? Because `.bind()` will pass the value of `todo` as an argument **where the bound function is called**.
            </section>
            <section data-markdown>
                # Using the Method
                
                Now that our parent `App` component has set `toggleComplete` as a prop on `ToDo`, we will use it within our `ToDo` component on the `onChange` attribute:
                
                ```js
                const ToDo = ({item, toggleComplete}) => (
                   <li>{item.title}
                      <input
                         type="checkbox"
                         id={item.id}
                         checked={item.complete}
                         onChange={toggleComplete} />
                      {/* other code... */}
                   </li>
                );
                ```
                
                *Be sure to update your `ToDo` proptypes with the new prop too!*
                
            </section>
            <section data-markdown>
    
            </section>
            <section data-markdown>
                # Exercise 4
                
                In your `App` component, now add a method to remove a to-do item from the list when the garbage can icon is clicked on a given `ToDo` component.
                
                To do this, you will need to add a `removeToDo` prop to your `ToDo` component, and pass in a `removeToDo` method from the `App` component. This method should be called `onClick` on the button wrapping the garbage can icon.
                
                **Hint:** To remove a to-do from the array of to-do objects stored in the state, you will need to call `.filter()` to create a new array of to-dos containing only the items **that are not the current item**, and set that new array to the value of `todos`.
            </section>
            <section data-markdown>
                # Binding Event Handlers in the Constructor
                
                We have seen how we can bind event handlers directly where component prop is set.
                
                However, where we don't need to pass in a specific `todo` item as a second argument to `.bind()`, we can simply bind the event handler in the constructor so they are only bound once for every instance.
                
                This is good for performance!
            </section>
            <section data-markdown>
                # In Practice
                
                Let's add an `removeCompleted` method to our `App` component to clear all completed to-do items when the "Clear completed" button is clicked:
                
                ```js
                removeCompleted() {
                   let todos = this.state.todos.filter((todo) => !todo.complete);
                   this.setState({ todos });
                }
                ```
                
                Now we will bind it in our `App` constructor:
                
                ```js
                constructor() {
                   super();
                   // other code...
                   this.removeCompleted = this.removeCompleted.bind(this);
                }
                ```
            </section>
            <section data-markdown>
                # In Practice
                
                And finally, we will pass it as a prop to the `ClearButton` component:
                
                ```js
                <ClearButton removeCompleted={this.removeCompleted} />
                ```
                
                **Bonus!** The proptype warning message is the console should be gone now that we have passed a method into that prop instead of an empty string.
            </section>
            <section data-markdown>
                # Exercise 5
                
                Now add a `hasCompleted` method to the `App` component to conditionally display the "Clear completed" button.
                
                **Hint:** You're going to need to use `.filter()` again to determine if there are any to-do items in the `todos` array that have `complete` set to `true`, and conditionally display the button based on the length of that filtered array.
                
                How can you use this new method to conditionally render the `ClearButton` component in the `App` component now?
                
                **Note:** The `hasCompleted` method isn't an event handler, so it doesn't need to be bound in the constructor (or elsewhere).
            </section>
            <section data-markdown>
                # Working with Refs
            </section>
            <section data-markdown>
                # Next Up...
                
                We still need to add a very important part of our to-do app&mdash;the input that will allow us to add new to-dos!
                
                Start by adding this mark-up in-between the `<h1>` and `<ul>` rendered in your `App` component:
                
                ```js
                <div className="add-todo">
                   <form name="addTodo" onSubmit={this.addToDo}>
                      <input type="text" ref={(input) => (this.toDoInput = input)} />
                      <span>(press enter to add)</span>
                   </form>
                </div>
                ```
                
                Look at the mark-up for this form...what new event handler will we need to add? What other strange thing do you notice?
            </section>
            <section data-markdown>
                # Refs to Components
                
                React gives us a special attribute that can be attached to any component called `ref`.
                
                The `ref` attribute can be a callback function where the referenced component will be passed in as a parameter:
                
                ```js
                <input type="text" ref={(input) => (this.toDoInput = input)} />
                
                // What's actually happening here...
                
                <input type="text"
                   ref={ function(input) { this.toDoInput = input }.bind(this) } />
                
                ```
                
                **Why does this matter?** We need refs to access values from within a specific input element.
            </section>
            <section data-markdown>
                # Using a Ref
                
                Add this method to your `App` and bind it in the constructor:
                
                ```js
                addToDo(event){
                   event.preventDefault();
                   const id = this.state.lastId + 1;
                
                   if (this.toDoInput.value) {
                      let newToDos = this.state.todos.concat({
                         id,
                         title: this.toDoInput.value,
                         complete: false
                      });
                
                      this.setState({
                         todos: newToDos,
                         lastId: id
                      });
                
                      this.toDoInput.value = '';
                   }
                }
                ```
            </section>
            <section data-markdown>
                # Using a Ref
                
                **What the `ref` gives us:**
                
                Adding the `ref` to the input in our `App` component allow us to reference the value entered into that input inside of our event handler via `this.toDoInput.value`, and use the value to update the component's state.
                
                Without the `ref` we would not be able to get this value because JSX doesn't actually return a component instance (just a lightweight representation of what the mounted component should look like).
            </section>
            <section data-markdown>
                # Component Lifecycle Methods
            </section>
            <section data-markdown>
                ### Component Lifecycle?
                
                We have already seen how we can set the initial state of a component using a component's class `constructor`, and also how to direct React to display a component using the required `render` method.
                
                React gives us more opportunities to run code that will affect a component as it is **mounted**, **updated**, and **unmounted**.
                
            </section>
            <section data-markdown>
                # Lifecycle Methods
                
                - `componentWillMount` (mounting)
                - `componentDidMount` (mounting)
                - `componentWillReceiveProps` (updating)
                - `shouldComponentUpdate` (updating)
                - `componentWillUpdate` (updating)
                - `componentDidUpdate` (updating)
                - `componentWillUnmount` (unmounting)
                
            </section>
            <section data-markdown># Exercise 6
                
                Last but not least, we want to improve the UX of our to-do app and automatically focus the `<input>` element when the app is rendered.
                
                To do that, we'll need to use one of React's lifecycle methods. It's up to you to pick the right one and implement the code within it to focus the `<input>`.</section>
            <section data-markdown>
                # State Cheatsheet
                
                - Initial state is set in the `constructor` with `this.state` (whereas props are passed from the outside only)
                - You inform a component of a state change by calling `this.setState()` (and you **can't** call it within `render()`)
                - When you update state in a component, it merges the new data with the data already contained in `this.state`
                - Keep state as simple as possible, and don't put other React components or props in the state object
                - Keep as many of your components as possible stateless
            </section>
            <section data-markdown>
                # What We've Learned
                
                - How to set an component's initial state in a `constructor`
                - How to alter state in response to some event
                - How to use the `ref` attribute on a component
                - What React's lifecycle methods can do
            </section>
          </section>




          <section>
              <section data-markdown>
                  # React Router
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Container vs. Presentational Components
                  2. Using React Router</section>
              <section data-markdown>
                  # Container vs. Presentational Components
              </section>
              <section data-markdown>
                  # Why the Diff?
                  
                  In React, it's very easy to mix code that controls the behaviour of our app with code that renders the view.
                  
                  As a result, our code will become more **tightly coupled** than it should be. This makes our components less modular and harder to reuse.
                  
                  To avoid this, we will organize our project into **Container Components** and **Presentational Components**.
              </section>
              <section data-markdown>
                  # In Use
                  
                  We've already seen an approximate example of this pattern in the to-do app&mdash;where the stateful `App` component **passes down props** to a stateless child component.
                  
                  We have also seen how a stateful parent component **can pass down an event handler too** to a stateless child component. The child component then uses that event handler to update the parent's state.
              </section>
              <section data-markdown>
                  .large[
                  Container components are concerned with **how things work**.
               ]
              </section>
              <section data-markdown>
                  .large[
                  Presentational components are concerned with **how things look**.
               ]
              </section>
              <section data-markdown>
                  # Cheatsheet #1
                  
                  *Container components:*
                  
                  - Should be responsible for **fetching data**
                  - Should **define event handlers** and pass them down as props
                  
                  *Presentational components:*
                  
                  - Should **never change prop data** (only receive it)
                  - Should **format the data** for the view only
              </section>
              <section data-markdown>
    
    .large[
    Knowing this, what type of components should we use for presentational and container components?
    ]
              </section>
              <section data-markdown>
                  # Cheatsheet #2
                  
                  Container | Presentational
                  ----------|---------------
                  Stateful  | Stateless
                  Classes   | Functions
                  Impure    | Pure
                  
                  **Note:** Container and presentational components can be represented on either side of these dichotomies, however, presentational components tend to be **stateless, pure functions** while container components tend to be **stateful classes** that **may or may not be pure**.
              </section>
              <section data-markdown>
                  # In Practice
                  
                  ```js
                  // CONTAINER COMPONENT
                  
                  class Posts extends React.Component {
                    constructor() {
                      super();
                      this.state = {
                        posts: [{ title: 'Hello, world!' }]
                      };
                    }
                  
                    render() {
                      return <PostList posts={this.state.posts} />;
                    }
                  }
                  
                  // PRESENTATIONAL COMPONENT
                  
                  const PostList = ({ posts }) => (
                    <ul>
                      { posts.map((post) => <li>{post.title}</li>) }
                    </ul>
                  );
                  ```
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Review the components that you have created for the Boomtown app so far. What should be classified as a container component, and what should be classified as a presentational component?
                  
                  Do some project reorganization based on these observations. Remember that your `import` file paths will likely break when you do this and you'll need to fix them!
              </section>
              <section data-markdown>
                # Routing with React</section>
              <section data-markdown>
                  ### What is routing?
                  
                  Routing allows us to create readable URLs that describe the content loaded in a single-page application, and allows the user to navigate forward and backward through a SPA.
                  
                  In other words, routing allows us to take a path and use it to generate the correct components to populate the UI.
              </section>
              <section data-markdown>
                  # About Routing
                  
                  **Note!**
                  
                  We're building a SPA, so our application uses **a single static HTML file** to display all of it's content.
                  
                  **When routes changes** in our application, we must ensure that:
                  
                  - The URL in the address bar reflects what is being shown
                  - Forward and back nav work in the browser
                  - The user can navigate to a new URL and they will see the expected view
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Visit **[Reddit](http://reddit.com)**. Click on several links and map out how the urls are structured:
                  
                  - hot posts
                  - new posts
                  - submitting posts
                  - comment on posts
                  - a subReddit
                  - showing posts only posted in the past hour
              </section>
              <section data-markdown>
                  # An Example
                  
                  Let's create a new React app to test out some of React Router's features. First run:
                  
                  `create-react-app router-demo`
                  
                  Then install React Router:
                  
                  `npm install react-router-dom --save`
                  
                  *Remember that React is a library, not a framework. Installing `react-router-dom` gives it more framework-like capabilities.*
              </section>
              <section data-markdown>
                  # Adding the Router
                  
                  To use React Router, we'll need to import it into our app. 
                  
                  Add this code to your `App.js` file:
                  
                  ```js
                  import { 
                    BrowserRouter as Router, 
                    Route,
                    Switch,
                    Link,
                    Redirect
                  } from 'react-router-dom';
                  ```
              </section>
              <section data-markdown>
                  # Router Basics
                  
                  We just imported four different modules that we will use set up routing in our app:
                  
                  - `BrowserRouter`: used to wrap all of the routes we define
                  - `Route`: used for identifying each route (inclusively)
                  - `Switch`: used to render the first child `Route` that matches the location
                  - `Link`: used to navigate around an application
                  - `Redirect`: used to navigate to a new location, like server-side redirects (HTTP 3xx) do
                  
              </section>
              <section data-markdown>
                  # Adding the Router
                  
                  Now replace the default app content with the following:
                  
                  ```js
                  const Home = () => <h1>Hello, World!</h1>;
                  const Contact = () => <h1>Get in touch!</h1>;
                  
                  class App extends Component {
                    render() {
                      return (
                        <Router>
                          <div>
                            <Route exact path="/" component={Home} />
                            <Route path="/contact" component={Contact} />
                          </div>
                        </Router>
                      );
                    }
                  }
                  ```
              </section>
              <section data-markdown>
                  # Adding the Router
                  
                  *Things to note...*
                  
                  `Router` and `Route` **don't render anything by themselves**. They just define rules for our app. Each `Route` renders its `component`.
                  
                  Also note that `Router` **can only have one child**, so multiple `Route` components should be wrapped in a `div`, etc.
                  
                  Lastly, the `exact` qualifier ensures that the `path` prop **exactly matches what's in the browser address bar** before rendering the component.
              </section>
              <section data-markdown>
                  # Adding a 404 Page
                  
                  We can also use the `Route` component to render something for any undefined route. First, create a component to render when there's a 404:
                  
                  ```js
                  const NotFound = () => <h1>Whoops. You broke the internet again.</h1>;
                  ```
                  
                  Then add the route:
                  
                  ```js
                  <Route component={NotFound} />
                  ```
                  
                  Look ma, no path! But now there's a bug we need to fix...
              </section>
              <section data-markdown>
                  # Switch
                  
                  `Switch` allows us to render a route **exclusively**, i.e. it allows us to pick only one `Route` to render at a given path:
                  
                  ```js
                  <Router history={history}>
                    <div>
                      <Switch>
                        <Route exact path="/" component={Home} />
                        <Route path="/contact" component={Contact} />
                        <Route component={NotFound} />
                      </Switch>
                    </div>
                  </Router>
                  ```
              </section>
              <section data-markdown>
                  # Rendering: 3 Ways
                  
                  There are 3 ways to show components for a given `Route`.
                  
                  We have already seen the first, using the `component` prop:
                  
                  ```js
                  <Route exact path="/" component={Home} />
                  ```
              </section>
              <section data-markdown>
                  # Rendering: 3 Ways
                  
                  We can also use the `render` prop and pass it a function:
                  
                  ```js
                  <Route exact path="/" render={() => <h1>Hello, World!</h1>} />
                  ```
                  
                  **Note:** Defining this function elsewhere (rather than passing in an anonymous function) would likely be preferable though.
              </section>
              <section data-markdown>
                  # Rendering: 3 Ways
                  
                  Lastly, we can use the `children` prop:
                  
                  ```js
                  <Route 
                    path ="/match-me" 
                    children={({ match }) => match && <p>It matched!</p>} 
                  />
                  ```
                  
                  The difference between `render` and `children` is that the function passed into `children` will always run (regardless of whether there is a match), **unless** you explicitly check for a match using the `match` parameter in the function.
              </section>
              <section data-markdown>
                  # Link Components
                  
                  The `Link` component allows you to link directly to the routes you have defined. Let's make a nav bar for our app:
                  
                  ```js
                  const NavBar = () => (
                    <div>
                      <Link to="/">Home</Link> 
                      <Link to="/contact">Contact</Link> {/* include forward slash! */}
                    </div>
                  );
                  ```
                  
                  ```js
                  <div>
                    <NavBar />
                    <Switch>
                      <Route path="/" exact component={Home} />
                      <Route path="/contact" component={Contact} />
                      <Route component={NotFound} />
                    </Switch>
                  </div>
                  ```
              </section>
              <section data-markdown>
                  # NavLink Components
                  
                  The `NavLink` component is like a `Link`, but with special feature that makes it better for setting up navigation menus.
                  
                  Ultimately, it allows us to add style-related attributes to the rendered element when it matches the current URL.
                  
                  Let's' use the `NavLink` instead. First, import the component from `react-router-dom`:
                  
                  ```js
                  import {
                    // ...other imports
                    NavLink
                  } from 'react-router-dom';
                  ```
                  
              </section>
              <section data-markdown>
                  # NavLink Components
                  
                  Note that if you added any qualifiers to your route you need to add the same ones to your `NavLink` as well...
                  
                  ```css
                  .selected {
                    color: red;
                  }
                  ```
                  
                  ```js
                  const NavBar = () => (
                    <div>
                      <NavLink to="/" exact activeClassName="selected">Home</NavLink>
                      <NavLink to="/contact" activeClassName="selected">Contact</NavLink>
                    </div>
                  );
                  ```
                  
                  You can also use the `activeStyle` prop with the `NavLink` and pass it a style object.
              </section>
              <section data-markdown>
                  # Nested Routes
                  
                  What if we want to define routes somewhere that isn't the top-level `App` component?
                  
                  We can use **nested routes** for that. Let's start by adding a route for a Posts page in our `App` component:
                  
                  ```js
                  <Router>
                    <div>
                      <NavBar />
                      <Switch>
                        <Route path="/" exact component={Home} />
                        <Route path="/contact" component={Contact} />
                        <Route path="/posts" component={Posts} />
                        <Route component={NotFound} />
                      </Switch>
                    </div>
                  </Router>
                  ```
              </section>
              <section data-markdown>
                  # Nested Routes
                  
                  Now create your `Posts` component with its nested routes:
                  
                  ```js
                  const Posts = ({ match }) => (
                    <div>
                      <h1>Blog</h1>
                      <Route 
                        path={`${match.url}/hello-world`}
                        render={({ match }) => <h2>Hello, World!</h2>}
                      />
                      <Route 
                        path={`${match.url}/scram-world`}
                        render={({ match }) => <h2>Scram, World!</h2>}
                      />
                    </div>
                  );
                  ```
                  
                  Note the use of `match` to dynamically grab the path of the `Posts` component route.
              </section>
              <section data-markdown>
                  # Redirects
                  
                  Redirects, as they suggest take the user to a different route. They can be rendered for or nested in a route:
                  
                  ```js
                  <Route render={() => (
                    loggedIn ? (
                      <Redirect to="/dashboard"/>
                    ) : (
                      <LoginForm />
                    )
                  ) />
                  ```
                  
                  Or used inside a `Switch` component:
                  
                  ```js
                  <Switch>
                    <Redirect from ="/old" to="/new" />
                    <Route path='/new' component={New} />
                  </Switch>
                  ```
              </section>
              <section data-markdown>
                  # URL Parameters
                  
                  URL parameters allow us to navigate to routes with some sort of variable segment in the URL using via **route matching**:
                  
                  ```js
                  const Posts = ({ match }) => (
                    <div>
                      <h1>Blog</h1>
                      <Route 
                        path={`${match.url}/:name`}
                        render={({ match }) => <h2>{match.params.name}</h2>}
                      />
                    </div>
                  );
                  ```
                  
                  *Much DRYer!*
              </section>
              <section data-markdown>
                  # URL Parameter Example
                  
                  Back to [reddit.com](https://www.reddit.com/):
                  
                  ```bash
                  # homepage
                  /
                  
                  # re-directs to /subreddits
                  /r
                  
                  # homepage of Subreddit
                  /r/space
                  
                  # browse all comments for the Subreddit
                  /r/space/comments
                  
                  # redirects to URL below
                  /r/space/comments/5lxs89
                  
                  # browse comments page for post
                  /r/space/comments/5lxs89/clouds_of_andromeda
                  
                  # URL for specific comment
                  /r/space/comments/5lxs89/clouds_of_andromeda/dbztmtr
                  ```
              </section>
              <section data-markdown>
                  # URL Parameter Example
                  
                  If we were building actual Reddit in React, our specific comment URLs might look like this:
                  
                  ```bash
                  /r/:subRedditName/comments/:postId/:postName/:commentId
                  ```
                  
                  The parts that start with `:` are URL parameters whose values will be parsed out and made available in `props.match.params.PARAM_NAME` in your component.
              </section>
              <section data-markdown>
                  # Query Strings
                  
                  React Router 4 **does not have a built-in way to parse query strings** at the end of an URL (e.g. `?sort=popular`).
                  
                  You can, however, link to an URL with a query string in the `to` props of a `Link` component like this:
                  
                  ```js
                  <Link to={% raw %}{{pathname: `${match.url}`, search: '?sort=popular'}}{% endraw %}>
                    Sort by Popularity
                  </Link>
                  ```
                  
                  Add this to your `Posts` component. You can then access the query string for the route in `props.location.search`.
              </section>
              <section data-markdown>
                  # Query String Example
                  
                  We can then use the emerging [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) standard to parse the query string, but we will need to add a polyfill to ensure support for older browsers:
                  
                  ```bash
                  npm install url-search-params-polyfill --save
                  ```
                  
                  Then import the polyfill wherever you plan on instantiaing a new `URLSearchParams`:
                  
                  ```js
                  import 'url-search-params-polyfill';
                  ```
              </section>
              <section data-markdown>
                  # Query String Example
                  
                  You can then parse your query string `id` param like this:
                  
                  ```js
                  const Posts = ({ match, location }) => {
                    const searchParams = new URLSearchParams(location.search);
                    const sortValue = searchParams.get('sort');
                  
                    return (
                      <div>
                        <h1>Blog</h1>
                        <Link to={% raw %}{{pathname: `${match.url}`, search: '?sort=popular'}}{% endraw %}>
                          Sort by Popularity
                        </Link>
                        <Route 
                          path={`${match.url}/:name`}
                          render={({ match }) => <h2>{match.params.name}</h2>}
                        />
                        {sortValue && <p>You are sorting by "{sortValue}" right now.</p>}
                      </div>
                    )
                  };
                  ```
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Based on what you just learned in the preceding examples, apply this to your project now. You will need to create routes that point users to:
                  
                  - The Items List page (`/`)
                  - The Login page (`/login`)
                  - The Share an Item page (`/share`)
                  - The individual User Profile pages (`/profile/[ID_HERE]`)
                  - A 404 page
              </section>
              <section data-markdown>
                  # History and URLs
              </section>
              <section data-markdown>
                  # Dealing with History
                  
                  React Router offers more than one type of top-level router component. We have see the `BrowserRouter` so far, but there's also a `HashRouter`.
                  
                  Hash history **works without configuring a server**. It uses `window.location.hash` and that's why we have `#` showing up in our URLs, even though we didn't put it there ourselves:
                  
                  - **Home:** http://localhost:3000/#/
                  - **Contact:** http://localhost:3000/#/contact/
              </section>
              <section data-markdown>
                  # Hash vs. Browser
                  
                  The `BrowserRouter` (used in our demo) uses the **[Browser History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)** and will eliminate the hashes from your URLs:
                  
                  - **Home:** http://localhost:3000/
                  - **Contact:** http://localhost:3000/contact
                  
                  **But there's a catch!** We need a server to use this...one that will always return `index.html` at any route. (Using the Browser History API also enables us to use server-side rendering.)
                  
                  Luckily, there's a server already configured in Create React App.
              </section>
              <section data-markdown>
                  # Browser History Demo
                  
                  Try visiting this article about the Browser History API:
                  
                  **https://css-tricks.com/using-the-html5-history-api/**
                  
                  Open your dev tools console, and run this code, line by line:
                  
                  ```js
                  window.history
                  
                  // Run this, then try navigating back and forth
                  history.replaceState(null, null, 'hello');
                  
                  // Run this, now try navigating back and forth again
                  history.pushState(null, null, 'hello');
                  ```
                  
                  What do you notice? Be sure to watch the browser's address bar will you do this...
              </section>
              <section data-markdown>
                  # Hash vs. Browser
                  
                  *Some further clarification...*
                  
                  - Hashes in URLs were meant to refer to a specific place in the document, so adding/changing a hash was a way to update the URL with `window.location` without refreshing the page (in a SPA)
                  - `hashHistory` works on the client side alone
                  - `browserHistory` (as stated) requires a server to always return `index.html` regardless of what "resource" is requested
              </section>
              <section data-markdown>
                  # Hash vs. Browser
                  
                  *Why bother with `hashHistory` at all?*
                  
                  You would use `hashHistory` if you're worried about supporting <IE9 (without full page re-loads). Or perhaps if you're deploying a site on GitHub Pages...
                  
                  It's also helpful it you're building a quick and dirty React app and don't want to go to the trouble of setting up a server to handle `browserHistory` right away.s></IE9>

              </section>
              <section data-markdown>
                  # Other Routers
                  
                  `MemoryRouter`:
                  
                  - An entirely in-memory router (doesn't depend on URLs in the browser address bar)
                  - Useful for testing and proof-of-concept
                  
                  `StaticRouter`:
                  
                  - Meant to be used with server-side rendering
                  
                  `NativeRouter`:
                  
                  - For use in React Native apps
              </section>
              <section data-markdown># withRouter
                  
                  Sometimes you need to access to the `history` object’s properties (or the `match` or `location` props) outside of named route in your app. 
                  
                  To do this, you can wrap the component that needs access to these props in the `withRouter` **higher-order component (HOC)** from React Router.</section>
              <section data-markdown>
                  # withRouter
                  
                  Example of `withRouter` in use:
                  
                  ```js
                  import React, { PropTypes } from 'react';
                  import { withRouter } from 'react-router-dom';
                  
                  const Header = ({ history }) => (
                    <button onClick={() => history.push('/')}>Go Home</button>
                  );
                  
                  Header.propTypes = {
                    match: PropTypes.object.isRequired,
                    location: PropTypes.object.isRequired,
                    history: PropTypes.object.isRequired
                  }
                  
                  export default withRouter(Header); // THIS IS HOW WE USE IT!
                  ```
                  
                  *We'll do a lot more with HOCs in our app when we add Redux next week...*
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - What container components and presentational components are for, and how to use them to make components more reusable
                  - How to use the `react-router` to set up SPA-style routing in a React app
              </section>
          </section>



          <section>
              <section data-markdown>
                  # Functional Programming
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. What is functional programming
                  2. Pure vs. Impure
                  3. Array methods (mapping, filtering, reducing, etc.)
                  4. Immutability
              </section>
              <section data-markdown>
                  # What is Functional Programming?
              </section>
              <section data-markdown>
                  ### FP FTW!
                  
                  Functional programming is a **programming paradigm** just like object-oriented or procedural programming is.
                  
                  In functional programming, computation is treated as **the transformation of data through functions**.
              </section>
              <section data-markdown>
                  # How Is It Different?
                  
                  Some characteristics of functional programming include:
                  
                  - Use of pure functions
                  - Avoids shared state, mutable data, and side effects
                  - Declarative (using expressions) instead of imperative (using statements)
                  
                  ???
                  
                  - Question to class: explain the different between declarative and imperative programming
                  - What are the relative pros and cons of each? e.g. Abstraction vs. efficiency
                  
                  Functional vs. OOP:
                  
                  - IN OOP, objects are little state machines.
                  - In FP, functions take in state and return new state.
              </section>
              <section data-markdown>
                  # Sidebar: FP Origins
                  
                  **Lambda Calculus!**
                  
                  Functional programming traces its roots back to the Lambda calculus was invented by Alonzo Church in the 1930s.
                  
                  It treats **functions as black boxes**&mdash;it takes inputs to functions and processes them in some way and gives you a single output. 
                  
                  Functions are also **meant to be pure**, so they have no internal state (i.e. no hidden information).
                  
                  Ultimately, it gives us **a way to encode any computation.**
                  
                  ???
                  
                  Lambda calculus is the basis of all functional programming languages, and now can be found in most programming languages.
                  
                  Lambda calculus essentially consists of three things:
                  
                  1. Variables
                  2. A way of building functions
                  3. A way of applying functions
                  
                  Any Turning Machine program can be translated into Lambda calculus, and vice versa (potential inefficiency aside).
              </section>
              <section data-markdown>
                  # Lambda Calculus
                  
                  - In Lambda calculus, **functions are just like numbers and numbers are just like functions** (in fact, you don't even need numbers!)
                  - Functions can consume other functions as arguments, and produce other functions as arguments as results (aka **higher order functions**)
                  - It has interesting implications, like the Y-combinator (invented by Haskell Curry), which is a way to do **recursion** in a language that doesn't have any looping or recursion mechanism (written as `Y = λf.(λx.f(xx))(λx.f(xx))`)
                  
                  ???
                  
                  Talk about "first class functions" in JS:
                  
                  - JS supports constructing new functions during the execution of a program, storing them in data structures, passing them as arguments to other functions, and returning them as the values of other functions
                  
                  Talk about "higher order functions" in JS:
                  
                  - Functions that operate on other functions, either by taking them as arguments or by returning them
                  - Where have you seen higher order functions in use (event handlers, map, filter, reduce, etc.)
              </section>
              <section data-markdown>
                  # FP in the Wild
                  
                  Some languages that are highly functional in nature include Clojure, Erlang, F#, and Haskell.
                  
                  Other languages (like JS!) support a functional programming style to varying degrees (even PHP).
                  
                  Support for **first-class functions** and **higher-order functions** in the language is key!
                  
                  ???
                  
                  - JS has properties of an untyped functional language
                  - But it can also be used in an OOP or imperative way
              </section>
              <section data-markdown>
                  # Pure vs. Impure Functions
              </section>
              <section data-markdown>
                  ### Functional programming is about writing *pure* functions.
                  
                  *Fill in the blank:*
                  
                  **Pure functions are...**
                  
                  ???
                  
                  Straight out of pre-work reading...
                  
                  - Portable / Self-documenting
                  - Testable
                  - Cacheable (by input)
                  - Referentially transparent, which means it can be substituted for its evaluated value without changing the behavior of the program
                  - Parallelizable
              </section>
              <section data-markdown>
                  # Pure Function Structure
                  
                  A pure function has three parts:
                  
                  ```
                  1. Input(s)
                        |
                        V
                  2. Transformation
                        |
                        V
                  3. Output(s)
                  ```
                  
                  ???
                  
                  - Remember that it's meant to be a self-contained black box!
                  - This function should not produce any side effects in the outside world
                  - So no matter how many times you run the function with the same inputs you should get the same output
              </section>
              <section data-markdown>
                  # Pure or Impure?
                  
                  Determine whether the following functions are **pure** or **impure**. 
                  
                  Be sure to justify your reasons as we will be discussing these as a class afterward.
              </section>
              <section data-markdown>
                  # 1.
              </section>
              <section data-markdown>
                  ### A toaster
                  
                  ???
                  
                  - This is up for debate, the students will likely think pure, but...
                  - What about the ambient temperature of the air effecting how long it takes to toast the bread?
                  - What about the side effect of heat lost to the environment?
                  - What's stopping you from putting a fork in there instead of bread?
                  
              </section>
              <section data-markdown>
    
                    # 2.
              </section>
              <section data-markdown>
                  ### A person who eats toast.
                  
                  ???
                  
                  - Impure (lasting side effects in your body from eating the bread)
              </section>
              <section data-markdown>
                  # 3.
                  
                  ```js
                  function addOne(x) {
                    return x + 1;
                  }
                  ```
                  
                  ???
                  
                  - Pure
              </section>
              <section data-markdown>
                  # 4.
                  
                  ```js
                  function addOne(x) {
                    console.log(x + 1);
                  }
                  ```
                  
                  ???
                  
                  - Impure
              </section>
              <section data-markdown>
                  # 5.
                  
                  ```js
                  let x = 0
                  function addOne() {
                    x += 1;
                    return x;
                  }
                  ```
                  
                  ???
                  
                  - Impure
              </section>
              <section data-markdown>
                  # 6.
                  
                  ```js
                  const addOne = (function() {
                    let x = 0;
                    return function() {
                      return x += 1;
                    }
                  })();
                  ```
                  
                  ???
                  
                  - Depends which function you're looking at...
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Create examples of pure functions in JavaScript for each of the following cases:
                  
                  1. A function used as an input to another function
                  2. A function created as an output from another function
                  3. A function that calls itself
                  
                  Be prepared to demo your functions for the class.
              </section>
              <section data-markdown>
                  # Array Methods
              </section>
              <section data-markdown>
                  # Array Methods
                  
                  In your browser console, type `Array.prototype.`:
                  
                  .inline-images[
                    ![Array methods in console](/public/img/slide-assets/arrayMethod.png)
                  ]
                  
                  *What array methods are autocompleted?*
              </section>
              <section data-markdown>
                  .large[
                  Why do we care?
                ]
              </section>
              <section data-markdown>
                  # Imperative: How
                  
                  Tell the computer **how** to do it, step by step.
                  
                  ```js
                  let list = [1, 2, 3];
                  
                  // loop over each item
                  for (let i = 0; i < list.length; i++) {
                    // add 1 to each item
                    list[i] = list[i] + 1;
                    // remove even numbers
                    if (list[i] % 2 === 0) {
                      list.splice(i+1, 1);
                    } 
                    // multiply the number by 10
                    list[i] = list[i] * 10;
                  }
                  ```
              </section>
              <section data-markdown>
                  # Declarative: What
                  
                  Describe the "transformation",  i.e. **what** should happen.
                  
                  ```js
                  const list = [1, 2, 3];
                  
                  list.map(addOne)
                      .filter(isOdd)
                      .map(multiplyTen);
                  ```
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  With a partner, **compare** and **categorize** the following array methods. How are they different? When should each be used?
                  
                  - `forEach`
                  - `map`
                  - `concat`
                  - `push`
                  - `slice`
                  - `splice`
              </section>
              <section data-markdown>
                  ### Map, Filter & Reduce...
                  
                  These array methods will change your life as a dev :)
              </section>
              <section data-markdown>
                  .large[Map:]
                  
                  .inline-images[
                    ![Map a fruit array](/public/img/slide-assets/array-map.png)  
                  ]
                  
                  .footnote.right[Image source: [ATEN](https://atendesigngroup.com/blog/array-map-filter-and-reduce-js)]
              </section>
              <section data-markdown>
                  # Map
                  
                  Slice fruit in JavaScript:
                  
                  ```js
                  const fruits = ['apple', 'orange', 'banana'];
                  
                  const fruitSlices = fruits.map(fruit => fruit.substring(0, 2));
                  
                  // ["ap", "or", "ba"]
                  ```
              </section>
              <section data-markdown>
                  .large[Filter:]
                  
                  .inline-images[
                    ![Filter a fruit array](/public/img/slide-assets/array-filter.png)  
                  ]
                  
                  .footnote.right[Image source: [ATEN](https://atendesigngroup.com/blog/array-map-filter-and-reduce-js)]
              </section>
              <section data-markdown>
                  # Filter
                  
                  Pick only oranges in JavaScript:
                  
                  ```js
                  const fruits = ['apple', 'orange', 'banana'];
                  
                  const orangesOnly = fruits.filter(fruit => fruit === 'orange');
                  
                  // ["orange"]
                  ```
              </section>
              <section data-markdown>
                  .large[Reduce:]
                  
                  .inline-images[
                    ![Reduce a fruit array](/public/img/slide-assets/array-reduce.png)  
                  ]
                  
                  .footnote.right[Image source: [ATEN](https://atendesigngroup.com/blog/array-map-filter-and-reduce-js)]
              </section>
              <section data-markdown>
                  # Reduce
                  
                  Make fruit salad in JS:
                  
                  ```js
                  const fruits = ['apple', 'orange', 'banana'];
                  
                  const fruitSalad = fruits.reduce((prev, curr) => prev + curr);
                  
                  // "appleorangebanana"
                  ```
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Turn this list:
                  
                  ```js
                  const list = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                  ```
                  
                  Into `[8, 6, 4, 2]` using array methods and **only one line of code**. Do not mutate the original `list` array!
                  
                  Once you figure this out, add `.sort()` to the end of your array method chain.
                  
                  Now add `10` to the original list. What happens when you sort it now? Why do you think this happens?
              </section>
              <section data-markdown>
                  # Exercise 4
                  
                  Flatten then add together this array using `.reduce()`, so:
                  
                  `[[0, 1], [2, 3], [4, 5]]`
                  
                  Becomes this:
                  
                  `[0, 1, 2, 3, 4, 5]`
                  
                  Then this:
                  
                  `15`
              </section>
              <section data-markdown>
                  # Immutability
                  
              </section>
              <section data-markdown>
                  # Immutability
                  
                  Functional programming avoids mutatable data because mutating data in your program makes it harder to read and more error-prone.
                  
                  Using `const` does not solve this problem, because `const` only creates an *immutable binding*.
                  
                  ```
                  const person = {};
                  person.name = 'Bob'; // this is fine! 
                  person = 'Bob'; // this is not fine
                  ```
              </section>
              <section data-markdown>
                  # Exercise 5
                  
                  In small groups, you'll have 15 minutes to understand your assigned topic (in relation to avoiding mutating object data) and teach it to the class using examples:
                  
                  1. `Object.assign`
                  2. `...` spread operator
                  3. `Object.freeze`
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - What functional programming is
                  - The difference between a pure and impure function
                  - How to use different array methods, such as map, filter, and reduce
                  - How to avoid mutating objects in JS
              </section>
          </section>




          
              <section>
                  <section data-markdown>
                      # Redux
                      
                      .title-logo[![Red logo](/public/img/red-logo-white.svg)]
                  </section>
                  <section data-markdown>
                      # Agenda
                      
                      1. Whys, whats, and hows Redux
                      2. Setup a basic project using Redux in plain vanilla JS
                  </section>
                  <section data-markdown>
                      # What Problem Does Redux Solve?
                  </section>
                  <section data-markdown>
                      .large[
                      Redux is a predictable state container for JavaScript apps.
                    ]
                    
                    ???
                    
                    - That also uses one-way data flow!
                    - Get students to discuss what they think this means in plain English
                  </section>
                  <section data-markdown>
                      ### Recall...
                      
                      How did state management and data flow work in the todo app last week? Did this feel like the best solution?
                      
                      ???
                      
                      Challenges:
                      
                      - Passing properties down the tree
                      - Handling local state within a component
                      - Passing callbacks down the tree
                  </section>
                  <section data-markdown>
                      .large[
                      How can we fix these issues?
                    ]
                  </section>
                  <section data-markdown>
                      # What if...
                      
                      - All app state was stored in a single immutable object?
                      - That state was was available anywhere within our app?
                      - Actions were decoupled from component hierarchy?
                  </section>
                  <section data-markdown>
                      .large[
                      How would that change the design of our app?
                    ]
                  </section>
                  <section data-markdown>
                      # Using Redux
                      
                  </section>
                  <section data-markdown>
                      # Three Principles of Redux
                      
                      1. There's a **single source of truth** for all application state
                      2. That state is **read-only**
                      3. Changes to application state are made with **pure functions**
                      
                      ???
                      
                      Single source of truth:
                      
                      - Regardless of the size of the application, all state data is stored in a single object
                      - This makes it much easier to debug or inspect your application!
                      
                      Read-only:
                      
                      - In Redux neither views nor network callbacks mutate state directly
                      - Because we don't mutate the state directly (just copy it and combine it with the updates), this makes it possible to "time travel" through our app state changes in the Redux dev tools
                      
                      Pure functions
                      
                      - We use actions in Redux, which are simple JavaScript objects that express an intent to mutate the state object
                      - Then you write a special function called a reducer to decide how every action transforms the entire application's state
                      - Reducers are just pure functions that take the previous state and an action, and return the next state
                  </section>
                  <section data-markdown>
                      # Redux Keywords
                      
                      - **Store:** where all your application state lives
                      - **Actions:** how you describe a change to be made to state
                      - **Reducers:** the pure functions that update the store with the new state object
                      
                      ???
                      
                      Redux, in a nutshell:
                      
                      - The whole state of your app is stored in an object tree inside a single store
                      - The only way to change the state tree is to emit an action, an object describing what happened
                      - To specify how the actions transform the state tree, you write pure reducers
                  </section>
                  <section data-markdown>
                      .inline-images[
                      ![Redux diagram](/public/img/slide-assets/redux.png)
                    ]
                    
                    .footnote.right[Image source: [Scotch.io](https://scotch.io/bar-talk/getting-started-with-redux-an-intro)]
                  </section>
                  <section data-markdown>
                      Before we start, **[install Redux DevTools](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en)**:
                      
                      .inline-images[
                        ![Redux Devtools](/public/img/slide-assets/reduxdevtools.gif)
                      ]
                  </section>
                  <section data-markdown>
                      # Premise & Set-up
                      
                      Before we learn how to integrate Redux with React, we're going learn the basics of Redux by improving fruit inventory state management in our grocery store from yesterday.
                      
                      We'll be rebuilding our grocery store from scratch with Redux, so **begin by creating a new directory** for this lesson with an `src/index.js` file in it, create an empty `dist` directory, and then `npm init` in the root directory.
                      
                  </section>
                  <section data-markdown>
                      # Webpack Installation
                      
                      Install Webpack and its dependencies in your project:
                      
                      ```bash
                      npm install --save-dev babel-loader babel-core babel-preset-stage-0 webpack webpack-dev-server html-webpack-plugin
                      ```
                      
                      Add scripts to your `package.json`:
                      
                      ```js
                      // ...
                      "scripts": {
                        "start": "webpack && webpack-dev-server",
                        "build": "webpack -p",
                      },
                      // ...
                      ```
                      
                      Also include a `webpack.config.js` file to your project root director too and add the provided snippet.
                      
                      ???
                      
                      Give the students this snippet for their Webpack config:
                      
                      ```js
                      const webpack = require('webpack');
                      const resolve = require('path').resolve;
                      const src = resolve(__dirname, 'src');
                      const dist = resolve(__dirname, 'dist');
                      const HtmlWebpackPlugin = require('html-webpack-plugin');
                      
                      module.exports = {
                        entry: {
                          app: './src/index.js',
                        },
                      
                        output: {
                          path: dist,
                          filename: 'bundle.js',
                        },
                      
                        module: {
                          rules: [
                            {
                              test: /\.js$/,
                              loader: 'babel-loader',
                              include: [src],
                              exclude: /node_modules/,
                              query: {
                                presets: ['stage-0']
                              }
                            },
                          ]
                        },
                      
                        plugins: [new HtmlWebpackPlugin()]
                      }
                      ```
                  </section>
                  <section data-markdown>
                      # Redux Installation
                      
                      Install Redux:
                      
                      ```bash
                      npm install --save redux
                      npm install --save-dev redux-devtools-extension
                      ```
                      
                      Now start your Webpack dev server:
                      
                      ```
                      npm start
                      ```
                  </section>
                  <section data-markdown>
                      .large[
                      What kind of actions do you think our store will need?
                    ]
                    
                    ???
                    
                    - one to count fruit
                    - one to stock up
                    - one to explain
                  </section>
                  <section data-markdown>
                      # Redux Set-up
                      
                      We will co-locate our related Redux actions, action creators, and reducers in appropriately named files.
                      
                      Create a new directory in `src` called `redux`, and another directory called `modules` within it, and a `fruit.js` module file within that:
                      
                      ```bash
                      mkdir -p src/redux/modules
                      touch src/redux/modules/fruit.js
                      ```
                      
                      ???
                      
                      - Note that we will mostly adhere to the Ducks pattern to structure our Redux code: https://github.com/erikras/ducks-modular-redux
                  </section>
                  <section data-markdown>
                      # Our First Action
                      
                      Remember that actions plain JS objects that contain payloads of information that send data from your application to your store. Action objects must have a `type` property to indicate the type of action being performed.
                      
                      As a best practice, we define string constants to use as the values for our action object `type` property.
                      
                      So in `fruit.js` add:
                      
                      ```js
                      const GET_FRUIT_COUNT = 'GET_FRUIT_COUNT';
                      ```
                  </section>
                  <section data-markdown>
                      # The Action Creator
                      
                      Now we need an **action creator** to actually create the corresponding action object in `fruit.js`:
                      
                      ```js
                      export const getFruitCount = () => ({
                        type: GET_FRUIT_COUNT
                      });
                      ```
                  </section>
                  <section data-markdown>
                      # Exercise 1
                      
                      Now create action string constants for stocking up fruit and explaining the current fruit stock.
                      
                      Note that the action creator for stocking up fruit will need to be set-up with a parameter of `count` so we can pass some information along in the action's payload about how much to update the inventory in our grocery store state.
                      
                      You can set the value of `count` on a `payload` property in this action object.
                      
                  </section>
                  <section data-markdown>
                      # A Bit More Set-up...
                      
                      Before we create our reducer, we'll need to add our initial fruit inventory data to our app, and abstract our prototype methods into helper functions.
                      
                      Create `inventory.js` and add your fruit data as a named export, then add `helpers.js` and add `countFruit`, `stockUp`, and `explain` functions to this file as named exports (based on the work you did yesterday).
                      
                      What modifications will you need to make to these functions to make them into more generic helpers?
                  </section>
                  <section data-markdown>
                      # What's in a Reducer?
                      
                      Actions describe the fact that something happened, but don't specify how the application's state changes in response&mdash;that's where reducers come in. The basic function signature of a reducer is:
                      
                      ```js
                      export default (state = {}, action) => {
                        switch (action.type) {
                          case SOME_ACTION_CONSTANT: {
                            return {
                              ...state, // not mutating state!
                              someData: action.payload
                            };
                          }
                          default:
                            return state;
                          }
                      };
                      ```
                      
                      ???
                      
                      Remember:
                      
                      - Use pure functions (don't mutate anything!)
                      - Generally built using `switch`
                      - Default to returning the existing state
                      - Set initial state with a default parameter
                      - It's a good idea to think about what shape you want your state object to be before writing any code
                      
                      Things you should never do inside a reducer:
                      
                      - Mutate its arguments
                      - Perform side effects like API calls and routing transitions
                      - Call non-pure functions, e.g. Date.now() or Math.random()
                  </section>
                  <section data-markdown>
                      .large[
                      Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation.
                    ]
                    
                    (From the [Redux docs](http://redux.js.org/docs/basics/Reducers.html))
                  </section>
                  <section data-markdown>
                      # The Reducer
                      
                      ```js
                      import { fruit } from '../../inventory';
                      import { countFruit, stockUp, explain } from '../../helpers';
                      
                      // action, action creators here...
                      
                      export default (state = {
                        inventory: fruit,
                        originalList: {},
                        currentList: {},
                        counted: false
                      }, action) => {
                        switch (action.type) {
                          case GET_FRUIT_COUNT: {
                            const originalList = ???; // how to define this?
                            const currentList = ???; // and this?
                            return { ...state, originalList, currentList, counted: true };
                          }
                          // check for other types here...
                          default:
                            return state;
                          }
                      };
                      ```
                      
                      ???
                      
                      - Work through this with the students!
                  </section>
                  <section data-markdown>
                      # Exercise 2
                      
                      Now that you've take care of the `GET_FRUIT_COUNT` action in the produce reducer, finish off building out the cases for the `UPDATE_FRUIT_STOCK` and `EXPLAIN_FRUIT_STOCK` action types.
                      
                      How will you ensure that the original and current lists of fruit stocks are added to the store even if the user doesn't fire off the `GET_FRUIT_COUNT` action first?
                  </section>
                  <section data-markdown>
                      # Combining Reducers
                      
                      Before we create our store, we'll use the `combineReducers` function to combine all of our module reducers into one, even through we only have one right now!
                      
                      Add this to `src/redux/reducers.js`:
                      
                      ```js
                      import { combineReducers } from 'redux';
                      import produceReducer from './modules/produce';
                      
                      export default combineReducers({
                       produce: produceReducer
                      });
                      ```
                  </section>
                  <section data-markdown>
                      # Creating the Store
                      
                      Create a `src/redux/store.js` file now, the import redux into the file:
                      
                      ```js
                      import { createStore } from 'redux';
                      import rootReducer from './reducers';
                      
                      export default createStore(rootReducer);
                      ```
                      
                      ???
                      
                      - Remember that the store is where we ultimately keep all of our application state (it's the single source of state truth)
                      - Redux provides a `dispatch` method for updating the state in the store
                      - Redux also provides a `getState` method for getting state info from the store
                      - It allows us to register change listeners to update our views based on state using `subscribe`
                  </section>
                  <section data-markdown>
                      # Exercise 3
                      
                      Now that you have your actions, reducers, and store created, you can actually dispatch actions to your store and get state from your store.
                      
                      Head over to `index.js` in the root of your app, import the store, import the action creator functions, then try dispatching the three actions and get something from the store:
                      
                      ```js
                      store.dispatch(getFruitCount());
                      store.dispatch(updateFruitStock(10));
                      store.dispatch(explainFruitStock());
                      // try console-logging something from the store with store.getState() 
                      ```
                  </section>
                  <section data-markdown>
                      # What Just Happened?
                      
                      The data lifecycle in any Redux app follows these 4 steps:
                      
                      1. You called `store.dispatch(action)`
                      2. The Redux store called the reducer function you gave it
                      3. The root reducer combined the output of all reducers into a single state tree
                      4. The Redux store saved the complete state tree returned by the root reducer
                  </section>
                  <section data-markdown>
                      # Subscribe to Changes
                      
                      To see each consecutive change made to the store, add the following code above your dispatches:
                      
                      ```js
                      let unsubscribe = store.subscribe(() =>
                        console.log(store.getState())
                      );
                      ```
                      
                      Then add this after the dispatches:
                      
                      ```js
                      unsubscribe();
                      ```
                      
                      Check out your console once your app refreshes.
                  </section>
                  <section data-markdown>
                      # Exercise 4
                      
                      Console logs are fine, but there's a better way! Integrate your store with the [Redux Dev Tools extension now](https://github.com/zalmoxisus/redux-devtools-extension).
                      
                      To do that you'll need to import `devToolsEnhancer` from `redux-devtools-extension` into `store.js` and then pass `devToolsEnhancer()` as a second argument to `createStore`.
                      
                      You'll know it's working when you can see the contents of your store in your browser's Redux dev tools.
                  </section>
                  <section data-markdown>
                      # What We've Learned
                      
                      - What Redux is for and what problem it solves
                      - What actions, reducers, and stores are
                      - How to set-up Redux in a simple app
                  </section>
          </section>



          <section>
              <section data-markdown>
                  # Redux Middleware
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. What is middleware?
                  2. Currying and composition
                  3. Write a logger middleware
                  4. Use middleware for async operations and in different environments
              </section>
              <section data-markdown>
                  # What is Middleware?
              </section>
              <section data-markdown>
                  # What Does It Do?
                  
                  In Redux, middleware provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.
                  
                  Middleware allows us to do things like logging and makes API requests in our action creators. Without middleware, Redux store only supports synchronous data flow.
                  
                  *Where do you think we'll need to use this in Boomtown?*
              </section>
              <section data-markdown>
                  .inline-images[
                  ![Redux middleware diagram](/public/img/slide-assets/redux_middleware.gif)
                ]
                
                .footnote.right[Image source: [Our Way of Life](https://prmadi.com/getting-started-with-react-native-app-and-parse/)]
                
                ???
                
                We can see here that middleware gives us a chance to intercept a dispatched action before reaching the reducer.
              </section>
              <section data-markdown>
                  # But First, Function Currying & Composition!
              </section>
              <section data-markdown>
                  # More FP Concepts
                  
                  In addition to what we've already learned about functional programming, we'll need to understand a couple more concepts to implement middleware in Redux:
                  
                  - Currying
                  - Function composition
              </section>
              <section data-markdown>
                  # Currying
                  
                  When currying, you call a function with fewer arguments than it expects. It returns a function that takes the remaining arguments.
                  
                  The idea with currying is that A function can move throughout your application and gradually receive the arguments it needs.
              </section>
              <section data-markdown>
                  # An Example
                  
                  Non-curried function:
                  
                  ```js
                  const madLibs = (ingVerb, number, nameOfPerson) => (
                    `When people begin ${ingVerb} in outer space,
                    they will have to spend ${number} years just getting
                    to the nearest solar system, called ${nameOfPerson}.`
                  );
                  
                  madLibs('hitch-hiking', '42', 'Arthur Dent');
                  ```
                  
                  Curried version:
                  
                  ```js
                  const curriedMadLibs = ingVerb => number => nameOfPerson => (
                    `When people begin ${ingVerb} in outer space,
                    they will have to spend ${number} years just getting
                    to the nearest solar system, called ${nameOfPerson}.`
                  );
                  
                  curriedMadLibs('hitch-hiking')('42')('Arthur Dent');
                  ```
              </section>
              <section data-markdown>
                  # Without Arrows
                  
                  Using regular functions makes it easier to see what's going on:
                  
                  ```js
                  const curriedMadLibsNoArrows = function(ingVerb) {
                    return function (number) {
                      return function (nameOfPerson) {
                        return `When people begin ${ingVerb} in outer space,
                          they will have to spend ${number} years just getting
                          to the nearest solar system, called ${nameOfPerson}.`
                      }
                    }
                  }
                  
                  curriedMadLibsNoArrows('hitch-hiking')('42')('Arthur Dent');
                  ```
              </section>
              <section data-markdown>
                  # Partial Application
                  
                  You can partially apply a curried function too:
                  
                  ```js
                  const curriedMadLibs = ingVerb => number => nameOfPerson => (
                    `When people begin ${ingVerb} in outer space,
                    they will have to spend ${number} years just getting
                    to the nearest solar system, called ${nameOfPerson}.`
                  );
                  
                  const how = curriedMadLibs('hitch-hiking');
                  const timeTo = how('42');
                  const where = timeTo('Arthur Dent');
                  ```
                  
                  ???
                  
                  - Partial application and currying are not the same thing! (though related)
                  - Currying is a function that takes a function with multiple parameters as input and returns a function with exactly one parameter
                  - Partial application is the process of applying a function to some of its arguments
                  - The partially applied function gets returned for later use, i.e. a function that takes a function with multiple parameters and returns a function with fewer parameters
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Re-write this function as a curried function:
                  
                  ```js
                  const greeting = (greeting, name) => {
                    return `${greeting}, ${name}`;
                  };
                  ```
                  
                  Try using partial application with your curried function too.
                  
                  ---
                  class: center, middle
                  
                  .large[
                    Middleware is created by **composing** functionality that wraps separate cross-cutting concerns which are not part of your main execution task.
                  ]
                  
                  ???
                  
                  - In the case of Redux middleware the main execution task is the store’s dispatch function
                  - What might be an example of a "cross-cutting" concern?
              </section>
              <section data-markdown># Function Composition
                  
                  - The most common use for currying in functional programming is to make it easier to **compose functions**
                  - Function composition is the process of **combining two or more functions to produce a new function**
                  - Think of it as "breeding" functions, or mashing them together to produce a brand new one
                  - Composition is **associative** so it doesn't matter how you group them (as long as the operands are in the same order)
                  
                  ???
                  
                  Demonstrate associativity:
                  
                  ```js
                  const comp = f => g => x => f(g(x));
                  
                  const inc = x => x + 1;
                  const dec = x => x - 1;
                  const sqr = x => x * x;
                  
                  comp(comp(dec) (sqr)) (inc) (2); // 8
                  comp(dec) (comp(sqr) (inc)) (2); // 8
                  ```</section>
              <section data-markdown>
                  # Math!
                  
                  We would express function composition in math like this:
                  
                  `f(g(x))` (evaluated from the inside out)
                  
                  And in JavaScript:
                  
                  ```js
                  var compose = function(f, g) {
                    return function(x) {
                      return g(f(x));
                    }
                  };
                  
                  // ES2015!
                  // const compose = (f, g) => x => g(f(x));
                  ```
                  
                  `f` and `g` are functions and `x` is the value being piped through them.
                  
                  ???
                  
                  Clear math example:
                  
                  ```
                  given:
                    f(x) = x^2 + 3x + 1
                    g(x) = 2x
                  then:
                    (f ∘ g)(x) = f(g(x)) = f(2x) = 4x^2 + 6x + 1
                  ```
                  
                  - If you take a bunch of small, pure functions and compose them, you guaranteed get a more complex function that is still pure and composable (scalable!)
                  - JS...point out that this is a higher-order function
              </section>
              <section data-markdown>
                  # Composing "n" Functions
                  
                  Using a rest parameter and a `reduce`, we can compose together multiple functions:
                  
                  ```js
                  const compose = (...funcs) => {
                    return funcs.reduce((acc, func) => (...args) => acc(func(...args)));
                  };
                  
                  // no arrows
                  const composeNoArrows = function(...funcs) {
                    return funcs.reduce(function(acc, func) {
                      return function(...args) {
                        return acc(func(...args));
                      }
                    });
                  };
                  ```
                  
                  Check this out in action in the [Redux source code](https://github.com/reactjs/redux/blob/master/src/compose.js).
                  
                  ???
                  
                  - Note that functions are composed right to left, so `compose(f, g, h)` is identical to doing `(...args) => f(g(h(...args)))`
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Create a `compose` function that accepts any number of functions as arguments to compose these functions together. Try emoting multiple times and see what happens.
                  
                  ```js
                  const greet = (name) => {
                    return `Hello ${name}`;
                  };
                  
                  const emote = (sentence) => {
                    return `${sentence}!!!`;
                  };
                  ```
              </section>
              <section data-markdown>
                  # Applying Middleware</section>
              <section data-markdown>
                  # Redux Middleware
                  
                  Here is the function signature for every Redux middleware.
                  
                  Does the Redux middleware use function composition or currying or both?
                  
                  ```js
                  const middleware = store => next => action => {
                    // This middleware does nothing!
                    next(action);
                  };
                  ```
                  
                  ???
                  
                  - It should be evident that Redux middleware uses function composition to apply middleware in sequence
                  - Redux middleware is designed by creating functions that can be composed together before the main dispatch method is invoked
                  - Compare this function signature with the `excitedGreeter` example
                  - Challenge the students to assess why the middleware would be called with the store and action.
                  - Describe how we can get the state before and after the call to `next(action)`
              </section>
              <section data-markdown>
                  # Apply Middleware
                  
                  Back to the grocery store! To use Redux's `applyMiddleware` to add middleware to your store:
                  
                  ```js
                  import { createStore, applyMiddleware } from 'redux';
                  // import { devToolsEnhancer } from 'redux-devtools-extension';
                  import { composeWithDevTools } from 'redux-devtools-extension';
                  
                  import rootReducer from './reducers';
                  
                  export default createStore(
                    rootReducer,
                    // devToolsEnhancer()
                    composeWithDevTools(
                      applyMiddleware(/* some middleware... */)
                    )
                  );
                  ```
                  
                  What functional pattern does `applyMiddleware` resemble?
                  
                  ???
                  
                  - We would just add `applyMiddleware` as the second argument to `createStore` directly if we weren't using dev tools
                  - **Challenge the students:** Does the order of the middleware added to `applyMiddleWare` matter? **Answer:** yes.
                  - Because Redux middleware uses function composition, the order does matter
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Let's implement a simple logger. In your grocery store app, put the following code inside a function that matches the expected function signature for Redux middleware:
                  
                  ```js
                  console.group(action.type);
                  console.info('dispatching', action);
                  let result = next(action);
                  console.log('next state', store.getState());
                  console.groupEnd(action.type);
                  return result;
                  ```
                  
                  Apply your middleware, and check out the browser console.
              </section>
              <section data-markdown>
                  # Thunks
              </section>
              <section data-markdown>
                  # Thunks?
                  
                  A thunk is a function returned from another function (or a function that wraps an expression) so you can delay the evaluation of an expression until later:
                  
                  ```js
                  function not_a_thunk() {
                    // this one is a thunk because it defers work for later
                    return function() {
                      console.log('do stuff now')
                    }
                  }
                  
                  not_a_thunk()(); // calls it right away, but you don't have to!
                  ```
                  
                  Where might we need these in the project?
                  
                  ???
                  
                  - We'll need them to trigger network requests, etc.
                  - Reducers are supposed to be pure (i.e. not change anything), so putting Ajax requests in a reducer is a non-starter
              </section>
              <section data-markdown>
                  # Another Example
                  
                  The calculation of `1 + 2` is immediate:
                  
                  ```js
                  let x = 1 + 2;  // 3
                  ```
                  
                  The calculation of `1 + 2` is delayed:
                  
                  ```js
                  // foo can be called later to perform the calculation
                  // foo is a thunk!
                  let foo = () => 1 + 2;
                  
                  // same, no arrows
                  let foo = function() {
                    return 1 + 2;
                  }
                  
                  foo(); // 3
                  ```
              </section>
              <section data-markdown>
                  # Redux Thunk
                  
                  **[Redux Thunk](https://github.com/gaearon/redux-thunk)** allows us to dispatch multiple actions in order, following this funciton signature:
                  
                  ```js
                  const action = (someArg, otherArg) => dispatch => {
                    dispatch(someActionCreator1(someArg, otherArg));
                    dispatch(someActionCreator2());
                  }
                  ```
                  
                  *Why is this important?*
                  
                  ???
                  
                  - Wait, what!? Actions are supposed to be objects...
                  - Redux thunk allows us to create actions that are function instead
                  - By default, Redux action creators don't support asynchronous actions like fetching data, so here's where we use Redux Thunk
                  - It is a middleware that looks at every action that passes through the system, and if it’s a function, it calls that function
                  - That’s all it does!
              </section>
              <section data-markdown>
                  # How Does It Work?
                  
                  Under the hood:
                  
                  ```js
                  function createThunkMiddleware(extraArgument) {
                    return ({ dispatch, getState }) => next => action => {
                      if (typeof action === 'function') {
                        return action(dispatch, getState, extraArgument);
                      }
                  
                      return next(action);
                    };
                  }
                  
                  const thunk = createThunkMiddleware();
                  thunk.withExtraArgument = createThunkMiddleware;
                  
                  export default thunk;
                  ```
              </section>
              <section data-markdown>
                  # Add Redux Thunk
                  
                  Install the package:
                  
                  ```bash
                  npm install --save redux-thunk
                  ```
                  
                  In `store.js`:
                  
                  ```js
                  // ...
                  import thunk from 'redux-thunk';
                  // ...
                  
                  export default createStore(
                    rootReducer,
                    composeWithDevTools(
                      applyMiddleware(logger, thunk)
                    )
                  );
                  ```
              </section>
              <section data-markdown>
                  # Exercise 4
                  
                  Now that you installed Redux Thunk, write an async action creator called `waitAndUpdateThenExplainFruitStock` that wraps calls to dispatch `updateFruitStock` and `explainFruitStock` in a `setTimeout`.
                  
                  Set your timer for 2 seconds, dispatch your new async action creator from `index.js`, and take a look at what happens in your Redux dev tools.
              </section>
              <section data-markdown>
                  # Example With Fetch
                  
                  An example of using `fetch` in an async action creator:
                  
                  ```js
                  const fetchSomethingFromAPI = url => dispatch => {
                    dispatch(somethingIsLoading());
                  
                    fetch(url)
                      .then(response => response.json())
                      .then(data => dispatch(somethingFetchedSuccessfully(data)))
                      .catch(error => dispatch(somethingHasErrored(error)));
                  };
                  ```
              </section>
              <section data-markdown>
                  # Production vs. Development
                  
                  ???
                  
                  - What are we talking about when we say 'production' or 'development' in relation to software development?
                  - What features do we have in our app that we do not want in 'production'?
                    - logger
                    - devTools
                    - no warnings or propType errors
              </section>
              <section data-markdown>
                  # process.env.NODE_ENV
                  
                  You can detect and use environment variables in your app using the following code:
                  
                  ```js
                  if (process.env.NODE_ENV !== 'production') {
                    // do development stuff
                  } else {
                    // do production stuff
                  }
                  ```
                  
                  `process` is a special **global** variable, much like `window` or `document` in Web Browser environments.
                  
                  ???
                  
                  - Demonstrate how variables can be passed into a Node process using `process.env` by setting some variables in your `.[whatever]rc` files using `export`, as well as running a node script with an environment variable: eg: `APP_NAME='Boomtown' node index.js`, and `console.log(process.env.APP_NAME);` from within the script
              </section>
              <section data-markdown>
                  # Logger in Dev Only
                  
                  React apps should not use the logger middleware in production environments because of performance penalties, and potential errors. Thunks however will be used. Here is how you determine individual middleware per environment:
                  
                  ```js
                  let middlewareList = [reduxThunk];
                  
                  if (process.env.NODE_ENV !== 'prodution') {
                    middlewareList.push(logger);
                  }
                  
                  const middlewares = applyMiddleware(...middlewareList);
                  ```
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - What middleware is used for in Redux
                  - How to do function currying and composition in JS
                  - How to write custom middleware, and use third-party packages
                  - Selectively apply middleware in different environments
                  
              </section>
          </section>


          <section>
              <section data-markdown>
                  # React & Redux
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
                  
              </section>
              <section data-markdown>
                  ## Exercise 1
                  
                  **Redux** and **React** serve different roles. Discuss with a partner the role of each in terms of handling:
                  - data
                  - view
                  - logic
                  - events
              </section>
              <section data-markdown>
                  # Redux as Global
                  
                  Currently, we are using "Redux" as a great big global container.
                  
                  Redux holds our:
                    - **data**
                    - **events** that trigger **logic** and change **data**
                  
                  Any component can access anything from anywhere by connecting to the `store`.
                  
                  - Is a "global" container a good design? Why or why not?
              </section>
              <section data-markdown>
                  # React Redux
                  
                  *React-Redux* allows us to connect up components and give them access to only what they need.
              </section>
              <section data-markdown>
                  # Presentational vs. Container
                  
                  Components can be categorized as either:
                  
                  - **Presentational**: *dumb* components
                  - **Container**: *smart* components
              </section>
              <section data-markdown>
                  ## Exercise 2
                  
                  With a partner, fill out a table to distinguish between **Presentational** & **Container** components.
                  
                  | Dumb             | Smart                |
                  | Presentational   | Container            |
                  | -----------------|----------------------|
                  | ...              | ...                  |
                  | ...              | ...                  |
                  
              </section>
              <section data-markdown>
                  ## Exercise 3
                  
                  Based on the following tree structure, discuss with a partner which components should be of each type. Justify your reasons.
                  
                  ```
                  - App
                   |- Weeks
                      |- Week
                          |- Header
                          |- Links
                   |- Posts
                      |- Post
                          |- Vote Button
                          |- Categories
                   |- NewPost
                      |- Form
                          |- InputOne
                          |- InputTwo
                          |- Submit
                  ```
              </section>
              <section data-markdown>
                  # Provider
                  
                  Use the [`<Provider>`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store) tag from "react-redux" to connect the redux store to the app.
                  
                  - What does `Provider` do?
              </section>
              <section data-markdown>
                  # Provider
                  
                  `Provider` acts as a wrapper to connect our `store` (data) to our React components.
                  
                  Any "connected" component can hookup to this store. 
              </section>
              <section data-markdown>
                  # Connect
                  
                  Use [`connect`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options) to create ("smart") container components.
                  
                  - What does `connect` do?
              </section>
              <section data-markdown>
                  # Connect
                  
                  `connect` provides a component with:
                  
                  - state
                  - actions
                  
                  These are passed into the component as "props".
              </section>
              <section data-markdown>
                  # mapStateToProps
                  
                  Write [`mapStateToProps`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options) to connect a "container" component using "react-redux" & `connect`.
              </section>
              <section data-markdown>
                  # mapStateToProps 
                  
                  `this.props.votes` = `store.getState().votes`
                  
                  ```js
                  class Component extends React.Component {
                    render() {
                      return (
                        <button>
                          {this.props.votes}
                        </button>
                      );
                    }
                  }
                  
                  const mapStateToProps = state => {
                    votes: state.votes
                  };
                  
                  connect(mapStateToProps)(Component);
                  ```
              </section>
              <section data-markdown>
                  # mapDispatchToProps
                  
                  Write [`mapDispatchToProps`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options) to connect a component actions to redux.
                  
                  Checkout the [shorthand notation](https://egghead.io/lessons/javascript-redux-using-mapdispatchtoprops-shorthand-notation).
              </section>
              <section data-markdown>
                  # mapDispatchToProps
                  
                  `this.props.someAction` = `store.dispatch(someAction())`
                  
                  ```js
                  class Component extends React.Component {
                    render() {
                      return (
                        <button onClick={this.props.someAction} />
                          {this.props.votes}
                        </button>
                      );
                    }
                  }
                  
                  const mapStateToProps = state => {
                    votes: state.votes
                  };
                  const mapDispatchToProps = { someAction };
                  
                  connect(mapStateToProps, mapDispatchToProps)(Component);
                  ```
              </section>
              <section data-markdown>
                  ## Exercises 5 & 6
                  
                  Use `<Provider>`, `connect`, `mapStateToProps` & `mapDispatchToProps` to connect the "container" components of your app. 
                  
              </section>
              <section data-markdown>## Exercise 7
                  
                  Now that you've had some practice, let's return to our component architecture.
                  
                  Read [React with Redux](http://redux.js.org/docs/basics/UsageWithReact.html).
                  
                  In a group, write some guidelines for connecting React & Redux.
                  
                  How can we tell which components should be "presentational" or "container" components?</section>
              <section data-markdown>
                  # React Redux Router
                  
                  Why might we want to use [react-redux-router](https://github.com/reactjs/react-router-redux)?
              </section>
              <section data-markdown>
                  # React Redux Router
                  
                  Why might we want to use [react-redux-router](https://github.com/reactjs/react-router-redux)?
                  
                  - reloading user state
                  - reducer logic can get access to router state
                  - keeps everything in one accessible place
              </section>
              <section data-markdown>
                  # Reselect
                  
                  Why might you want to use [reselect](https://github.com/reactjs/reselect)?
                  
                  - mapping state to props can sometimes lead to long or repeated paths
                  
                  ```js
                  const mapStateToProps = state => {
                    name: state.user.profile.name,
                    activeUsers: state.users.filter(user => user.profile.name && user.isActive)
                  };
                  ```
              </section>
              <section data-markdown>
                  # Selectors
                  
                  When these `mapStateToProps` paths get long we can create a "selector".
                  
                  /src/selectors.js
                  
                  ```js
                  export const nameSelector = state => state.user.profile.name;
                  
                  export const activeUsersSelector = state => state.users.filter(user => user.profile.name && user.isActive);
                  ```
              </section>
              <section data-markdown>
                  # Using Selectors
                  
                  Import and call selectors with the state.
                  
                  /src/someFile.js
                  
                  ```js
                  import { nameSelector, activeUsersSelector } from '../selectors';
                  
                  const mapStateToProps = state => {
                    name: nameSelector(state),
                    activeUsers: activeUsersSelector(state),
                  };
                  ```
              </section>
              <section data-markdown>
                  # Reselect
                  
                  To compose selectors together, we can use *reselect*.
                  
                  ```js
                  import { createSelector } from 'reselect';
                  
                  export const nameSelector = state => state.user.profile.name;
                  
                  export const activeUsersSelector = state => state.users.filter(user => user.profile.name && user.isActive);
                  
                  export const activeUserNamesSelector = createSelector(
                    activeUsers,
                    name
                  );
                  ```
              </section>
              <section data-markdown>
                  ## Challenge
                  
                  Create selectors for your `mapStateToProps` calls.
              </section>
              <section data-markdown>
                  # Review
                  
                  1. Presentational & Container Components
                  2. **react-redux**
                  3. `<Provider />`
                  4. `connect`
                  5. `mapStateToProps`
                  6. `mapDispatchToProps`
                  7. selectors & **reselect**
              </section>
          </section>


          <section>
              <section data-markdown>
                  # Asynchronous JavaScript
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Recognizing Asynchrony
                  2. Stacks & Queues
                  3. The Event Loop
                  4. Asynchrony, Parallelism & Concurrency
                  5. Callbacks & Callback Hell
                  6. Promises
                  7. Async Functions
              </section>
              <section data-markdown>
    
    # Recognizing Asynchrony
              </section>
              <section data-markdown>
                  # Example 1
                  
                  **What is the output here? Why?**
                  
                  ```js
                  // setTimeout(fn, delay)
                  
                  function run() {
                    console.log('a');
                  
                    setTimeout(() => {
                      console.log('b');
                    }, 100);  
                  
                    setTimeout(() => {
                      console.log('c');
                    }, 0);
                  
                    console.log('d');
                  }
                  
                  run();
                  ```
                  
                  ???
                  
                  You can run the example directly in the console.
                  
                  You will get an `undefined` response before you see `b` and `c` logged. See if they have any idea why.
                  
                  (The `run` function will return `undefined` on its completion, after which the event loop picks up the `b` and `c` log calls)
              </section>
              <section data-markdown>
                  # Example 2
                  
                  **What is the output here? Why?**
                  
                  ```js
                  function do_a(){
                    // simulate a time consuming function
                    setTimeout(() => {
                      console.log('a');
                    }, Math.random() * 1000);
                  }
                  
                  function do_b(){
                    console.log('b');
                  }
                  
                  do_a();
                  do_b();
                  ```
              </section>
              <section data-markdown>
                  # Example 3
                  
                  **What is the output here? Why?**
                  
                  ```js
                  function do_a(cb) {
                    console.log('a');
                    cb('cb');
                  }
                  
                  function do_b() {
                    console.log('b');
                    do_a(console.log)
                  }
                  
                  do_b();
                  ```
                  
                  *What is different about this example?*
              </section>
              <section data-markdown>
                  # Data Structures:<br />Stacks & Queues
              </section>
              <section data-markdown>
                  # Stack
                  
                  .inline-images[
                    ![Stack of colourful plates](/public/img/slide-assets/stack-of-plates.jpg)
                  ]
              </section>
              <section data-markdown>
                  # Stack
                  
                  ```
                  L -> Last
                  I -> In
                  F -> First
                  O -> Out
                  ```
                  
                  Two methods: **Push** and **Pop**. 
                  
                  One reference: **Top**.
                  
                  *How would we implement it?*
              </section>
              <section data-markdown>
                  # Queue
                  
                  .inline-images[
                  
                    ![Kissing queue](/public/img/slide-assets/queue-kissing.jpg)
                  ]
              </section>
              <section data-markdown>
                  # Queue
                  
                  ```
                  (head) 1 <- 2 <- 3 <- 4 <- 5 (tail)
                  ```
                  
                  Two methods: **Enqueue** & **Dequeue**. 
                  
                  Two references: **Head** & **Tail**.
                  
                  *How would we implement it?*
              </section>
              <section data-markdown>
                  # The Event Loop
              </section>
              <section data-markdown>
                  .large[
                  So what does **asynchronous** actually mean?
                ]
              </section>
              <section data-markdown>
                  .large[
                  **Parallelism:**
                
                   Picture a roller coaster with one thirty-seat car
                ]
              </section>
              <section data-markdown>
                  .large[
                  **Asynchrony:**
                
                   Picture a roller coaster with thirty one-seat cars
                ]
              </section>
              <section data-markdown>
                  .large[
                  **Concurrency**
                
                  More than one person can enjoy the roller coaster at any given time
                ]
              </section>
              <section data-markdown>
                  .large[
                  *So how do we write asynchronous code?*
                ]
              </section>
              <section data-markdown>
                  # Callbacks
                  
                  ???
                  
                  - What is a callback?
                  - What kind of function uses callbacks (higher order functions)
              </section>
              <section data-markdown>
                  # Callbacks
                  
                  Also known as **callback functions**...
                  
                  ```js
                  get(url, (response) => {
                    console.log('response');
                  });
                  ```
                  
                  *How does this look on the event loop?*
                  
                  ???
                  
                  - Make sure they factor in the 'main' method that is executing the `get` fn.
                  - Make sure they understand that each function 'runs to completion' in JS.
                  - Any downsides to writing code that uses callbacks?
              </section>
              <section data-markdown>
                  .large[
                  **Callback Hell!**
                ]
                
                ???
                
                - Has anyone heard of callback hell?
                - Syntactic symptoms: 45 degree code, deeply nested functions
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  In pairs describe/diagram what is happening in the event loop when the `callbackHell` function is called.
                  
                  ```js
                  const callbackHell = (url) => {
                    get(url, (response) => {
                      get(response.url, (response) => {
                        get(response.url, (response) => {
                          console.log('third response');
                        });
                      });
                    });
                  };
                  ```
                  
                  ???
                  
                  - Make sure they understand that each function "runs to completion" in JS
                  - Once they're done the exercise, ask: "What happens if/when one of these requests fails?"
              </section>
              <section data-markdown>
                  # Handling Errors in Callbacks
                  
                  To make sure errors are properly handled, many libraries implement **error first** callbacks:
                  
                  ```js
                  get(url, (error, response) => {
                    if (error) {
                      return console.log(error);
                    }
                    console.log('response');
                  });
                  ```
                  
                  *Why do you think we put the error first?*
                  
                  *How would this make callback hell more hellish?*
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  **Setup (in pairs):**
                  
                  Create an `async-js` branch in the `esnext-playground`, install the [Request](https://www.npmjs.com/package/request) library, and read the API docs for [this fake API](https://jsonplaceholder.typicode.com/) to GET our data.
                  
                  **Using callbacks, write a function that:**
                  
                  1. Prints the first 10 Posts
                  2. Prints the first 20 Albums
                  3. Prints 'Done!'
              </section>
              <section data-markdown>
                  .large[
                  **The *real* problem with callbacks...**<br />
                ]
                
                (it's worse than syntax)
                
                ???
                
                Inversion of Control:
                
                - Can anyone think of a bigger issue with the way we're writing code?
                - We've handled errors, but what if the response never comes?
                - We've handed control of our application to some API
                - This principle is called Inversion of Control (IOC)
                
                Reasonability:
                
                - Consider the callback hell example
                - Is it easy to understand, to "Reason About"?
                - When there is a divergence between the way we think and the way our computer thinks, we get bugs
                
              </section>
              <section data-markdown>
                  # Promises
                  
                  ???
                  
                  Promises
                  
                  - The next generation in async code after callbacks
                  - Allow us to write code that we can reason abount, and maintain control over
                  
                  Pre-test:
                  
                  - Where have we seen promises before? (jQuery AJAX)
                  - The "Promise" metaphor: "I promise I'll get back to you"
              </section>
              <section data-markdown>
                  # Promises
                  
                  Promises use `then` and `catch` to handle success resolution or a rejection, respectively:
                  
                  ```js
                  get(url)
                    .then(response => console.log(response));
                    .catch(console.log);
                  ```
                  
                  *Where have we used this already?*
                  
                  ???
                  
                  - Instead of handing control and asking a function to be called, we're calling a function and expecting a return value.
                  
                  Bonus:
                  
                  How does this look in the event loop?
                  
                  - All `then` and `catch` methods get called, they just register callbacks effectively using closures.
              </section>
              <section data-markdown>
                  # Handling Errors in Promises
                  
                  If any of the `then` functions fail, then the `catch` function will be called:
                  
                  ```js
                  get(url)
                    .then(response => console.log(response));
                    .then(response => console.log(response));
                    .then(response => console.log(response));
                    .catch(console.log);
                  ```
                  
                  ???
                  
                  - Unhandled promises throw an error
                  - What about timeouts? Is this fixed? How might you fix it?
                  - You can easily add timeouts into promise calls.
              </section>
              <section data-markdown>
                  # Handling Errors in Promises
                  
                  **GOTCHA:** Any `then` *after* a `catch` will be called!
                  
                  ```js
                  get(url)
                    .then(response => console.log(response));
                    .then(response => console.log(response));
                    .catch(error => console.log('STOP!'));
                    .then(response => console.log(response)); // This will get called!
                    .catch(console.log);
                  ```
                  
                  ???
                  
                  This can make multiple failure flows difficult to code.
                  
                  - You can return a failed promise with a message `Promise.reject('FLAG')`
                  - But there's no good control flow options
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Look up the docs on the **[Promise API](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise)** on MDN. How can we wrap the above in a function that returns a promise?
                  
                  ```js
                  get(url, (error, response) => {
                    console.log('response');
                  });
                  ```
                  
                  ???
                  
                  Solution:
                  
                  ```js
                  function getPromise = (url) => {
                    return new Promise((resolve, reject) => {
                      get(url, (error, response) => {
                        if (error) return reject(error);
                        resolve(response);
                      });
                    });
                  };
                  ```
              </section>
              <section data-markdown>
                  # Exercise 4
                  
                  In pairs, refactor the callbacks exercise using Promises.
                  
                  **Setup:**
                  
                  Install the [Request Promise](https://www.npmjs.com/package/request-promise) library.
                  
                  **Using promises, write a function that:**
                  
                  - Prints the first 10 Posts
                  - Prints the first 20 Albums
                  - Prints 'Done!'
              </section>
              <section data-markdown>
                  # Async Functions
              </section>
              <section data-markdown>
                  # Async Functions
                  
                  ```js
                  async function getUrl(url) {
                    try {
                      const response = await get(url);
                      console.log(response);
                    } catch (e) {
                      console.log('uh oh!');
                    }
                  }
                  
                  getUrl('http://www.google.ca');
                  ```
                  
                  - Any async **or sync** function can be awaited
                  - Allows us to write async code that looks synchronous
                  - We can only use the `await` keyword in an `async function`
                  
                  ???
                  
                  - Async functions are sugar for generators
                  - Already in the newest versions of all browsers.
                  - No IE or Opera Mini support, still need a transpiler
              </section>
              <section data-markdown>
                  # Exercise 5
                  
                  In pairs, refactor the Promises exercise using `async`/`await`.
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - How to recognize asynchrony
                  - What stacks and queues are
                  - How the event loop relates to asynchrony in JS
                  - What parallelism and concurrency are
                  - What callbacks (and callback hell) are
                  - How to use Promises
                  - How to use `async`/`await`
                  
              </section>
          </section>



          <section>
              <section data-markdown>
                  # Introducing Node
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  - Understand the history and beginnings of Node
                  - Review TCP/UDP protocols
                  - Model JavaScript's event loop
                  - Build a simple TCP/UDP messaging server
                  - Use Node's built in modules to read from you computer's filesystem
              </section>
              <section data-markdown>
                  # What is Node?
              </section>
              <section data-markdown>
                  # What is Node?
                  
                  - Node was created in **2009**
                  - It has become the driving force behind the widespread adoption of the JS programming language as a tool for developing sophisticated software applications
                  - Provides the **minimum viable foundation** to support the main Internet protocols, and OS interface
                  - Given its low-level API, any reasonably complex application needs to make extensive use of libraries (npm!)
              </section>
              <section data-markdown>
                  # Experienced Node Developers Know...
                  
                  - How to structure an application using multiple third-party modules, and how to reliably judge the quality of a third-party module
                  - How to leverage the **event loop** and Node's **async**, single-threaded nature (more on this to come...)
                  - How to use various networking protocols
              </section>
              <section data-markdown>
                  ### What Makes It So Special?
                  
                  *Node's most useful features are...*
                  
                  The **event loop** and **non-blocking I/O**.
                  
                  Node programs are **single threaded** and **highly parallel**.
              </section>
              <section data-markdown>
                  # A Simple Node App
                  
              </section>
              <section data-markdown>
                  # Building a TCP Service
                  
                  TCP and UDP are the basic protocols of the internet.
                  
                  **All network communication on the internet is carried out by these two protocols (for the most part).**
                  
                  Take a minute to **[read this link](http://www.diffen.com/difference/TCP_vs_UDP)**, for a good description of the differences between TCP & UPD, and how they are used.
                  
                  When you're finished, create a folder called `TCP_Service`. Inside the folder run the command `npm init`.
              </section>
              <section data-markdown>
                  # Building a TCP Service
                  
                  Your `package.json` should look like this:
                  
                  ```json
                  {
                    "name": "intro-to-node-exercises",
                    "version": "1.0.0",
                    "description": "Learning Node @ Red Academy",
                    "scripts": {
                      "test": "echo \"Error: no test specified\" && exit 1"
                    },
                    "author": "MK <mackenzie@redacademy.com>",
                    "license": "ISC"
                  }
                  ```
                  
                  **Why do we need this?**
              </section>
              <section data-markdown>
                  # Building a TCP Service
                  
                  Create a file called `index.js`. Use Node's [built-in `net` module](https://nodejs.org/api/net.html) to create a server which will handle incoming network connections (TCP/UDP):
                  
                  ```js
                  const net = require('net')
                  const server = net.createServer();
                  
                  server.on('connection', handleConnection);
                  
                  server.listen(9000, function() {
                    console.log('server listening to %j', server.address());
                  });
                  
                  function handleConnection() {
                    // TODO: Handle connection!
                  }
                  ```
                  
                  Run this code by typing `node index.js`.
              </section>
              <section data-markdown>
                  # Building a TCP Service
                  
                  In order to show when the **server** has received a connection from a **client**, we'll need to add some code to the `handleConnection` callback.
                  
                  ```js
                  function handleConnection(conn) {
                    const remoteAddress = `${conn.remoteAddress}:${conn.remotePort}`;
                    console.log(`new client connection from ${remoteAddress}`);
                  }
                  ```
                  
                  Add the `conn` parameter and `console.log` connection details when a connection happens.
                  
                  *Where is the client?*
                  
                  **Note:** Socket in this context is not WebSocket.
              </section>
              <section data-markdown>
                  # Simple Netcat Client
                  
                  **We'll use Netcat to test our nre TCP/UDP server.**
                  
                  Start your server new TCP Server, and from your command line in a separate terminal window, run:
                  
                  ```bash
                  nc localhost 9000
                  ```
                  
                  You should see something like this in the terminal where your server was started:
                  
                  ```bash
                  new client connection from ::1:63342
                  ```
                  
                  Take a few minutes and read about the [Netcat](http://nc110.sourceforge.net/) tool now.
              </section>
              <section data-markdown>
                  ### Congratulations, you've successfully created a new network 'node' and connected it to the internet!
                  
                  <p style="text-align:center; margin:0;">
                    <img style="display:inline;" src="http://cheswick.com/ches/map/gallery/wired.gif" width="250" height="250">
                  </p>
                  
                  It doesn't do anything useful yet.
                  Before we can start sending and receiving data, we'll need to add a few more things...
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Implement the following `conn` event handlers in your `handleConnection` callback:
                  
                  - `data`
                  - `close`
                  - `error`
                  
                  Each handler should `console.log` the `remoteAddress` as well as any relevant parameters (e.g. incoming data, or error messages). Review **[the documentation](https://nodejs.org/api/net.html)** here before you begin.
              </section>
              <section data-markdown>
                  # UTF-8
                  
                  If you're sending incoming data to the server console, you may have noticed somthing like this `<Buffer 9c 4f 4f 4f>` in the output.
                  
                  This happens because TCP sends **streams of bytes** across the network, and it's up to our application to decode them properly.
                  
                  *But what is UTF-8?*
              </section>
              <section data-markdown>
                  # Debugging a Node Application
              </section>
              <section data-markdown>
                  # V8 Inspector Integration
                  
                  To debug a Node application, start the node process using the following command:
                  
                  ```bash
                  node --debug --inspect index.js
                  ```
                  
                  You should see output in your terminal:
                  
                  ```bash
                  Debugger listening on port 9229.
                  Warning: This is an experimental feature and could change at any time.
                  To start debugging, open the following URL in Chrome:
                      chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=127.0.0.1:9229/3b270900-1c51-460c-a7a4-d593f462b2d7
                  ```
                  
                  Copy and paste the `chrome-devtools://` url into a new chrome tab to start your debugging session.
              </section>
              <section data-markdown>
                  Open your debugger and set a breakpoint somewhere in your code. Send a message to your server using Netcat to trigger it.
                  
                  .inline-images[
                    ![Chrome dev tools for debugging Node](/public/img/slide-assets/node-debugger-breakpoint.png)
                  ]
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Use the debugger and set a breakpoint in your `data` event handler. Intercept the incoming data, and use the debugger's console to change the value of the data parameter (the incoming data) before it's logged.
                  
                  Use [Netcat](https://en.wikipedia.org/wiki/Netcat) to send data to your new TCP service.
                  
              </section>
              <section data-markdown>
                  # Completed TCP Service
                  
                  Finally, lets return some data from our service. At the moment does not send any information back to the client.
                  
                  Add the following code to your `data` handler to complete the service:
              </section>
              <section data-markdown>
                  # Completed TCP Service
                  
                  Finally, lets return some data from our service. At the moment does not send any information back to the client.
                  
                  Add the following code to your `data` handler to complete the service:
                  
                  ```js
                  // console.log ...
                  conn.write(
                    `Got "${d.trim()}". Let me uppercase: "${d.toUpperCase()}"`
                  )
                  ```
                  
                  Now we have a friendly upper-casing service.
              </section>
              <section data-markdown>
                  # Blocking & Non-Blocking Operations
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Use your TCP server to read from your local file system. When your server receives a request, use Node's build in `fs` module to read text from a `.txt` file and send the contents back to the connection.
                  
                  - Is reading from the filesystem an **async** or **sync** action?
                  - In what circumstance is it useful to use blocking operations?
                  
                  Modify your existing code:
                  
                  ```js
                  function handleConnection(conn) {
                    // TODO: Read a welcome message from your filesystem
                    // And respond to the connection with the contents
                  }
                  ```
              </section>
              <section data-markdown>
                  # Internet Messaging with Node
                  
              </section>
              <section data-markdown>
                  # Exercise 4
                  
                  Next we'll create a minimal chat server.
                  
                  Change your TCP service to deliver any incoming data to all connected clients.
                  
                  - Your server will need to store all connections
                  - Messages you send to the server should not return to you
              </section>
              <section data-markdown>
                  # Process: Memory & CPU
                  
                  Introducing the code recommended on the previous slide may have introduced a memory leak.
                  
                  Run the load tester to find out!
                  
                  *What do we have to do to prevent the memory leak?*
              </section>
              <section data-markdown>
                  What We've Learned
                  
                  - What Node is and what where it came from
                  - What the TCP/UDP protocols are
                  - What the JS event loop is
                  - How blocking versus non-blocking operations work in Node
              </section>
          </section>


          <section>
              <section data-markdown>
                  # Creating a Web Server with Express
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Install and create an Express app
                  2. Create a "Hello World" server using Express
                  3. Create an Express middleware
                  4. Parse requests coming into Express
                  5. Explore REST (in relation to Express)
              </section>
              <section data-markdown>
                  # Getting Started
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Before we begin creating an Express web server, in pairs draw a diagram of a client-server application. Be sure to diagram the lines of communication, and be as detailed as possible. Label as many things as you can.
              </section>
              <section data-markdown>
                  # Boomtown Fullstack
                  
                  **What do we still need to do?**
                  
                  ```
                  [View]  <--  [Data]   <--->   [Server]   <--->   [Database]
                  
                  (React)  (Redux/GraphQL)    (Express.js)        (PostgreSQL)
                  ```
              </section>
              <section data-markdown>
                  # Communication
                  
                  - How do servers and clients communicate with each other?
                  - What language (i.e. protocols) can they use?
              </section>
              <section data-markdown>
                  # Communication
                  
                  **HTTP** and **Web Sockets** are the most common protocols for communicating between web servers and clients.
                  
                  *Explain the following analogies:*
                  
                  1. HTTP is like sending a piece of mail
                  2. Web Sockets is like a text message or a phone call
                  
                  ???
                  
                  - Web sockets...a way to receive event-driven response without polling (set up a persistent connection so either client or server can send data at anytime)
                  - i.e. bidirectional, low latency real-time communication
                  - How? Send an HTTP request with `Connection: Upgrade` header to URL with `ws://` scheme
              </section>
              <section data-markdown>
                  .large[
                  **HTTP:** <br />
                  Lack of features as a feature
                ]
              </section>
              <section data-markdown>
                  > "HTTP and HTML are the Whoopee Cushion and Joy Buzzer of Internet protocols, only comprehensible as elaborate practical jokes. For anyone who has tried to accomplish anything serious on the Web, it's pretty obvious that of the various implementations of a worldwide hypertext protocol, we have the worst one possible.
                  
                  > Except, of course, for all the others."
                  
                  &mdash;Clay Shirky
                  
                  ???
                  
                  - HTTP is a "glue" protocol
                  - Inter-operability because it is weak, relatively uncoordinated, and imperfectly implemented
                  - HTTP kills all other protocols BECAUSE OF the simplicity of its labelling system
              </section>
              <section data-markdown>
                  # HTTP Conceptually
                  
                  Think of every HTTP request or response as an **envelop**. 
                  
                  What's on the envelop is information about where it should go (the **path**), a description of what's inside (some **headers**), what we want done to the contents of the envelop when it gets to its destination (the **HTTP verb**), or what happened to during its trip (the **status code**).
                  
                  What's inside the envelop is the actual message/document (the **body**).
              </section>
              <section data-markdown>
                  # HTTP Essentials
                  
                  Take a look in your dev tools under the Network tab, and look at the Header sub-tab for one of the requests that was sent while loading the page.
                  
                  What are the first three things you see listed under General?
                  
                  ???
                  
                  - Request URL, Request Method, Status Code
                  - These are some of the essential components of HTTP requests and responses
                  
              </section>
              <section data-markdown>
                  # URIs
                  
                  - Every resource on the web must be exposed with **at least one unique identifier** (but possible many unique identifiers)
                  - If a resource doesn't have URI then it's not a resource (it's likely just information about another resource)
                  - An **addressable** application exposes interesting aspects of its data set as resources, and exposes URIs for all of the resources it may conceivably serve
                  
                  ???
                  
                  - URIs don't belong specifically to HTTP, but HTTP uses them
                  - Uniform Resource Identifier vs. Locator: every URL is URI, every URI on the web is a URL, but not all URI are URLs
                  - URLs don't just identify resources like URIs do, they also indicate where to find them (like describing a person by their name instead of resident of their physical address)
              </section>
              <section data-markdown>
                  # HTTP Verbs
                  
                  What do we use the following **[HTTP verbs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)** for?
                  
                  - `GET`
                  - `POST`
                  - `PUT`
                  - `PATCH`
                  - `DELETE`
                  
                  ???
                  
                  - It's up to you to choose the right verb when you send your request, and the verb that you choose will have consequences!
                  - HTTP verbs provide us with a uniform interface when structuring our applications (as in there aren't many of these verbs and we know what they do in advance)
              </section>
              <section data-markdown>
                  # HTTP Status Code
                  
                  How would we describe these **[status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)** in non-colloquial terms?
                  
                  - `100`: Hold on
                  - `200`: Here you go
                  - `300`: Go away
                  - `400`: You messed up
                  - `500`: I messed up
                  
                  ???
                  
                  - Responding appropriately (i.e. correct status code / message) when a request comes into our Express server will be our job
              </section>
              <section data-markdown>
                  # What is Express?
                  
                  - It's minimal, flexible abstraction layer on top of Node
                  - Handy framework for creating web APIs
                  - [Other frameworks](https://expressjs.com/en/resources/frameworks.html) are written on top of it too
                  - Allows us to do routing, create/use middleware, and use template engines to generate HTML pages
              </section>
              <section data-markdown>
                  # Initial Set-up
                  
                  Create a new directory with an `index.js` file, and then run through `npm init` in that directory.
                  
                  Once that's done, run:
                  
                  ```bash
                  npm i -S express
                  ```
                  
                  More on [Express installation instructions here](https://expressjs.com/en/starter/installing.html).
              </section>
              <section data-markdown>
                  # Initial Set-up
                  
                  Let's also use Babel with our app:
                  
                  ```bash
                  npm i -D babel-cli babel-preset-es2015 babel-preset-stage-2 nodemon
                  ```
                  
                  The [nodemon](https://github.com/remy/nodemon) package will allow us to watch files in the directory in which nodemon was started, and if any files change, it will automatically restart our Node application.
                  
                  **Note:** If we were deploying this app we would want to create a build command as it is not recommended to run `babel-node` in production.
              </section>
              <section data-markdown>
                  # Initial Set-up
                  
                  Create a Babel config file:
                  
                  ```bash
                  touch .babelrc
                  ```
                  
                  Add to `.babelrc`:
                  
                  ```
                  {
                    "presets": ["es2015", "stage-2"],
                    "plugins": []
                  }
                  ```
                  
                  And in `package.json`:
                  
                  ```
                  "scripts": {
                    "start": "nodemon index.js --exec babel-node"
                  }
                  ```
              </section>
              <section data-markdown>
                  # Express "Hello, World!"
              </section>
              <section data-markdown>
                  # A Basic Express App
                  
                  Below, the `app.get()` method create a route that accepts GET requests:
                  
                  ```js
                  import express from 'express';
                  const app = express();
                  const port = 3300;
                  
                  app.get('/', function(request, response) {
                    response.send('Hello, world!');
                  });
                  
                  app.listen(port, function() {
                    console.log(`Server running @ localhost:${port}`);
                  });
                  ```
              </section>
              <section data-markdown>
                  # Does It Work?
                  
                  Run the following in your Terminal:
                  
                  ```bash
                  curl -i http://localhost:3300
                  ```
                  
                  *What do you see?*
                  
                  ???
                  
                  - `ETag`: can be used for web cache validation
                  - `Connection: keep-alive`: Persist connection to improve performance of multiple requests
              </section>
              <section data-markdown>
                  # It's Just Node!
                  
                  Remember that Express is just providing an abstraction layer on top of Node, so we can still use the Node API in our route handlers too:
                  
                  ```js
                  app.get('/', function(request, response) {
                    // Express method:
                    // response.send('Hello, world!');
                  
                    // Almost-equivalent code with regular Node:
                    response.write('Hello, world!');
                    response.end();
                  });
                  ```
                  
                  ???
                  
                  - If you were to dig into the Express code you would see that the `request` and `response` objects have prototypes that are based on objects from the Node `http` library.
              </section>
              <section data-markdown>
                  # Send Some JSON
                  
                  The `.send()` method converts an array or object to JSON:
                  
                  ```js
                  const quotes = [
                    { 
                      name: 'Fred Brooks',
                      text: 'Nine people can’t make a baby in a month.'
                    },
                    { 
                      name: 'Paul Ford',
                      text: 'A computer is a clock with benefits.'
                    },
                    { 
                      name: 'Linus Torvalds',
                      text: 'Talk is cheap. Show me the code.'
                    }
                  ];
                  
                  app.get('/', function(request, response) {
                    response.send(quotes);
                  }); // ...now run `curl -i` again
                  ```
              </section>
              <section data-markdown>
                  # Add a Route
                  
                  We can respond to request on more than just the root-level URI too (thankfully!). Create a dedicated route to send our quotes JSON back on:
                  
                  ```js
                  app.get('/quotes', function(request, response) {
                    response.send(quotes);
                  });
                  ```
              </section>
              <section data-markdown>
                  # Middleware in Express
              </section>
              <section data-markdown>
                  # Middleware?
                  
                  Middleware are simply **functions added to the call stack that have access to the request and response objects, and are executed sequentially** (before `app.get()`, etc. is called).
                  
                  Express middleware can perform the following tasks:
                  
                  - Execute any code
                  - Make changes to the request and the response objects
                  - End the request-response cycle
                  - Call the next middleware in the stack
                  
                  ???
                  
                  - Redux middleware solves different problems than Express middleware, but in a conceptually similar way
                  - In Redux, middleware provides a third-party extension point between dispatching an action, and the moment it reaches the reducer
                  - In Express, middleware provides a third-party extenion point between the raw request and the final request handler.
              </section>
              <section data-markdown>
                  # Using Middleware
                  
                  We can apply middleware in Express as follows:
                  
                  ```js
                  app.use(function(request, response, next) {
                    // Do something here...
                    // then move to next middleware...
                    next();
                  });
                  
                  app.use(function(request, response, next) {
                    // ...
                    response.send();
                  });
                  ```
                  
                  The call to `next()` is how we move onto the next piece of middleware, until we're finally ready to respond back to the client and call `response.send()` in the last middleware.
                  
                  ???
                  
                  - Once `response.send()` is called you can’t apply more middleware
                  - You can also specify a route for a first argument of `.use()` to only run the middleware function on that route, otherwise it will run on for all requests
              </section>
              <section data-markdown>
                  # Built-in Middleware
                  
                  The only middleware function that ships with Express 4.x+ is `static()`. This function makes it possible to serve static assets in your app:
                  
                  ```js
                  // Serve files from the "public" dir:
                  app.use(express.static('public'));
                  ```
                  
                  Try replacing your call to `app.get('/', ...)` with this in your Express app. Be sure to add a `public` directory with an `index.html` file in it. What do you see in your browser now?
                  
                  ???
                  
                  - The static middleware will serve everything under the public folder
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Before we go further with middleware, let's pause an build out the client side of our app. In your `index.html` file, add a button (which you will use to asynchronously retrieve quotes).
                  
                  Also create `main.js` file in your `public` directory and include it in your `index.html` file. Inside of `main.js`, use `fetch` to grab your quotes on JSON when the button is clicked.
                  
                  Lastly, append all the quotes and their authors to the DOM after the `fetch` Promise resolves successfully.
                  
                  ???
                  
                  Probably want to share this with the students to save time...
                  
                  ```js
                  function appendQuote(quote) {
                    const blockquote = document.createElement('blockquote');
                    const deleteButton = document.createElement('button');
                    deleteButton.setAttribute('data-quote', quote.name.replace(/\s+/g, '-').toLowerCase());
                    deleteButton.textContent = 'Delete';
                    blockquote.textContent = `"${quote.text}" — ${quote.name} `;
                    blockquote.appendChild(deleteButton);
                    container.appendChild(blockquote);
                  }
                  ```
              </section>
              <section data-markdown>
                  .large[
                  Logging, two ways!
                ]
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Finish writing this middleware knowing that we want to log in this format: `GET / 200 15 ms`
                  
                  ```js
                  function diyLogger(request, response, next) {
                    const start = +new Date();
                    const stream = process.stdout;
                    const { url, method } = request;
                    const { statusCode } = response;
                  
                    response.on('finish', function () {
                      // ...what goes here?
                    });
                  
                    next();
                  }
                  ```
                  
                  Call `app.use()` with your logger in the appropriate place too.
                  
                  ???
                  
                  - The response object has event listeners: `response.on()`
              </section>
              <section data-markdown>
                  # Exercise 4
                  
                  Now let's try adding a third-party (more fully-featured!) logger.
                  
                  Install **[morgan](https://github.com/expressjs/morgan)**, add the middleware to your app, and try some different log formats.
              </section>
              <section data-markdown>
                  # Parsing Requests
              </section>
              <section data-markdown>
                  # Dynamic Routes
                  
                  Like with React Router, we can add route parameters:
                  
                  ```js
                  app.get('/quotes/:name', function(request, response) {
                    response.send(request.params.name);
                  });
                  ```
                  
                  What do you see in your browser now when you navigate to `/quotes/someone`?
                  
                  ???
                  
                  - Query string parameters are added to `request.query` object as properties too
              </section>
              <section data-markdown>
                  # Exercise 5
                  
                  Finish writing the route handler for `/quotes/:name`:
                  
                  ```js
                  app.get('/quotes/:name', function(request, response) {
                    const { name } = request.params;
                    const slug = name.replace(/\s+/g, '-').toLowerCase();
                  
                    // What array method can you use on the quotes array to return
                    // the first object in the array with a matching name?
                  
                    if (/* there's no match... */) {
                      response.status(404).json('That person isn\'t quote-worthy.');
                    } else {
                      response.send(/* the quote object */);
                    }
                  });
                  ```
              </section>
              <section data-markdown>
                  # POST Requests
                  
                  Time to add some new quotes to our app.
                  
                  Doing this in our Express app will be similar to sending `GET` requests, but we'll use a `POST` request instead.
                  
                  *But first, some initial set-up...*
              </section>
              <section data-markdown>
                  # Submit Form
                  
                  First, we'll need a form to send `POST` requests to our server from the client:
                  
                  ```html
                  <h2>Submit a Quote</h2>
                  <form id="create-quote">
                    <label for="text">Quote Text</label>
                    <input type="text" id="text" name="text">
                    <label for="name">Speaker Name</label>
                    <input type="text" id="name" name="name">
                    <button type="submit">Create Quote</button>
                  </form>
                  ```
              </section>
              <section data-markdown>
                  # Event Handler
                  
                  In our client-side JS, you'll also need to listen for the `submit` event on the form:
                  
                  ```js
                  const createQuoteForm = document.getElementById('create-quote');
                  
                  createQuoteForm.addEventListener('submit', function (event) {
                    event.preventDefault();
                    const formData = new FormData(createQuoteForm);
                    const newQuote = {};
                  
                    for ([key, value] of formData.entries()) {
                      newQuote[key] = value;
                    }
                  
                    // Now use fetch to send a post request to finish the job...
                  });
                  ```
              </section>
              <section data-markdown>
                  # Exercise 6
                  
                  Before we handle the `POST` request in Express, we'll need a way to send that request from the client to our server. 
                  
                  Inside of the submit event handler, use `fetch` to send a `POST` request. You'll need to send it to the `/quotes` route. 
                  
                  **Note**: You will also need to supply some request options in the form of an object as a second argument to `fetch`. You'll want to specify that the `method` is `POST`, set `headers` for the `Content-Type` (JSON), and set the `newQuote` object as the `body` (use `JSON.stringify()`).
              </section>
              <section data-markdown>
                  # POST Requests
                  
                  Now we finally get to handle the `POST` request we're sending from the client. First, we'll need some middleware to parse the JSON body of the incoming request:
                  
                  ```js
                  npm install --save body-parser
                  ```
                  
                  Now add this to your Express app:
                  
                  ```js
                  import bodyParser from 'body-parser';
                  
                  app.post('/quotes', bodyParser.json(), function (request, response) {
                    const newQuote = request.body;
                    // Add your new quote to the quotes array
                    // Then send back a 201 status
                    // And also send the new quote as JSON in the response
                  });
                  ```
              </section>
              <section data-markdown>
                  # Exercise 7
                  
                  Now figure out how to finish writing the route handler for the `POST` request.
                  
                  Once you've finished that, jump back to your client-side JS and take the JSON response you get back from the server to append your new quote to the DOM.
                  
                  Improve UX by clearing out the form inputs after the response comes back too!
              </section>
              <section data-markdown>
                  # Remove a Quote
                  
                  The last bit of functionality will be to delete individual quote from the list. We'll submit our request from the client like this:
                  
                  ```js
                  const container = document.getElementById('quotes');
                  
                  container.addEventListener('click', function (event) {
                    const clickedEl = event.target;
                  
                    if (clickedEl.tagName === 'BUTTON') {
                      const name = clickedEl.getAttribute('data-quote');
                  
                      fetch(`http://localhost:3300/quotes/${name}`, {
                        method: 'DELETE'
                      })
                        .then(() => {
                          const blockquote = clickedEl.parentNode;
                          blockquote.parentNode.removeChild(blockquote);
                        });
                    }
                  });
                  ```
              </section>
              <section data-markdown>
                  # DELETE Requests
                  
                  Not surprisingly, you'll handle a `DELETE` request like this in Express:
                  
                  ```js
                  app.delete(function (request, response) {
                    // Remove the quote from the quotes array
                    // Send back the 200 status with the response
                  });
                  ```
              </section>
              <section data-markdown>
                  # Exercise 8
                  
                  Finish writing the route handler for the `DELETE` request.
              </section>
              <section data-markdown>
                  # Bonus Round: Clean-up
                  
                  There's a way we can consolidate route code so that we're not making isolated calls to HTTP verb-related Express methods on the same routes.
                  
                  Also, the `index.js` file in our Express app is getting a bit messy. Typically, you wouldn't define all of your routes for an app in this top-level file. There's a built-in solution in Express for that as well.
                  
                  *Let's do some refactoring...*
              </section>
              <section data-markdown>
                  # Use app.route()
                  
                  Right now we have this in our app:
                  
                  ```js
                  app.get('/quotes', /* handler */ );
                  app.post('/quotes', /* handler */ );
                  app.get('/quotes/:name', /* handler */ );
                  app.delete('/quotes/:name', /* handler */ );
                  ```
                  
                  But we can use `app.route()` to consolidate our route handling with chaining:
                  
                  ```js
                  app.route('/quotes')
                    .get( /* handler */ )
                    .post( /* handler */ );
                  
                  app.route('/quotes/:name')
                    .get( /* handler */ )
                    .delete( /* handler */ );
                  ```
              </section>
              <section data-markdown>
                  # Exercise 9
                  
                  Refactor your route-related code to use `app.route()`.
              </section>
              <section data-markdown>
                  # Routes in a Module
                  
                  It would also be nice to get all of the route handling code out of `index.js` into a dedicated module for quotes.
                  
                  Create a `quotes.js` file in your Express app and add:
                  
                  ```js
                  import express from 'express';
                  import bodyParser from 'body-parser';
                  
                  const router = express.Router();
                  
                  // ...some code goes here
                  
                  export default router;
                  ```
                  
                  ???
                  
                  - Creates modular, mountable route handlers
                  - A Router instance is a complete middleware and routing system; for this reason, it is often referred to as a “mini-app”
              </section>
              <section data-markdown>
                  # Refactor Routes
                  
                  Now mount your router in your app:
                  
                  ```js
                  import quotesRoutes from './quotes';
                  
                  // ...
                  
                  app.use('/quotes', quoteRoutes)
                  ```
                  
                  And move all of the `app.route()` calls `quotes.js`.
              </section>
              <section data-markdown>
                  # Exercise 10
                  
                  Our app won't work until we refactor what we just moved into `./quotes.js`.
                  
                  First, we won't call `.route()` on the `app` object (it doesn't exist here), we'll call it on the instance of the router we instantiated in this file (`router`).
                  
                  Second, the path argument passed into `.route()` will be relative to where it's mounted in `index.js`. What do we need to change in the path argument to reflect this?
                  
                  Don't forget to move your quotes array into `quotes.js` too!
              </section>
              <section data-markdown>
                  # REST APIs
              </section>
              <section data-markdown>
                  .large[
                  Surprise! We've been building up a REST API this whole time.
                ]
              </section>
              <section data-markdown>
                  # What Is REST?
                  
                  - **RE**presentational **S**tate **T**ransfer
                  - Conceived of by Roy Fielding in 2000 in his [doctoral dissertation](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)
                  - REST isn't an architecture, it's meant to be a way to judge architectures (i.e. it's a set of design criteria)
                  - It's resource-driven, like the web
                  
                  ???
                  
                  - All about stateless servers and structured access to resources
                  - REST itself is pretty strict, but it's widely interpreted
                  - Contrast to RPC which is action-driven
                  - A tale of two APIs
                    - https://codex.wordpress.org/XML-RPC_WordPress_API
                    - https://developer.wordpress.org/rest-api/reference/
              </section>
              <section data-markdown>
                  # Rise to Popularity
                  
                  A few events contributed to the rise of REST:
                  
                  - The ubiquity of smartphones (iPhone launched in 2007)
                  - Social media platforms (the witter sort-of-REST-ish API was a way to combat rogue API implementations)
                  - Cloud computing (Amazon S3 launched in 2006 and initially didn't have a GUI, just a RESTful API)
              </section>
              <section data-markdown>
                  # How REST Works
                  
                  REST defines a type of architecture where **resources**, **identifiers** (URIs), and **actions** (HTTP verbs) are all we need to interact with resources hosted on the web.
                  
                  In other words, HTTP verbs provide semantic intention for the actions we want to take on resources, and URIs help us know where to find them.
                  
                  Taken together, REST enabled us to use the web as a **distributed application plaform** whose **linked resources** communicate by **exchanging representations of resource state**.
              </section>
              <section data-markdown>
                  # Decisions We Made
                  
                  Thinking about the quotes app we just built...
                  
                  - What resources did we identify in our quotes app?
                  - How did we structure the URIs?
                  - What HTTP verbs did we use to send requests from the client?
              </section>
              <section data-markdown>
                  # Data &rarr; Resources
                  
                  How a data set splits into resources:
                  
                  1. Pre-defined/one-off resources for important aspects of the application (e.g. the homepage)
                  2. Resources for every object exposed through the service (possibly infinite)
                  3. Resources as a result of algorithms applied to data sets (probably infinite)
              </section>
              <section data-markdown>
                  # RESTful URIs
                  
                  And we describe our resources with URI structure:
                  
                  - Use path variables to denote hierarchy (e.g. `/parent/child`)
                  - Use punctuation to avoid implying hierarchy where one doesn't exist (e.g. `lat,long` or `lat;long`)
                  - Use a query string as a input to an algorithm (e.g. `?search=`)
              </section>
              <section data-markdown>
                  # Exercise 11
                  
                  In small groups or pairs, you'll be assigned one of the following topics to research (with respect to how it relates to REST) and deliver a short presentation to class on your findings:
                  
                  - Data versus Resources versus Representations in REST
                  - State in REST: The idea of "statelessness" and the difference between resource state and application state
                  - The Richardson Maturity Model and where "hypermedia as an engine of application state" (HATEOAS) comes into play
                  - Safety and idempotence of HTTP verbs used in REST APIs
                  
                  ???
                  
                  **Data v. Resources v. Representations:**
                  
                  - Resource: a document, a row in a database, the results of running an algorithm, etc. (anything that can be streamed as bits)
                  - Splitting an app into resources increases its surface area
                  - Representation: any useful information about the state of the resource
                  - Representations also provide levers of state (the next possible state)
                  - Representations help capture the current or intended sate of a resource (with metadata) (we represent with JSON)
                  
                  **State in REST:**
                  
                  - Statelessness: request happen in isolation of each other and contain all the info they necessary to get what's needed from the server
                  - The client doesn't need to coax the server into some state for the server to be receptive to a request
                  - HTTP sessions on the server can break statelessness
                  - Statelessness makes it easier to cache and scale a distributed app
                  - Application state should be managed in the client, and reflects interactions
                  - Resource state should be managed on the server, and reflects the semi-permanent state of data
                  - Resource state is the same for every client
                  
                  
                  **RMM & HATEOAS:**
                  
                  - Level 0: URI tunneling
                  - Level 1: Resources
                  - Level 2: HTTP verbs
                  - Level 3: Hypermedia
                  - HATEOAS: App state tracked by the client on its path through the web (the server guides it along the path through links and forms)
                  - As an app reaches a new state, the next possible states are discovered (like a treasure hunt for nearby resources)
                  
                  **Safety & Idempotence:**
                  
                  - Safe: no server-side effects for which the client can be held responsible
                  - Idempotent: generates absolute side effects
                  - GET is safe and idempotent
                  - PUT and DELETE are not safe but idempotent
                  - PATCH and POST are not safe and not idempotent
                  - POST overload in RPC
                  - POST is often used as the wildcard operation of the web
                  - In REST, POST is for creating subordinate resources
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - How to set up a basic Express app
                  - How to add middleware to Express
                  - How to parse HTTP requests set to the Express server
                  - What REST is, and why it's important
              </section>
          </section>



          <section>
              <section data-markdown>
                  # Connecting Client & Server with GraphQL
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. REST pain points
                  2. Graph theory basics
                  3. GraphQL basics
                  4. Set-up a GraphQL server
                  5. Define queries and run them in a client
                  6. Define mutations and run them in a client
                  7. Clean-up and optimize data fetching
              </section>
              <section data-markdown>
                  # REST Pain Points
              </section>
              <section data-markdown>
                  .large[
                  Over-fetching data
                ]
                
                ???
                
                - More data is sent over the wire than what you typically need with REST
                - Let's say we want to hit the GitHub API to fetch all of the names of our repos and list them on the RED Academy website...this is the response we get back from hitting that endpoint: https://api.github.com/orgs/redacademy/repos?client_id=a37c6077034750f953fc&client_secret=8ff75658b21aa8c5830b7efeae85f559b4d36a02
              </section>
              <section data-markdown>
                  .large[
                  Under-fetching data
                ]
                
                ???
                
                - **n+1 problem:** when a request to load one item turns into n+1 requests since the item has "n" associated items
                - how many requests are need to populate all of the information into this user profile: https://boom.academy.red/profile/LAi9TYWxgGhbjgHu1Sm6ZvB1tRP2
              </section>
              <section data-markdown>
                  .large[
                  The server decides the shape of the data, but the client decides the structure of the UI
                ]
                
                ???
                
                - i.e. how data needs to be displayed
                - relates to under-fetching and over-fetching, but also illustrates how REST makes it difficult for us to rapidly iterate the UI of an app
                - Designing a REST API endpoint around views makes it harder it iterate on a product
              </section>
              <section data-markdown>
                  .large[
                  API versioning
                ]
                
                ???
                
                - We didn't talk about API versioning yesterday (and how this gets incorporated into the path of an URL)
                - What happens when you get feedback that the `createdOn` time for Boomtown should no longer be a Unix timestamp, but a human-readable time instead...how could you change this in the response without breaking things for other clients using this API?
                - You have two choices...break things for clients who don't update, or version your API
              </section>
              <section data-markdown>
                  .large[
                  REST APIs are (usually) tied to a single data source
                ]
                
                ???
                
                - What happens when we want to get data from multiple services, etc.?
              </section>
              <section data-markdown>
                  .large[
                  This is why Facebook <br />invented GraphQL!
                ]
                
                ???
                
                - REST APIs can be problematic when it comes to keeping up with all the ways clients want to access data from them (inflexible)
                - GraphQL gives us more flexibility and efficiency when it comes to query data from the client and getting it back in exactly the shape that we want it
              </section>
              <section data-markdown>
                  # But First, <br />Some Graph Theory
              </section>
              <section data-markdown>
                  # Graph Theory 101
                  
                  - Graphs help us represent networks (i.e. collections of interconnected things)
                  - Graphs have **nodes** and **edges**
                  - In math, a graph can be expressed as `G = (V, E)` where `V`is a set of nodes (vertices), and `E` is the set of edges between them (links)
              </section>
              <section data-markdown>
                  ![Trees and graphs](/public/img/slide-assets/graphs-trees.jpg)
                  
                  .footnote.right[
                    Source: [The Practical Dev](https://dev.to/vaidehijoshi/a-gentle-introduction-to-graph-theory)
                  ]
                  
                  ???
                  
                  - All trees are graphs, but not all graphs are trees
                  - A graph can have one node (a singleton graph)
              </section>
              <section data-markdown>
                  ![Nodes and edges](/public/img/slide-assets/graph-nodes-edges.jpg)
                  
                  .footnote.right[
                    Source: [The Practical Dev](https://dev.to/vaidehijoshi/a-gentle-introduction-to-graph-theory)
                  ]
                  
                  ???
                  
                  - Edges are the links between nodes
              </section>
              <section data-markdown>
                  ![Directed verus undirected](/public/img/slide-assets/graph-directed-undirected.jpg)
                  
                  .footnote.right[
                    Source: [The Practical Dev](https://dev.to/vaidehijoshi/a-gentle-introduction-to-graph-theory)
                  ]
                  
                  ???
                  
                  - An edge can be directed (one-way; origin and destination are fixed) 
                  - Or undirected (bidirectional; origin and destination nodes are not fixed)
                  - directed graphs are also called digraphs
                  
              </section>
              <section data-markdown>
                  .large[
                  Is Facebook a directed or undirected graph?
                 ]
                 
                 ???
                 
                 - Undirected, because friendships are mutual
              </section>
              <section data-markdown>
                  .large[
                  How about Twitter?
                 ]
                 
                 ???
                 
                 - Undirected, because I can follow you but you don't have to follow me
              </section>
              <section data-markdown>
                  .large[
                  And the web?
                 ]
                 
                 ???
                 
                 - Undirected
                 - Webpages are nodes, directed edge is the link, the relationship of links is not mutual
                 - Web crawling is just graph traversal (i.e. visiting all nodes in a graph)
              </section>
              <section data-markdown>
                  # Whats and Hows of GraphQL
                  
              </section>
              <section data-markdown>
                  # What Is GraphQL?
                  
                  - It's a [specification](http://facebook.github.io/graphql/)
                  - It's a query language for APIs
                  - It's transport layer-agnostic
                  - It's an application layer (i.e. an abstraction)
                  - It's introspective
                  - It's hiearchical
                  - It's driven by the requirements of the view
                  
                  ???
                  
                  - The specification is just a document describing how a GraphQL server should behave
                  - The spec determines the validity of the schema on the API server and the schema determines the validity of client calls
                  - Because it's just a spec, if you want to use it, you need to build your own GQL server or use a service like Graphcool (this is where Express will come in for us)
                  - "Introspective" means that client can query the schema for details about the schema
                  - Re: hierarchy, the shape of a GraphQL call mirrors the shape of the JSON data it returns, and nested fields let you query for and receive only the data you specify in a single round trip.
              </section>
              <section data-markdown>
                  .large[
                  **[Try it out!](https://developer.github.com/v4/)**
                ]
                
                ???
                
                *Go to the Live Explorer...*
                
                **Premise:**
                
                Remember that mess of JSON we got back when we hit the GH REST endpoint?
                
                With GraphQL we can just get back what we need:
                
                ```
                query {
                    organization(login:"redacademy") {
                    repositories(first: 100) {
                      edges {
                        node {
                          name
                        }
                      }
                    }
                  }
                }
                ```
                
                - Be sure to take a look in the dev tools in the Network tab. What kind of request is being sent? Where does it go? What's in the body?
                - You just send a single POST request to the server with a query and it responds with all the data you need, packaged up a JSON object returned to the client
                - Also be sure to take a look at the documentation explore in GraphiQL. Introspection!
                - The root field is always called `data`
              </section>
              <section data-markdown>
                  .large[
                  Remember:<br />
                  It's not a database.
                ]
                
                ???
                
                - GraphQL is not a storage model or a database query language
                - This is something completely different from graph-based databases
                - The graph refers to graph structures defined in the schema, where nodes define objects and edges define relationships between objects
                - The API traverses and returns application data based on the schema definitions, **independent of how the data is stored**
              </section>
              <section data-markdown>
                  # How Else Is It Different?
                  
                  - **The identity of an object is separate from how you fetch it**
                  - It only defines a single endpoint on the server
                  - The client defines the shape and size of a resource
                  - All the data you need for your view is **retrieved in one round-trip to the server**
                  - It doesn't use HTTP verbs to indicate writes in requests (it changes a word in the query instead)
                  - It's easier evolve your API without versioning, and not adjust your API when product requirements change slightly
                  
                  ???
                  
                  - GraphQL typically tunnels everything through a `POST` request (GraphiQL may use `GET` requests and query string through)
              </section>
              <section data-markdown>
                  # A Basic GraphQL Server
              </section>
              <section data-markdown>
                  # Express Set-up
                  
                  We'll need to set-up a basic Express server and create an endpoint for our web client to send queries to. Create a new directory for your server, `npm init`, and then:
                  
                  ```bash
                  npm i -S express body-parser node-fetch
                  ```
                  
                  Let's also use Babel with our app again:
                  
                  ```bash
                  npm i -D babel-cli babel-preset-es2015 babel-preset-stage-2 nodemon
                  ```
                  
                  Create a `.babelrc` file with the **same config as yesterday**, and then add the same `start` command to your `package.json` too.
                  
                  ???
                  
                  `.babelrc` config:
                  
                  ```
                  {
                    "presets": ["es2015", "stage-2"],
                    "plugins": []
                  }
                  ```
                  
                  `package.json` script:
                  
                  ```bash
                  "scripts": {
                    "start": "nodemon index.js --exec babel-node"
                  }
                  ```
              </section>
              <section data-markdown>
                  # Express Set-up
                  
                  Now create an `index.js` file and instantiate your new Express app:
                  
                  ```js
                  import express from 'express';
                  import bodyParser from 'body-parser';
                  
                  const app = express();
                  ```
              </section>
              <section data-markdown>
                  # GraphQL Set-up
                  
                  Now we'll need to install the GraphQL server for Express:
                  
                  ```bash
                  npm i -S graphql apollo-server-express graphql-tools
                  ```
                  
                  *Note that we are using the [**Apollo Server**](http://dev.apollodata.com/tools/apollo-server/index.html)*.
                  
                  ???
                  
                  - `graphql`: The JavaScript reference implementation for GraphQL, a query language for APIs created by Facebook
                  - `apollo-server-express`: Apollo server is a flexible, community driven, production-ready HTTP Apollo Server plugin for Node.js
                  - `graphql-tools`: This package allows you to use the GraphQL schema language to build your GraphQL.js schema, and also includes useful schema tools like per-type mockin
              </section>
              <section data-markdown>
                  # GraphQL Set-up
                  
                  And create our endpoints in `index.js`:
                  
                  ```js
                  import { 
                    graphqlExpress, 
                    graphiqlExpress 
                  } from 'apollo-server-express';
                  import schema from './api/schema'; // Next step!
                  
                  const GQL_PORT = process.env.PORT; // Where does this come from?
                  
                  // Where we will send all of our GraphQL requests
                  app.use('/graphql', bodyParser.json(), graphqlExpress({ schema }));
                  
                  // A route for accessing the GraphiQL tool
                  app.use('/graphiql', graphiqlExpress({
                    endpointURL: '/graphql',
                  }));
                  
                  app.listen(GQL_PORT, () => console.log(
                    `GraphQL is now running on http://localhost:${GQL_PORT}/graphql`
                  ));
                  ```
                  
                  ???
                  
                  The `.env` file:
                  
                  ```
                  GQL_PORT=4000
                  ```
              </section>
              <section data-markdown>
                  # Querying Data
              </section>
              <section data-markdown>
                  # Where Does the Schema Come From?
                  
                  Before we define our schema we'll need to cover some core GraphQL concepts:
                  
                  - **Schema** (and root types)
                  - Queries
                  - Mutations
                  
                  ???
                  
                  - The schema is one of the most important concepts in GraphQL
                  - The schema is where we will define what queries, mutations, and subscriptions are available in the API, and what the **root types** of the schema are
                  - These are the **main entry points for the API**
                  - Mutations allow us to create, update, and delete data
                  - We won't be creating subscriptions in Boomtown
              </section>
              <section data-markdown>
                  # Schema
                  
                  - With GraphQL, the schema serves as the **contract defined between the client and the server**
                  - We use a **Schema Definition** to write our schemas in GraphQL, which allows us to express our API's type system and the relationships between the types with relations
                  - Schema Definitions **types** and **fields**
              </section>
              <section data-markdown>
                  # Built-in Types
                  
                  GraphQL has five built-in scalar types:
                  
                  - `Int`
                  - `Float`
                  - `String`
                  - `Boolean`
                  - `ID`
              </section>
              <section data-markdown>
                  # Types and Fields
                  
                  We use a special syntax to define types/fields in GraphQL:
                  
                  ```js
                  type Person {
                    id: ID!
                    name: String!
                    birthday: String
                    placeOfBirth: String
                    bio: String
                  }
                  ```
                  
                  The `!` type modifier indicates a **non-nullable** field.
              </section>
              <section data-markdown>
                  # Types and Fields
                  
                  A field can use any other type defined in the Schema Definition. Notice the use of the `[]` type modifier for lists now:
                  
                  ```js
                  type Person {
                    id: ID!
                    name: String!
                    birthday: String
                    placeOfBirth: String
                    bio: String
                    filmography: [Movie]
                  }
                  
                  type Movie {
                    id: ID!
                    title: String!
                    releaseDate: String
                    stars: [Person]
                    director: Person
                  }
                  ```
              </section>
              <section data-markdown>
                  # Root Query Type
                  
                  Finally, we'll need to define what queries our schema allows. This will be an entry point into the type system.
                  
                  The name of this type is `Query` by convention, and it describes our **public, top-level API**.
                  
                  ```js
                  type Query {
                    people: [Person]
                    person(id: ID!): Person
                    movies: [Movie]
                    movie(id: ID!): Movie
                  }
                  ```
              </section>
              <section data-markdown>
                  # Add Your Schema
                  
                  Create a `graphql/schema.js` file in your app:
                  
                  ```js
                  import { makeExecutableSchema } from 'graphql-tools';
                  
                  import resolvers from './resolvers'; // Next step!
                  
                  const typeDefs = `
                    # Your schema goes here...
                  `;
                  
                  export default makeExecutableSchema({
                    typeDefs,
                    resolvers,
                  });
                  ```
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Define the types and fields for items and users in Boomtown.
                  
                  Be sure to use type modifiers where needed.
              </section>
              <section data-markdown>
                  # Resolvers
                  
                  **Schemas are the what, resolvers are the how in GraphQL.**
                  
                  The role of a resolver function is to fetch the data for its corresponding field.
                  
                  Resolvers can't be included directly in the schema language, so they need to be added separately.
                  
                  You define a resolver as a nested object that maps type and field names to resolver functions. 
                  
                  Resolvers can return Promises too (woot!).
                  
                  ???
                  
                  - Every field can have a resolve function, which tells the GraphQL server how to return data for that field, if it appears in a query
                  - At the minimum, we need to define a resolve function for each field that either returns a non-scalar type or takes any arguments
                  
              </section>
              <section data-markdown>
                  # Resolver Set-up
                  
                  Create a `graphql/resolvers.js` file in your app:
                  
                  ```js
                  import fetch from 'node-fetch';
                  
                  const resolveFunctions = {
                    // Resolvers go here...
                  };
                  
                  export default resolveFunctions;
                  ```
              </section>
              <section data-markdown>
                  # Example Resolvers
                  
                  If we were getting our data from **[a static source like this](https://gist.github.com/mandiwise/25dbcfd558748f6afded7dcebe23f9a3)**, our resolvers may look like this:
                  
                  ```js
                  const resolveFunctions = {
                    Query: {
                      movies() {
                        return data.movies;
                      },
                      movie(root, { id }) {
                        return data.movies.find(movie => movie.id === parseInt(id));
                      },
                    },
                    // ...other resolvers
                  };
                  ```
                  
                  ???
                  
                  - We should define a resolver for each of our types so GraphQL knows where to get the data from
                  - The first argument is the object that contains the result returned from the resolver on the parent field, or, in the case of a top-level Query field, the rootValue passed from the server configuration (this argument enables the nested nature of GraphQL queries)
                  - An object with the arguments passed into the field in the query
              </section>
              <section data-markdown>
                  # Or Fetch the Data
                  
                  But if we were fetching data from some (pretend) existing movie API, our resolvers would look like this:
                  
                  ```js
                  const resolveFunctions = {
                    Query: {
                      movies() {
                        return fetch(`http://somemovieapi.com/movies/`)
                          .then(response => response.json())
                          .catch(errors => console.log(errors));
                      },
                      movie(root, { id }) {
                        return fetch(`http://somemovieapi.com/movies/${id}`)
                          .then(response => response.json())
                          .catch(errors => console.log(errors));
                      }
                    },
                    // ...other resolvers
                  };
                  ```
                  
                  ???
                  
                  - Cool! GraphQL pushes the complexity of fetching data to the server (where ideally more powerful machines are taking care of this computing work)
              </section>
              <section data-markdown>
                  .large[
                  Problem: Where do the actors and directors come from in relation to our movie type?
                ]
              </section>
              <section data-markdown>
                  # Resolve the Director
                  
                  We have to tell GraphQL where to find the director with another resolver function for that specific field:
                  
                  ```js
                  Movie: {
                    // Static version
                    director(movie) {
                      if (!movie.director) return null;
                      return data.people.find(person => person.id === movie.director);
                    }
                  
                    // Promise-based version
                    director(movie) {
                      if (!movie.director) return null;
                      return fetch(`http://somemovieapi.com/people/${movie.director}`)
                        .then(response => response.json())
                        .catch(errors => console.log(errors));
                    }
                  },
                  ```
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Write the resolvers for your Boomtown items and users now.
                  
                  You will need to write extra resolvers to provide data to the `itemOwner` and `borrower` fields for `Item` type, and `items` and `borrowed` fields for the `User` type.
                  
                  When you're done, try querying items and users using the GraphiQL interface.
              </section>
              <section data-markdown>
                  # Query Variables
                  
                  As per our schema, we can query for individual movies by ID:
                  
                  ```js
                  query {
                    movie(id: 1) {
                      title
                    }
                  }
                  ```
                  
                  *Try this out in GraphiQL now.*
              </section>
              <section data-markdown>
                  # Query Variables
                  
                  We often need to dynamically pass data in as the query argument. To do that, give your query a name and give an `$id` argument, then pass that ID into the `movie` query. 
                  
                  ```js
                  query fetchMovie($id: ID!) {
                    movie(id: $id) {
                      title
                    }
                  }
                  ```
                  
                  You can set the value of `$id` in GraphiQL like this in the **Query Variables panel**:
                  
                  ```js
                  {
                    "id": 2
                  }
                  ```
                  
                  ???
                  
                  - As a best practice, we'll name all of our queries when we send them from the front-end of Boomtown
                  - Names queries allow us to name multiple queries per document, and actually send query variables along with our request
                  - Query variables will be very useful to use when we want to use props (like route params) to query for specific data
              </section>
              <section data-markdown>
                  # Using GraphQL in Boomtown
                  
                  In order to use GraphQL on the front-end, we'll need to add the **[React Apollo Client](http://dev.apollodata.com/react/)** to the front-end app:
                  
                  ```js
                  npm i -S react-apollo graphql-tag
                  ```
                  
                  ???
                  
                  Apollo client will allow us to shift from imperative to declarative data fetching in the client. Data fetching logic be gone!
                  
                  Imperative data fetching:
                  1. construct and send the HTTP request
                  2. receive and parse data response
                  3. store data locally
                  4. display the inforamiton in the UI
                  
                  Declarative data fetching:
                  1. describe its data requirements
                  2. display the information in the UI
                  
                  (All of the lower level networking tasks should be abstracted away by Apollo Client.)
              </section>
              <section data-markdown>
                  # Create a Client
                  
                  Next we'll create an `ApolloClient` instance in our React app in `config/apolloClient.js`:
                  
                  ```js
                  import ApolloClient, { createNetworkInterface } from 'react-apollo';
                  
                  const networkInterface = createNetworkInterface({
                      uri: 'http://localhost:5000/graphql'
                  });
                  
                  const client = new ApolloClient({ networkInterface });
                  
                  export default client;
                  ```
              </section>
              <section data-markdown>
                  # Apollo Provider
                  
                  Next we'll wrap our entire app in an `<ApolloProvider>` component to make the client instance available to our React component hierarchy in `index.js`:
                  
                  ```js
                  import { ApolloProvider } from 'react-apollo';
                  import client from './config/apolloClient';
                  ```
                  
                  ```js
                  <MuiThemeProvider muiTheme={muiTheme}>
                      <ApolloProvider client={client} store={store}>
                          <ConnectedRouter history={history}>
                              <Layout>
                                  <Routes />
                              </Layout>
                          </ConnectedRouter>
                      </ApolloProvider>
                  </MuiThemeProvider>
                  ```
              </section>
              <section data-markdown>
                  # Integrate with Redux
                  
                  `ApolloClient` has its own Redux store, but we can integrate into our existing store instead in `redux/store.js`:
                  
                  ```js
                  // ...other imports
                  import rootReducer from './reducers';
                  import client from '../config/apolloClient';
                  import { history } from '../index';
                  ```
                  
                  ```js
                  export default createStore(
                      rootReducer,
                      composeWithDevTools(
                          applyMiddleware(
                              client.middleware(),
                              thunk,
                              routerMiddleware(history)
                          )
                      )
                  );
                  ```
                  
                  ???
                  
                  - Note that we will never pull Apollo data directly from the store
                  - We will use the `graphql` and `connect` HOCs as containers instead
                  - So this is more for debugging purposes
                  - http://dev.apollodata.com/core/how-it-works.html
                  
              </section>
              <section data-markdown>
                  # Integrate with Redux
                  
                  Add the Apollo reducer as well!
                  
                  ```js
                  import { combineReducers } from 'redux';
                  
                  import client from '../config/apolloClient';
                  import itemReducer from './modules/items';
                  import userReducer from './modules/user';
                  
                  export default combineReducers({
                      apollo: client.reducer(),
                      items: itemReducer,
                      user: userReducer
                  });
                  
                  ```
              </section>
              <section data-markdown>
                  # CORS
                  
                  Before we can access our GraphQL endpoint from our React app, we'll need to **enable CORS** (Cross-Origin Resource Sharing) in our GraphQL app.
                  
                  To do that, **we'll need to apply some extra middleware** to our Express server:
                  
                  ```bash
                  npm install cors --save
                  ```
                  
                  In `index.js` of our server:
                  
                  ```js
                  import cors from 'cors';
                  
                  app.use('*', cors());
                  ```
                  
                  ???
                  
                  - Enabling CORS will allow JavaScript to make requests across domain boundaries
                  - This will add the `Access-Control-Allow-Origin:*` header to the response
                  - This will allow Ajax requests that would otherwise have been forbidden by the same-origin policy (because it wouldn't be very secure if we could use JS to make requests across domains any place and any time...)
              </section>
              <section data-markdown>
                  # graphQL HOC
                  
                  Just as Redux `connect` allows us to create HOCs, Apollo has a `graphql` function to create HOCs to pass data as props:
                  
                  ```js
                  import React from 'react';
                  import { graphql } from 'react-apollo';
                  import gql from 'graphql-tag';
                  
                  const MoviesList = ({ data }) => (
                    <ul>{data.movies.map(({title}, i) => <li key={i}>{title}</li>)}</ul>
                  );
                  
                  const fetchMovies = gql`
                    query fetchMovies {
                      movies {
                        title
                      }
                    }
                  `;
                  
                  export default graphql(fetchMovies)(MoviesList);
                  ```
                  
                  ???
                  
                  - When we use graphql with a GraphQL query document, two things happen:
                    1. The query is loaded from the Apollo client-side data store, or the server if the data is not in the store
                    2. Our component subscribes to the store, so that it is updated if the data changes as the result of a mutation or some other response from the server
                  - `gql` is a function, and using in front of template string creates a tagged template literal (tags allow you to parse template literals with a function)
              </section>
              <section data-markdown>
                  # With Redux connect
                  
                  ```js
                  // ...imports above, including Redux "connect" now
                  const MoviesList = ({ data, filters }) => (
                    <ul>
                      {data.movies
                        .filter({ title } => filters.includes(title))
                        .map(({ title }, i) => <li key={i}>{title}</li>)}
                    </ul>
                  );
                  
                  const fetchMovies = gql`
                    query fetchMovies {
                      movies {
                        title
                      }
                    }
                  `;
                  
                  const mapStateToProps = state => ({ filters: state.movies.filters });
                  
                  const MoviesListWithData = graphql(fetchMovies)(MoviesList);
                  export default connect(mapStateToProps)(MoviesListWithData);
                  ```
                  
                  ???
                  
                  - This means you can easily pass variables into your queries that come from Redux state, or dispatch actions that rely on server-side data
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Take what you've just learned and use it refactor your `<ItemsContainer>` component to fetch data from your GraphQL server.
                  
                  There are a few things to consider...will you need to explicitly keep your items in your store (and dispatch an action to fetch them), or will Apollo handle that? If you're not using your old items actions, [how do we know if the data is loading](http://dev.apollodata.com/react/queries.html#default-result-props)?
                  
                  What shape will your query be? How will your proptypes need to change as a result?
                  
                  *Remember to leverage the power of nested queries!*
              </section>
              <section data-markdown>
                  # Dynamic Query Vars
                  
                  We can pass component data into the query as an argument:
                  
                  ```js
                  const MovieListing({ data }) => (
                    <p>{data.title}</p>
                  );
                  
                  const fetchMovie = gql`
                    query fetchMovie($id: ID!) {
                      movie(id: $id) {
                        title
                      }
                    }
                  `;
                  
                  export default graphql(fetchMovie, {
                    options: ownProps => ({
                      variables: {
                        id: ownProps.match.params.id // e.g. from React Router!
                      }
                    }),
                  })(MovieListing);
                  ```
                  
              </section>
              <section data-markdown>
                  # Exercise 4
                  
                  Now using what you just learned about query variables, refactor your `<ProfileContainer>` component to fetch data from your GraphQL server for a specific user on a `profile/:id` route.
                  
                  Again, how will your proptypes change? Do you still need your Redux actions and reducer for user data anymore?
                  
                  Additionally, can GraphQL help you filter items by user in advance with a nested query (instead of monkeying around with this on the client)? What about the other users that a user has borrowed items from?
              </section>
              <section data-markdown>
                  # Mutating Data
              </section>
              <section data-markdown>
                  # Defining Mutations
                  
                  Any mutations we want to permit on our data must be added to the schema as the `Mutation` root query type:
                  
                  ```js
                  // back in ./api/schema.js...
                  
                  const typeDefs = `
                  
                    # Other types defined above...
                  
                    type Mutation {
                      addPerson (
                        name: String!
                        birthday: String
                        placeOfBirth: String
                        bio: String
                        filmography: [ID]
                      ): Person
                    }
                  `;
                  ```
              </section>
              <section data-markdown>
                  # Mutation Resolver
                  
                  We must also another key to our `resolveFunctions` object called `Mutation`, and define what the mutation should do:
                  
                  ```js
                  Mutation: {
                    addPerson(root, args) {
                      const newPerson = {
                        id: data.people.length + 1,
                        name: args.name,
                        birthday: args.birthday,
                        placeOfBirth: args.placeOfBirth,
                        bio: args.bio,
                        filmography: args.filmography
                      }
                  
                      data.people.push(newPerson);
                      return newPerson;
                    }
                  }
                  ```
              </section>
              <section data-markdown>
                  # Using Mutations
                  
                  Mutation queries always start with the `mutation` keyword:
                  
                  ```js
                  mutation createPerson(
                    $name: String!
                    $placeOfBirth: String
                  ) {
                    addPerson(
                      name: $name
                      placeOfBirth: $placeOfBirth
                    ) {
                      name
                      placeOfBirth
                    }
                  }
                  ```
                  
                  We can also **specify a payload** for the mutation (like getting the response back from a POST request).
              </section>
              <section data-markdown>
                  # Exercise 5
                  
                  Now define a mutation in your Boomtown schema to add an item. You will need to set it up with `title`, `imageUrl`, `itemOwner`, `description`, and `tags` parameters. The JSON server will auto-generate the `id`, but you will statically set the `createdOn`, `available`, and `borrower` properties in the resolver.
                  
                  Your resolver will need to make a `POST` request to the JSON server's `/items` endpoint, and return the response as JSON.
                  
                  For now, just test out your new mutation in GraphiQL, as we won't wire this up to the front-end of Boomtown until we add Redux Form next week.
              </section>
              <section data-markdown>
                  # Cleaning Up and Optimizing Data Fetching
              </section>
              <section data-markdown>
                  # Exercise 6
                  
                  As a best practice, it would be better to remove our data fetching code directly from our resolver code blocks, and instead abstract this away into helper functions.
                  
                  Create a `api/jsonServer.js`, refactor your data-fetching logic in there now as exported functions. Do all of your resolvers need their own helper functions?
                  
                  Import your new data fetching functions into `resolvers.js`, replace your existing `fetch` requests, and test your app to make sure everything still works.
              </section>
              <section data-markdown>
                  # GET Requests Run Amok
                  
                  Try running this request in Boomtown's GraphiQL interface:
                  
                  ```
                  # Get items with owners, and list of all their items
                  
                  query {
                    items {
                      title
                      itemOwner {
                      fullName
                        borrowed {
                          title
                        }
                      }
                    }
                  }
                  ```
                  
                  *Take a look at requests to the JSON server logged in your Terminal. What do you see?*
              </section>
              <section data-markdown>
                  # Batch Those Requests!
                  
                  The **[DataLoader](https://github.com/facebook/dataloader)** library will up us solve this problem with its built-in batching and caching features. Install the library in Boomtown now:
                  
                  ```bash
                  npm install --save dataloader
                  ```
                  
                  ???
                  
                  - DataLoader is a utility that supports query batching and caching out of the box
                  - Caching is a process of storing data in a temporary storage area
                  - Batching is a way to coalesce all individual loads which occur within a single frame of execution and then calling a batch function with all requested keys
              </section>
              <section data-markdown>
                  # Create Loaders
                  
                  To create a loader, we will instantiate a new `DataLoader` and pass it a function that accepts some keys and returns a list of Promises (aka a **batch function**).
                  
                  We'll do this in a new `api/loaders.js` file:
                  
                  ```js
                  import DataLoader from 'dataloader';
                  import { getUserOwnedItems } from './jsonServer';
                  
                  export default function() {
                    return {
                      UserOwnedItems: new DataLoader(ids => (
                        Promise.all(ids.map(id => getUserOwnedItems(id));
                      ))),
                      // other data loaders go here...
                    }
                  };
                  ```
                  
                  ???
                  
                  - In our case, the individual item and user loaders should take a list of resource IDs and return the fetched data from each of their related endpoints (we'll use our helper functions for that)
              </section>
              <section data-markdown>
                  # Set Context
                  
                  This isn't enough by itself though! We'll need to set our data loaders as a `context` for our GraphQL server in `index.js`:
                  
                  ```js
                  import createLoaders from './api/loaders';
                  
                  app.use('/graphql', bodyParser.json(), graphqlExpress({
                    schema,
                    context: { loaders: createLoaders() }
                  }));
                  ```
                  
                  ???
                  
                  - The `context` property simply allows us to set some context to any of our resolvers
                  - In this case, it will be the data loaders, but we could also use it for something like setting API keys for all requests to a third-party service
              </section>
              <section data-markdown>
                  # Use Context in Resolver
                  
                  Lastly, we'll add `context` as the third parameter to our resolver function, and call our data loader there instead of calling the helper function directly:
                  
                  ```js
                  User: {
                    items: (user, args, context) => {
                      return context.loaders.UserOwnedItems.load(user.id);
                    },
                    // other resolvers here...
                  }
                  ```
              </section>
              <section data-markdown>
                  # Exercise 7
                  
                  Now that we've created one data loader together, create three more for batching requests for items that a user has borrowed, individual items, and individual users.
                  
                  Use your data loaders in your resolvers, and test your app to make sure everything still works.
              </section>
              <section data-markdown>
                  # Bonus Topics
                  
                  Some more advanced topics in GraphQL you may want to look into
                  
                  - [Subscriptions](http://dev.apollodata.com/tools/graphql-subscriptions/subscriptions-to-schema.html)
                  - [Fragments](http://graphql.org/learn/queries/#fragments)
                  - [Enums](http://graphql.org/learn/schema/#enumeration-types)
                  - [Unions](http://graphql.org/learn/schema/#enumeration-types)
                  - [Interfaces](http://graphql.org/learn/schema/#interfaces)
                  - [Inputs](http://graphql.org/learn/schema/#input-types)
                  
                  ???
                  
                  **Subscriptions:**
                  
                  - when a client subscribes to an event, it Create and holds a steady connection to the server to be informed about events
                  - the server will push the corresponding data to the client when an event fires
                  - queries and mutations follow a typical request response cycle
                  - subscriptions are sustained
                  
                  **Fragments:**
                  
                  - ways to reuse chunks of queries
                  
                  **Enums:**
                  
                  - enums to express the sematics of a type that has a fixed set of values
                  
                  **Interfaces:**
                  
                  - an interface can be used to describe a type in an abstract way
                  
                  **Unions:**
                  
                  - a union type is a type that should be either of a collection of types (with conditional fragments)
                  
                  **Inputs:**
                  
                  - allow us to pass complex objects as arguments into a field (helpful for mutations where you might want to pass a whole object as an argument)
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - Why GraphQL is awesome
                  - Graph theory and GraphQL core concepts
                  - How to set-up a GraphQL server
                  - How to define queries and mutations
                  - How to use Apollo client in a React app
                  - How to optimize data fetching in a GraphQL API
              </section>
          </section>



          <section>
              <section data-markdown>
                  # Intro to Databases with PostgreSQL
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Determine what a database is
                  2. Introduce the various types of databases available
                  3. Introduce Codd's Rules (RDBMS)
                  4. Install and set up PostgreSQL
                  5. Demonstrate the SQL language
                  6. Setup a Postgres user and database for use in our project application
                  
              </section>
              <section data-markdown>
                  #What is a Database?
                  
                  A database is an organized collection of data. The data is typically organized to model relevant aspects of reality. The process of describing the organization of data in your database is called *modelling*.
              </section>
              <section data-markdown>
                  #Why we use Databases?
                  
                  Think of how we get the information about the weather from the newspaper. Information can be printed but it cannot be continuously updated without printing a new paper. We call this **static** data. 
                  
                  We've used static data in the form of a JSON file, in our project already. Today we're going to replace static data with a database, which will allow us to update the data in our application **dynamically**, whilst persisting that data.
              </section>
              <section data-markdown>
                  # Relational Databases (RDBMS)
                  
                  To complete our project application, we'll use a database system called **Postgres**.
                  
                  The principles of RDBMS systems were first formalized by Computer Science researcher **Edgar F. Codd**.
                  
                  [Codd's 12 Rules](https://www.tutorialspoint.com/dbms/dbms_codds_rules.htm)
                  
                  ???
                  Pause and review Codd's 12 rules from the pre-work reading.
                  [https://www.tutorialspoint.com/dbms/dbms_codds_rules.htm](https://www.tutorialspoint.com/dbms/dbms_codds_rules.htm)
                  
                  A "Management System" is more than just a database. What are the other components that make up the Postgres RDBMS?
                  eg. psql prompt
              </section>
              <section data-markdown>
                  # Relational Database
                  
                  A Relational Database is made up of several components, of which the **table** is most significant.  The table is where all the data in a database is stored, and without tables, there would not be much use for relational databases.
                  
                  ![Table](/public/img/slide-assets/sql-table.png)
                  
                  *What do Codd's rules say about tables in an RDBMS?*
                  
                  ???
                  Be sure to provide some clarity about "tables". Comparing tables in a relational database to those in common spreadsheet applications like excel is usually sufficient.
                  
                  Google for a diagram of a large relational system. Find one and show the students the level of complexity inherent in large relational systems.
              </section>
              <section data-markdown>
                  # Who is Postgres?
                  
                  "PostgreSQL is a general purpose and object-relational database management system, the most advanced open source database system. PostgreSQL was developed based on POSTGRES 4.2 at Berkeley Computer Science department, University of California."
                  
                  *It's Open Source!*
                  
                  ???
                  Take the opportunity to contrast Open Source technology vs proprietary tech, ie Microsoft's MySQL.
              </section>
              <section data-markdown>
                  # Start Using Postgres
                  
                  Once you've installed the Postgress.app, use the following command to log into the Postgres Shell.
                  
                  ```
                  psql
                  ```
                  You should see a prompt with your OS username: <br/>
                  ('RED' is the name of the user)
                  
                  ```
                  RED=#
                  ```
                  
                  You're connected to the Postgres RDBMS!
              </section>
              <section data-markdown>
                  # Get Help
                  
                  The `psql` shell provides all of the functionality for using our Postgres RDBMS.
                  To learn more, type the following command into the shell:
                  
                  ```
                  \?
                  ```
                  **How do you quit the shell?** (Use `\?` to find th command)
                  
                  ```
                  \h
                  ```
                  This command will list all of the SQL commands you can use to interact with your Relational Databases!<br/>
                  *To return to the shell type ctrl+c*
              </section>
              <section data-markdown>
                  # SQL
                  
                  The output of the `\h` command lists all of the **SQL** commands we can use to interact with our (yet to be created)
                  databases.
                  
                  **SQL** is the common language used to interact with RDBMS systems that follow Codd's Rules.
                  
                  How is SQL defined in Codd's rules?
                  
                  ???
                  **How is SQL defined in Codd's rules?**<br/>
                  
                  Rule 5: <br/>
                  *Comprehensive Data Sub-Language Rule* <br/>
                  A database can only be accessed using a language having linear syntax that supports data definition, data manipulation, and transaction management operations. This language can be used directly or by means of some application. If the database allows access to data without any help of this language, then it is considered as a violation.
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  - Create 2 Postgres databases
                  We'll use one of these databases to try out new things. The other one we'll use as the official database in our project.
                  
                  - Use the `CREATE USER <name> WITH PASSWORD <pw>` command to create a new user and configure a password for each database.
                  
                  This setup is meant to mock a real world database setup, and to give us the opportunity to become familiar with
                  creating and authorizing a new Database on your local machine. In a real production setting, our setup would be more complicated.
                  
                  ???
                  
                  Encourage the students to use the Postgres Docs as well as the help commands to determine how to complete the exercise.
                  
                  Commands: 
                  
                  Start Postgres Shell
                  ```
                  psql
                  ```
                  Inside the Shell
                  
                  ```sql
                  CREATE USER <db-user> WITH PASSWORD '<new-password>'
                  CREATE DATABASE <db-name>;
                  GRANT ALL PRIVILEGES ON DATABASE <db-name> TO <db-user>;
                  ```
              </section>
              <section data-markdown>
                  # More `psql` commands
                  
                  To list the databases we've created in the previous exercise use the following command from the psql shell:
                  ```
                  \l
                  ```
                  To list the new Postgres users we created use the following command from the psql shell:
                  ```
                  \du
                  ```
              </section>
              <section data-markdown>
                  #Adding Data to Postgres
              </section>
              <section data-markdown>
                  # Relational Database
                  
                  In a relational system, we create an **schema** by defining relationships between the data stored in various of tables.
                  ![Relational-Database](/public/img/slide-assets/relational-databases.png)
              </section>
              <section data-markdown>
                  # Normalization
              </section>
              <section data-markdown>
                  #What is Normalization?
                  
                  "Database normalization is the process of organizing the attributes and tables of a relational database to minimize data redundancy."
                  
                  [source](https://www.quora.com/What-is-database-normalization-in-simple-terms-with-examples)
              </section>
              <section data-markdown>
                  ### Codd on Normalization
                  
                  1. To free the collection of relations from undesirable insertion, update and deletion dependencies.
                  2. To reduce the need for restructuring the collection of relations as new types of data are introduced, and thus increase the life span of application programs.
                  3. To make the relational model more informative to users.
                  4. To make the collection of relations neutral to the query statistics, where these statistics are liable to change as time goes by.
                  
                  [source](https://www.quora.com/What-is-database-normalization-in-simple-terms-with-examples)
              </section>
              <section data-markdown>
                  # A Table for Items
                  
                  First, log into psql using a specific user & database with the following command:
                  ```
                  psql -U <db-user> -d <db-name>
                  ```
                  Run the following **SQL** command to create your first table!
                  
                  ```sql
                  CREATE TABLE IF NOT EXISTS "items";
                  ```
              </section>
              <section data-markdown>
                  # Adding Columns
                  
                  ```sql
                  ALTER TABLE "items" ADD COLUMN itemid TYPE serial;
                  ALTER TABLE "items" ADD COLUMN title TYPE text NOT NULL;
                  ALTER TABLE "items" ADD COLUMN description TYPE text NOT NULL;
                  ALTER TABLE "items" ADD COLUMN imageurl TYPE text NOT NULL;
                  ALTER TABLE "items" ADD COLUMN ownerid TYPE text NOT NULL;
                  ALTER TABLE "items" ADD COLUMN borrowerid TYPE text NOT NULL;
                  ```
                  
                  Copying and pasting each line into the psql shell allows us to modify the table we created, adding columns with their appropriate data types.
                  
              </section>
              <section data-markdown>
                  # All At Once
                  
                  ```sql
                  CREATE TABLE "public"."items" (
                    "itemid" serial primary key,
                    "title" text not null,
                    "imageurl" text DEFAULT null,
                    "description" text not null,
                    "ownerid" text DEFAULT null,
                    "borrowerid" text DEFAULT null
                  );
                  ```
                  ### Q & A
                  What is the function of a Primary Key? <br/>
                  What does the `serial` datatype do? <br/>
                  What does the DEFAULT attribute mean? <br/>
                  
                  ???
                  
                  Be sure to stop to talk about the following details:
                  
                  - serial data type
                  - PRIMARY KEY
                  - NOT NULL
                  - DEFAULT
              </section>
              <section data-markdown>
                  # Mistakes Happen
                  
                  If you need to start over, you can remove your new table with the following command:
                  
                  ```sql
                  DROP TABLE "public"."items";
                  ```
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Populating your Relational Database. 
                  Use what you know to create the **Tags** table!
                  
                  *Hint: use the `\du` command to check if the table was successfully created.*
                  
                  ???
                  
                  Solution: 
                  
                  ```sql
                  CREATE TABLE "public"."tags" (
                    "tagid" serial PRIMARY KEY,
                    "title" text NOT NULL
                  )
                  ```
              </section>
              <section data-markdown>
                  # Relationships Matter
              </section>
              <section data-markdown>
                  # Relational Relationships
                  
                  We've created 2 tables in our database. Each table will hold information about a specific *thing* in our application.
                  
                  Now, it's time to use our Relational Database to create relationships between them! But first it's helpful to know what kind of relationships we can define. Here are the most common: 
                  
                  - 1 to 1 (1:1)
                  - 1 to many (1:n)
                  - Many to many (n:n)
                  
                  ???
                  
                  Here you can introduce the following relationships among data in the project application:
                  
                  **Items and Tags share a n:n (Many to many) relationship.** <br/>
                  **Users and Items share a 1:n (One to many) relationship.**
                  
                  We haven't mentioned Users yet. Introduce them now.
              </section>
              <section data-markdown>
                  # Primary Keys in Action
                  
                  Imagine we're storing Users in our Database (We're going to put users in a separate database and connect them using GraphQL, which we'll talk about later):
                  
                  ```sql
                  CREATE TABLE "public"."users" (
                    "userid" serial primary key,
                    "name" text not null,
                  );
                  ```
              </section>
              <section data-markdown>
                  # Primary Keys in Action
                  
                  In Relational Databases, the PRIMARY KEY is used to define relationships between tables. To relate users to their items,we would use the PRIMARY KEY as follows, when creating the items table:
                  
                  ```sql
                  CREATE TABLE "public"."items" (
                    "itemid" serial primary key,
                    "title" text not null,
                    "imageurl" text DEFAULT null,
                    "description" text not null,
                    "ownerid" REFERENCES users (userid),
                    "borrowerid" REFERENCES users (userid)
                  );
                  ```
                  
                  Can you spot the relationship?
              </section>
              <section data-markdown>
                  # Primary Key Constraint
                  
                  ```sql
                  "ownerid" REFERENCES users (userid),
                  "borrowerid" REFERENCES users (userid)
                  ```
                  These lines are telling Postgres that the values stored in these columns will be references to values stored in the `users` table, namely the userid of actual users.
                  
                  This is called a **Primary Key constraint**, because no other value can be stored in this column, and it's a common way of defining relationships between tables in a relational database.
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  **Defining an n:n (Many to many) relationship**<br/>
                  
                  Creating a 1:n relationship is straightforward. How should we create a many-to-many relationship? <br/>
                  
                  Use what you know, and see if you can reason about how to implement a many-to-many relationship between **Items** and **Tags** in your database.
                  
                  ???
                  
                  Solution
                  
                  Create a Link Table
                  
                  ```sql
                  CREATE TABLE "public"."itemtags" (
                    "itemid" number references items (itemid),
                    "tagid" number references tags (tagid)
                    unique (itemid, tagid)
                  )
                  ```
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - What is an RDBMS
                  - How to set up and configure Postgres
                  - How to use the `psql` shell
                  - How to create Postgres users & databases
                  - How to alter existing tables using `psql`
                  - How to define column data-types for our database tables
                  - How to create relationships between database tables using primary keys
                  
              </section>
              <section data-markdown>
                  # Lab activity
                  
                  Now that we've created our schema (table) for our project application, use the `INSERT` command to populate your data base with some mock data.
                  
                  Add the following mock data to your database:
                  
                  - At least 4 Items
                  - All of the Tags (Categories)
                  
                  Ensure that you've set up the appropriate foreign key constraints!
                  
                  ???
                  
                  Solution
                  
                  ```sql
                  INSERT INTO items
                  (
                    title,
                    imageurl,
                    description
                  )
                  VALUES (
                    'Camp Stove',
                    'https://firebasestorage.googleapis.com/v0/b/boomtown-dfdd8.appspot.com/o/demo-images%2Fcamp-stove.jpg?alt=media',
                     'All you need to cook gourmet meals on your next trek into the wild.',
                  );
                  
                  INSERT INTO tags
                  (
                    title
                  )
                  VALUES (
                    'Household Items'
                  );
                  
                  INSERT INTO itemtags
                  (
                    tagid,
                    itemid
                  )
                  VALUES (
                    1,
                    1
                  );
                  ```
              </section>
          </section>



          <section data-markdown>
              <section data-markdown>
                  # Intro to Databases with PostgreSQL II
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Review
                  2. Constraints in detail
                  3. Patterns for updating and deleting relational data
                  4. Install and set up the `node-postgres` library
              </section>
              <section data-markdown>
                  .left-column[
                  ### RDBMS Recap
                ]
                
                .right-column[
                
                Here are the main takeaways from yesterday's lesson.
                Can you think of any other important points?
                
                - Data is stored in tables
                - Data in tables in normalized
                - Data is accessed using SQL 
                - Data consistency / integrity is maintained by Constraints
                - Relationships between tables are defined by
                Foreign Key / Primary Key references
                ]
              </section>
              <section data-markdown>
                  # Constraints in Detail
                  
                  Here is an example of a constrain we've added to a table in our Database: 
                  
                  ```sql
                  TEXT NOT NULL
                  ```
                  Constraining our columns ensures that any data we add to our database is consistent.
                  
                  - What other constraints are present on the columns in tables we created?<br/>
                  - Why are constraints important?
                  
                  .footnote[.red[*]
                     constraints can be written in ALL CAPS or lowercase
                  ]
                  
                  ???
                  
                  Constraints we've created:
                  
                  - text DEFAULT null
                  - number references items (itemid)
                  - number references tags (tagid)
                  - unique (itemid, tagid)
                  - serial primary key
                  - text not null
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Add the appropriate constraints to your project's database.
                  
                  - What fields in our tables should be unique?
                  - What are the specific types of data we're storing in each column?
                  - Do we need to initialize any default values in our tables?
                  - How can we check if the data being sent by client applications for storage is valid?
              </section>
              <section data-markdown>
                  # Primary Key Constraint
                  
                  #### A Primary Key is the column that will be used as a reference in other tables of related data.
                  A Primary Key is defined by adding the PRIMARY KEY constraint to a specific column in your table.
                  
                  - Can a table have more than one Primary Key?
                  - Does a Primary Key have to be unique for each record (row) in your table?
                  
                  .footnote[.red[*]
                     There are other ways of defining Primary Keys
                  ]
              </section>
              <section data-markdown>
                  # Foreign Key Constraint
                  
              </section>
              <section data-markdown>
                  #### A Primary Key is the column that will be used as a reference in other tables of related data.
                  A Primary Key is defined by adding the PRIMARY KEY constraint to a specific column in your table.
                  
                  - Can a table have more than one Primary Key?
                  - Does a Primary Key have to be unique for each record (row) in your table?
                  
                  .footnote[.red[*]
                     There are other ways of defining Primary Keys
                  ]
              </section>
              <section data-markdown>
                  # Foreign Key Constraint
              </section>
              <section data-markdown>
                  #### A Foreign Key Constraint is a column which references (usually) the Primary Key of another table.
                  A Foreign Key is defined by adding the PRIMARY KEY constraint to a specific column in your table.
                  
                  - Can a table have more than one Foreign Key?
                  - Does a Foreign Key have to be unique for each record (row) in your table?
              </section>
              <section data-markdown>
                  Get to know Constraints. Take a moment and review the Postgres documentation on constraints:
                  ### [Postgres 9.6 Docs: Constraints](https://www.postgresql.org/docs/9.6/static/ddl-constraints.html)
              </section>
              <section data-markdown>
                  # Querying Relations
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Now that we have our data and relationships set up. Let's write some SQL queries.
                  
                  - Write a query that returns all of the tags for a given Item.
                  - Write a query that returns the number of Items in the database.
                  - Write a query that returns the average number of Items which are tagged in your database.
                  - Write a query that returns the 5 newest Items.
              </section>
              <section data-markdown>
                  # Environment Variables
                  
              </section>
              <section data-markdown>
                  # Environment Variables
                  
                  Environment variables are: 
                  
                  .large[...values available to a process, defined by the system where the process is executing. ]
              </section>
              <section data-markdown>
                  # Environment Variables
                  
                  In Express, we'll need to provide values to our application that will be used at runtime. 
                  
                  .large[
                      Environment variables should be *dynamic* depending on the 'Environment' where your app is running.
                  ]
                  
                  ???
                  
                  Explanation: 
                  
                  We don't want to have to manually specify specific variables for each environment, in out application code.
                  
              </section>
              <section data-markdown>
                  # Defining Environments
                  
                  **Development** (Your computer)
                    - Connections to Express ingress from `localhost` (localhost:3000).
                    - Postgres is also running on `localhost` (localhost:5432)
                  
                  **Production** (On a server computer) 
                    - Connections to Express ingress via some domain, eg *boom.academy.red*
                    - Postgres could be running on a separate domain.
              </section>
              <section data-markdown>
                  # Local Environment
                  
                  To view your local environment run the following command:
                  
                  ```bash
                  env
                  ```
                  
                  .large[What do you see?]
              </section>
              <section data-markdown>
                  # Learn to Use Environment Variables
                  
                  Take a moment and read through this tutorial from DigitalOcean: <br/>
                  
                  [How To Read and Set Environmental and Shell Variables](https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-a-linux-vps)
              </section>
              <section data-markdown>
                  # `process.env`
                  
                  Here is the code we'll use to connect Express to our environment.
                  This example contains the necessary configuration for connecting to Postgres. 
                  You should replace `boomtowndemo` with the values you set for your own database.
                  
                  ```js
                  
                    app.set('PGUSER', process.env.PGUSER || 'boomtowndemo');
                    app.set('PGPASSWORD', process.env.PGPASSWORD || 'boomtowndemo');
                    app.set('PGDATABASE', process.env.PGDATABASE || 'boomtowndemo');
                    app.set('PGHOST', process.env.PGHOST || 'localhost');
                  
                  ```
                  
                  Where should this code be written? <br/>
                  What other Environment variables doe we need?
                  
                  
                  ???
                  
                  Code should be written in a file called configs.js with the following export
                  
                  ```js
                  export default function(app) {
                    app.set ...
                  }
                  ```
                  
                  And imported into the main `index.js` file
                  
                  ```js
                  import initConfigs from './configs
                  initConfigs(app);
                  ```
                  
                  Full config:
                  
                  ```js
                  app.set('DEV_JSON_SERVER', 'http://localhost:3001');
                  app.set('DEV_WEB_SERVER', 'http://localhost:3000');
                  
                  app.set('FIREBASE_API_KEY', ...
                  app.set('FIREBASE_AUTH_DOMAIN', ...
                  app.set('FIREBASE_DB_URL', ...
                  app.set('FIREBASE_PROJECT_ID' ...
                  app.set('FIREBASE_STORAGE_BUCKET' ...
                  
                  app.set('PGUSER', process.env.PGUSER ...
                  app.set('PGPASSWORD', process.env.PGPASSWORD ...
                  app.set('PGDATABASE', process.env.PGDATABASE ...
                  app.set('PGHOST', process.env.PGHOST ...
                  ```
              </section>
              <section data-markdown>
                  .large[Installing `node-postgres`]
              </section>
              <section data-markdown>
                  # `node-postgres`
                  
                  This is the library we'll use to connect to our Postgres database from Express. First, install the dependency.
                  ```
                  npm i -S pg
                  ```
                  
                  For usage information, take a look at the documentation. It's awesome!<br/>
                  
                  .large[[Node Postgres Docs](https://node-postgres.com/)]
              </section>
              <section data-markdown>
                  # Exercise 4
                  
                  See the Lesson page for instruction on how to add Postgres to your project.
                  Once you've added it, add the following code to your Connection Pool instance configuration object:
                  
                  ```js
                  user: app.get('PGUSER'),
                  host: app.get('PGHOST'),
                  database: app.get('PGDATABASE'),
                  password: app.get('PGPASSWORD')
                  
                  ```
              </section>
              <section data-markdown>
                  #Lab Activity
                  
                  1) Add the necessary environment variables to our Express server.<br/>
                  2) Connect to our local instance of Postgres from our Node/Express server.<br/>
                  3) Test the connection by performing the `SELECT NOW()` query.<br/>
                  4) Create the necessary files & folders to hold our Postgres code. (Service pattern).<br/>
                  5) Begin to write the methods for querying and retrieving information from Postgres, to use in our GraphQL resolvers!<br/>
              </section>
          </section>


          <section>
              <section data-markdown>
                  # Forms in React
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
                
              </section>
              <section data-markdown>
                  ## Exercise 1
                  
                  Write a basic form in HTML only that alerts the value of an input.
                  
              </section>
              <section data-markdown>
                  # Basic Form
                  
                  `onSubmit` will be triggered when the button with type `submit` is clicked.
                  
                  ```html
                  <form onSubmit="alert(document.getElementById('name').value)">
                    <input id="name" type="text" />
                    <button type="submit">Submit</button>
                  </form>
                  ```
                  
                  We can capture the input value using a selector.
              </section>
              <section data-markdown>
                  # Agenda
                  
                  Building forms in React
                  
                  1. Controlled vs. Uncontrolled components
                  2. React form events
                  3. Redux-Form
                  4. Form validation
                  5. Displaying errors
                  
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Install a repo of React-Form demos.
                  
                  ```shell
                  git clone https://github.com/redacademy/adp-react-forms.git
                  cd adp-react-form-demos
                  npm install
                  npm start
                  ```
              </section>
              <section data-markdown>
                  # React Forms
                  
                  Forms in React are not as intuitive as you might expect.
                  
                  Try the following input.
                  
                  ```html
                    <input
                      type="text"
                      value="expected"
                    />
                  ```
                  
                  - What happens? Why?
              </section>
              <section data-markdown>
                  # Controlled & Uncontrolled
                  
                  In React, form elements are considered "controlled" or "uncontrolled".
                  Read [React Forms](https://facebook.github.io/react/docs/forms.html).
                  
                  - With a partner, compare the "controlled" and "uncontrolled" input.
                  - Act out the differences, one person is a "controlled" input with a component parent, and the other "uncontrolled" with a parent.
              </section>
              <section data-markdown>
                  # React Form Events
                  
                  React has two major form events you should know:
                  
                  - `onChange`
                  - `onSubmit`
              </section>
              <section data-markdown>
                  # onChange
                  
                  `onChange` is attached to an input and called every time an input value changes.
                  
                  ```html
                  <input onChange={(value) => console.log(value)} />
                  ```
                  
                  - What might we use `onChange` for?
                  
              </section>
              <section data-markdown>
                  # onChange
                  
                  `onChange` is attached to an input and called every time an input value changes.
                  
                  ```html
                  <input onChange={(value) => console.log(value)} />
                  ```
                  
                  - What might we use `onChange` for?
                  
                  Updating an input's value every time the value changes.
              </section>
              <section data-markdown>
                  # Controlled
                  
                  A controlled components handles it's own component state.
                  
                  1. `onChange` calls `handleChange` method
                  2. `handleChange` updates component `state`
                  3. `state` change updates component view
              </section>
              <section data-markdown>
                  # Form Values
                  
                  Form values create an object with keys matching the "name" given to the inputs.
                  
                  ```html
                  <input name="title" defaultValue="React Forms"/>
                  <input name="description" defaultValue="Some practice"/>
                  ```
                  
                  Data:
                  
                  ```js
                  {
                    title: "React Forms",
                    description: "Some practice"
                  }
                  ```
              </section>
              <section data-markdown>
                  # onSubmit
                  
                  `onSubmit` is attached to a form, and called every time a "submit" event is triggered.
                  
                  ```html
                  <form onSubmit={(values) => console.log(values)}>
                    {/* ... inputs ... */}
                  </form>
                  ```
                  
                  - How can we trigger an `onSubmit` event?
              </section>
              <section data-markdown>
                  # onSubmit
                  
                  We can trigger an `onSubmit` event by setting the type of a button or input to "submit".
                  
                  ```html
                  <form onSubmit={(values) => console.log(values)}>
                    {/* ... inputs ... */}
                    <button type="submit">Submit</button>
                  </form>
                  ```
              </section>
              <section data-markdown>
                  ## Exercise 3
                  
                  Add an extra field to either your **controlled** or  **uncontrolled** form.
                  
                  The output data should be in JSON, like the following:
                  
                  ```json
                  {
                    "username": "name",
                    "password": "pass"
                  }
                  ```
              </section>
              <section data-markdown>
                  # A Common Issue
                  
                  The following code will throw an error on submit. Why?
                  
                  ```js
                  constructor(props) {
                    super(props);
                    this.state = { values: '' };
                  }
                  onSubmit(values) {
                    this.setState({ values });
                  }
                  render() {
                    return <form onSubmit={this.onSubmit}>
                      {/* ... */}
                    </form>
                  }
                  ```
              </section>
              <section data-markdown>
                  ## Exercise 4
                  
                  Add any of the following to a form of your choosing:
                  
                  - show an error message if the password is shorter than 5 characters
                  - make it impossible for a user to type a username longer than 8 characters
                  - validate that a username does not contain any capital letters
                  - disable the submit button if any of the fields are invalid
              </section>
              <section data-markdown>
                  # Redux Form
              </section>
              <section data-markdown>
                  # Redux Form
                  
                  Redux form is a popular library for... well... using forms with Redux.
                  
                  - form state props (valid)
                  - saves state to Redux store
                  - validation helpers (error messages)
                  
                  [Docs: Redux-Form](http://redux-form.com/6.0.1/).
              </section>
              <section data-markdown>
                  # Setup
                  
                  Add a formReducer for Redux form.
                  
                  ```js
                  import { createStore, combineReducers } from 'redux'
                  import { reducer as formReducer } from 'redux-form'
                  
                  const reducers = {
                    // ... your other reducers here ...
                    form: formReducer     // <---- Mounted at 'form'
                  }
                  const reducer = combineReducers(reducers)
                  const store = createStore(reducer)
                  ```
                  
                  [Docs: Getting Started](http://redux-form.com/6.0.2/docs/GettingStarted.md/)
              </section>
              <section data-markdown>
                  # reduxForm
                  
                  Connect a component to reduxForm. Add a unique form name.
                  
                  ```js
                  class FormComponent extends React.Component {/* ... */}
                  
                  FormComponent = reduxForm({
                    form: 'form1'
                  })(FormComponent);
                  ```
                  
                  [Docs: reduxForm](http://redux-form.com/6.0.2/docs/api/ReduxForm.md/)
              </section>
              <section data-markdown>
                  # State
                  
                  The **form name** corresponds to a **key** in your redux store.
                  
                  ```js
                  console.log(store.getState());
                  
                  /*
                  {
                    form: {
                      form1: {
                        // your form data here
                      }
                    }
                  }
                  */
                  ```
              </section>
              <section data-markdown>
                  # Props
                  
                  A component connected with `reduxForm` passes in several props.
                  
                  ```js
                  class FormComponent extends React.Component {
                    render() {
                      console.log(this.props);
                      return <form></form>
                    }
                  }
                  ```
                  
                  - Which props are added by Redux Form?
              </section>
              <section data-markdown>
                  # Props
                  
                  What might we use each of these props for?
                  
                  - dispatch
                  - pristine / dirty
                  - valid / invalid
                  - submitting
                  - error
                  
                  [Docs: Props](http://redux-form.com/6.0.2/docs/api/Props.md)
              </section>
              <section data-markdown>
                  # Field
                  
                  Field's are input components used with "redux-form".
                  
                  ```html
                  <Field
                    name="myField"
                    component="input"
                  />
                  ```
                  
                  Field's require a **name** and **component**.
                  
                  See other optional properties: [Docs: Field](http://redux-form.com/6.0.2/docs/api/Field.md/)
              </section>
              <section data-markdown>
                  # Custom Field's
                  
                  You can create your own custom `<Field />` components.
                  
                  ```js
                  // outside your render() method
                  const myCustomField = (field) => (
                    <div className="input-row">
                      <input {...field.input} type="text"/>
                      { field.meta.touched &&
                        field.meta.error &&
                        <span className="error">{field.meta.error}</span>
                      }
                    </div>
                  );
                  ```
              </section>
              <section data-markdown>
                  # handleSubmit
                  
                  Redux-Form adds a `handleSubmit` prop, which can be added to your form.
                  
                  ```html
                  
                  <form onSubmit={
                    this.props.handleSubmit((values) => console.log(values))
                  }>
                  ```
                  
                  `handleSubmit`, as the name implies, calls a function when data is submitted.
              </section>
              <section data-markdown>
                  # connect
                  
                  "react-redux" can be called after "redux-form" is applied.
                  
                  ```js
                  FormComponent = reduxForm({ form: 'form1' })(FormComponent);
                  FormComponent = connect(
                    mapStateToProps,
                    mapDispatchToProps
                  )(FormComponent);
                  ```
                  
                  `connect` connects the redux **state** and **dispatch** to the component.
                  
              </section>
              <section data-markdown>
                  # Submit Function
                  
                  We can pass a submit function to our `handleSubmit`.
                  
                  ```js
                  import submit from './submit';
                  
                  /*... */
                  <form onSubmit={handleSubmit(submit)}>
                  ```
                  
                  [Docs: Submit](http://redux-form.com/6.0.2/examples/submitValidation/)
              </section>
              <section data-markdown>
                  # Submit Function
                  
                  The submit function can be used to update the state.
                  
                  ```js
                  import store from '../store';
                  
                  function submit(values) {
                    // save!
                    store.dispatch(saveForm(values));
                  }
                  export default submit;
                  ```
              </section>
              <section data-markdown>
                  # Validation Errors
                  
                  Validation errors can be handled with `SubmissionError`.
                  
                  ```js
                  import { SubmissionError } from 'redux-form';
                  
                  function submit(values) {
                     if (!values.length) {
                       throw new SubmissionError({
                         name: 'Name does not exist',
                         _error: 'Must include a name'
                       });
                     } else {
                       store.dispatch(saveForm(values));
                     }
                  }
                  export default submit;
                  ```
                  
                  [Docs: SubmissionError](http://redux-form.com/6.0.2/docs/api/SubmissionError.md/)
              </section>
              <section data-markdown>
                  # Displaying Errors
                  
                  `touched` & `error` are both props passed in by "redux-form".
                  
                  When does the following error get displayed?
                  
                  ```js
                  const renderField = ({ input, label, type, meta: { touched, error } }) => (
                    <div>
                      <label>{label}</label>
                      <div>
                        <input {...input} placeholder={label} type={type}/>
                        {touched && error && <span>{error}</span>}
                      </div>
                    </div>
                  )
                  ```
              </section>
              <section data-markdown>
                  # Disabled Button
                  
                  We know how to disable a button in HTML.
                  
                  ```html
                  <button type="submit" disabled={true}>Submit</button>
                  ```
                  
                  - How can we *disable* the submit button when the form is **invalid** or is **submitting**?
              </section>
              <section data-markdown>
                  # Using Meta Props
                  
                  We can use the "meta" props to specify our disable property.
                  
                  - invalid: true
                  - submitting: true
                  
                  ```html
                  <button
                    type="submit"
                    disabled={invalid || submitting}
                  >Submit</button>
                  ```
              </section>
              <section data-markdown>
                  # Performance Experiment
                  
                  - How often do you think your form component is re-rendered?
              </section>
              <section data-markdown>
                  # Performance Experiment
                  
                  Add the following code to the top of your form.
                  
                  ```js
                  render() {
                    console.log('rendered');
                  }
                  ```
                  - When is a form re-render triggered?
              </section>
              <section data-markdown>
                  # Material-UI
                  
                  We can use "material-ui" form components easily by using [redux-form-material-ui](http://erikras.github.io/redux-form-material-ui/).
                  
                  ```html
                   <Field
                    name="name"
                    component={TextField}
                    hintText="Name"
                    floatingLabelText="Name"
                  />
                  ```
                  
                  [Docs: MaterialUi](http://redux-form.com/6.0.2/examples/material-ui/)
              </section>
              <section data-markdown>
                  # Custom Components
                  
                  Material-UI components are created with a simple [wrapper component](https://github.com/erikras/redux-form-material-ui/blob/master/src/createComponent.js).
                  
                  Feel free to create your own wrapper for any other UI library.
              </section>
              <section data-markdown>
                  # Review
                  
                  1. Controlled vs. Uncontrolled components
                  2. React Form events
                  3. Redux Form
                  4. Form validation
                  5. Displaying errors
              </section>
              <section data-markdown>
                  ## Challenge
                  
                  Create a form in your Boomtown project. Include:
                    - saving data to the Redux store
                    - validation of fields
                    - styled components
                    - error feedback
                    - a disabled submit button when the form is invalid
              </section>
          </section>



          
            
                
              <section>
                  <section data-markdown>
                      # Client-Side Validation
                      
                      .title-logo[![Red logo](/public/img/red-logo-white.svg)]
                  </section>
                  <section data-markdown>
                      # Agenda
                      
                      1. UX Guest Speaker
                      1. Client vs Server Validation
                      1. Controlled vs Uncontrolled Components
                      1. Form Validation in Redux
                      1. Implement a form using the `Redux Form` library
                  </section>
                  <section data-markdown>
                      # Client vs Server Validation
                  </section>
                  <section data-markdown>
                      # Exercise 1
                      
                      Split into two groups.
                      
                      - Group 1: Research client-side validation
                      - Group 2: Research server-side validation
                      
                      You have 10 minutes, then we'll present.
                      
                      ???
                      
                      Essential differences:
                      
                      - Client-side validation is inherently insecure
                      - Client-side validation makes an app seem faster
                      - Server-side validation is absolutely required
                      - Client-side validation is for the user's convenience, but can also save a huge amount of resources. Ie. Picture 1,000,000 requests that are poorly formed. Client-side validation stops them from happening altogether.
                      - In short,eEvery app needs both client and server-side validation
                  </section>
                  <section data-markdown>
                      # Controlled vs Uncontrolled Components
                  </section>
                  <section data-markdown>
                      # Exercise 2
                      
                      Back into two groups.
                      
                      - Group 1: Research controlled components
                      - Group 1: Research uncontrolled components
                      
                      You have 10 minutes, then we'll present.
                      
                      ???
                      
                      Controlled components are controlled by React. That means we have programatic access to their values without having to interact with the DOM.
                      
                      Uncontrolled components rely on the DOM to store their state. This is inefficient in the long wrong, and contrary to React/Redux principles.
                  </section>
                  <section data-markdown>
                      # Form Validation in React/Redux
                  </section>
                  <section data-markdown>
                      # Discuss
                      
                      Where should form state exist in a React/Redux application?
                      
                      - Think of the pros and cons of local state vs Redux state
                      - Is invalid state still state?
                      
                      It might help to look up 'Ephemeral' state  
                      
                      ???
                      
                      Hopefully this will lead to them understanding:
                      
                      - Form state is ephemeral, which means that it isn't meaningful to the application until it is validated.
                      - We don't want to be updating redux with every key stroke. That will be very inefficient, as we'll be firing our pure reducer functions to make state that might not even be valid.
                  </section>
                  <section data-markdown>
                      # Exercise 3
                      
                      2 new groups!
                      
                      Draw how an application might handle client-side form validation.
                      
                      You have 15 minutes.
                      
                      ???
                      
                      This is an example of where will be good to use component-level state in React/Redux. The form component should own the state for all of its inputs, but we shouldn't pass any of it to Redux (and our servers) until we know that the form is completely valid.
                  </section>
                  <section data-markdown>
                      # Lab Activity
                      
                      Create the forms that you'll use in your Boomtown app, using the [Redux Form](http://redux-form.com) library.
                      You'll need to create both a user (login) form and a form for adding new Items.
                      
                      Be sure to include:
                        - saving data to the Redux store
                        - validation of fields
                        - styled components
                        - error feedback
                  </section>
          </section>


          <section>

              <section data-markdown>
                  # Introducing Meteor <br/>
                  (with React)
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. What is Meteor?
                  2. Application Platforms
                  3. The Client-Server model
                  4. Meteor Packages: Atmosphere vs. NPM
                  5. Meteor's Parts
                  6. Benefits of Meteor
                  7. Drawbacks of Meteor
              </section>
              <section data-markdown>
                  # What is Meteor?
              </section>
              <section data-markdown>
                  ### Meteor is an open source platform for web, mobile, and desktop.
                  
                  And it's JavaScript all the way down!
              </section>
              <section data-markdown>
                  # Application Platforms
                  
                  <img width="200px" style="display:block; margin:0 auto;" src="/public/img/slide-assets/swiss-army-knife.jpg" />
                  
                  An **Application Platform** is an *integrated set useful of programs*.
                  
                  Meteor comes with everything a JavaScript developer might need to build a fully functioning application, out of the box.
              </section>
              <section data-markdown>
                  Meteor simplifies and improves the *Developer Experience* of building Client-Server applications:
                  
                  - It's a complete and fully integrated suite of programs.
                  - It's simple and powerful set of JavaScript API's for working with those programs.
                  
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Split into two groups. Imagine you're planning an application platform for *other developers* to use. Your platform should be geared towards developers who want to create Web Apps and should include all the necessary components. Feel free to **invent or imagine technology or solutions that don't currently exist**
                  
                  When you've come up with a platform design, then come up with a marketing plan for your platform. When you have a marketing plan, you'll present it to the class. Your plan should highlight all of the reasons developers should choose your platform, over their own custom solution.
              </section>
              <section data-markdown>
                  # Client-Server Applications
              </section>
              <section data-markdown>
                  # What is Meteor?
                  
                  Under the hood, Meteor applications are typical Client-Server applications, like we're used to developing on the web.
                  
                  The Meteor platform includes:
                  
                  - Front-End tools for building a user interface: **Blaze/React/Angular**
                  - Back-End tools for developing your database and Server-Side logic: **Node / MongoDB**
              </section>
              <section data-markdown>
                  # Better than the REST?
                  
                  **So far in the course we've built a typical RESTful style Client-Server application.**
                  
                  This architecture has been in use for a long time. For experienced developers, the
                  shortcomings of this type of application have become obvious, here are a few:
                  
                  - HTTP is a slow and bloated transport protocol
                  - Client-Server applications don't share code!
                  - UI's built over RESTful applications will need loading states everywhere!
              </section>
              <section data-markdown>
                  Meteor was created to address these and many other shortcomings in typical Client-Server application architecture.
                  
                  <img style="display:block; margin: 0 auto;" src="/public/img/slide-assets/simply-the-best.jpg">
              </section>
              <section data-markdown>
                  # History of Meteor & MDG
              </section>
              <section data-markdown>
                  **Meteor was created by some of the top developers in Silicon Valley...**
                  
                  - [Meteor is Open Source!](https://github.com/meteor/meteor/commit/4e4358e2c068ffd0c0bc565bb2a9438c68bab7fb)
                  - Meteor was first introduced in 2011 under the name [Skybreak](https://blog.meteor.com/skybreak-is-now-meteor-e680d1dbaf84#.8iukm4iye).
                  - The startup **The Meteor Development Group** (MDG) was incubated by Y Combinator.
                  - In 2014, MDG acquired Y Combinator alum FathomDB.
                  - In 2012 MDG received 11 million in funding from the investment firm *Andreessen Horowitz*.
              </section>
              <section data-markdown>
                  <img style="display:block; margin: 0 auto;" src="/public/img/slide-assets/meteor-in-2011.jpg" />
                  Meteor in 2011
              </section>
              <section data-markdown>
                  <img style="display:block; margin: 0 auto;" src="/public/img/slide-assets/meteor-in-2017.png" />
                  Meteor in 2017
              </section>
              <section data-markdown>
                  # Meteor's Parts
                  What makes Meteor so Special?
              </section>
              <section data-markdown>
                  # Meteor's Parts
                  
                  Let's review the Awesome Meteor API Documentation and discuss the finer points of Meteor's API:
              </section>
              <section data-markdown>
                  ### [The Meteor Guide](https://guide.meteor.com/)
              </section>
              <section data-markdown>
                  ## Meteor, Atmosphere & NPM
                  
                  In 2011 NPM had not yet established itself as the de-facto package manager for Node applications.
                  
                  Because of Meteor unique architecture , and in order to preserve it's simple developer experience, while allowing
                  3rd party developers to contribute useful packages for use with Meteor, MDG built a proprietary packaging system.
                  
                  The community responded by building a package hub called:
                  ### [Atmosphere](https://atmospherejs.com/)
              </section>
              <section data-markdown>
                  ## Meteor, Atmosphere & NPM
                  
                  As Meteor grew in popularity, the benefits of this system were soon overshadowed, by the demand from the JavaScript
                  community at large, for NPM integration. Most JavaScript developers, especially those building software with Node,
                  use NPM.
                  
                  The result is that there are 2 ways of acquiring packages to use with your Meteor Project.
                  
                  - Meteor's packaging system is still very useful, and you'll use it to add and remove all of the **Standard Packages**
                  that come built into Meteor.
              </section>
              <section data-markdown>
                  # Deploying Meteor Apps
                  
                  Historically, Meteor has been difficult to deploy, because of it's unique architecture.
                  This is no longer the case. MDG has created [Galaxy](https://www.meteor.com/hosting). An all in one paid hosting
                  solution for Meteor apps.
                  
                  The Open Source community has also built deployment solutions. The 2 most popular are:
                  - [MUP](https://github.com/zodern/meteor-up) Built by Arounoda Surispala, a hero in the Meteor OS community.
                  - [meteor-now](https://www.npmjs.com/package/meteor-now) Built on the fantastic **[Now](https://zeit.co/now)** Node deployment tool.
                  Install Now and deploy your example app to see just how easy it is...
              </section>
              <section data-markdown>
                  # Meteor's Parts
                  
                  Based on our review of the API, let's attempt to answer the following questions:
                  
                  - How does Meteor address some of the shortcomings we mentioned earlier?
                  - What are some of the innovative or unusual aspects of Meteor's API?
                  - What are some of the important Deployment gotchas involved in running a production Meteor application?
                  - How will working with Meteor make our lives as Full-Stack JavaScript Developers more sane?
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Install Meteor and run `meteor create`.
                  
                  See if you can add the following features to the example project that is generated:
                  
                  - A button that decrements the counter
                  - A text input and button combination. When the user clicks the button, whatever text
                  is in the input appears on screen.
                  
                  Install the Meteor Dev Tools Chrome extension, and observe Meteor's DDP websocket
                  transport protocol in action! Open the mongoDB shell using the `meteor mongo` command
                  and take a peek at your new mongoDB database.
                  
              </section>
              <section data-markdown>
                  # Exercise 3
              </section>
              <section data-markdown>
                  ### Let's get technical
                  
                  Now that we know a little bit about What Meteor does, watch the following short Video on Fibers & Futures in Node, for some insight on how it does it:
                  
                  - [Evented Mind, Introducing Fibers in Node](https://www.eventedmind.com/items/nodejs-introducing-fibers).
                  - [Evented Mind, Using Futures](https://www.eventedmind.com/items/nodejs-using-futures).
              </section>
              <section data-markdown>
                  # Benefits of Meteor
              </section>
              <section data-markdown>
                  # Benefits of Meteor
                  
                  - No loading!
                  - Send less data!
                  - Reactive!
                  - So many sensible defaults!
                  - Fast TTL!
                  
                  ... Anything else?
              </section>
              <section data-markdown>
                  # Drawbacks of Meteor
              </section>
              <section data-markdown>
                  # Drawbacks of Meteor
                  
                  - Black box magical API's
                  - JS Ecosystem interop
                  - mongoDB by default
                  - Performance gotchas
                  - Deployment
                  - Doesn't work seamlessly with all JS
                  
                  ... Anything else?
              </section>
          </section>


          <section>
              <section data-markdown>
                  # Collections and Accounts
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Intro to MongoDB
                  2. Using Collections in Meteor
                  3. Adding user accounts to a Meteor app
              </section>
              <section data-markdown>
                  # Intro to MongoDB
              </section>
              <section data-markdown>
                  .large[
                  What do we know about MongoDB already?
                ]
              </section>
              <section data-markdown>
                  # About MongoDB
                  
                  - Stores data in rich documents (use arrays, **embedded documents**, etc.)
                  - Uses JSON to format the documents
                  - Schema-free by default
                  - Allows us to design data models to support common access patterns (compared to a relational design that may require joins across tables)
                  - Makes it way easier to shard data across servers (scale out instead of up!)
              </section>
              <section data-markdown>
                  .large[
                  ...versus SQL
                ]
              </section>
              <section data-markdown>
                  A loose comparison of SQL vs. MongoDB terminology:
                  
                  ```
                    SQL          |  MongoDB
                  -----------------------------------------
                    Database     |  Database
                  
                    Table        |  Collection
                  
                    Index        |  Index
                  
                    Row          |  Document
                  
                    Column       |  Field
                  
                    Primary Key  |  Primary Key (_id)
                  
                    Joining      |  Linking or Embedding
                  ```
              </section>
              <section data-markdown>
                  # NoSQL Schema Design
                  
                  MongoDB favours an **application-driven schema**.
                  
                  Compare this to relational schema design where you try to structure the data in a way that's agnostic to the application.
                  
                  So with a MongoDB you think about what pieces of data are **used together**, what pieces of data **are read-only**, what pieces of data need to be **written all the time** (and match the data access patterns of your application!)
              </section>
              <section data-markdown>
                  # Embedded Docs FTW
                  
                  - **Potential to improve read performance** if we design around access patterns
                  - We must **have a plan for keeping data consistent** even though MongoDB lacks foreign key constraints
                  - **Third Normal Form:** Says that every non-key attribute in the table must provide a fact about the key, the whole key, and nothing but the key (not as worried about this in MongoDB)
                  - Must consider if data have a **1:1**, **1:Many**, or **Many:Many** (or **1:Few** or **Few:Few**) relationship
                  
              </section>
              <section data-markdown>
                  # Other Differences
                  
                  - There are **no joins** (think of embedded data as "pre-joins")
                  - There are **no foreign key constraints**
                  - **Operations are atomic** at the level of the single document (so fields that should be updated together should be contained within a single document)
                  - Atomic operations also mean that when you work on a document that **work will be completed before anyone sees the updated document** (they see all the changes or none)
                  - There's **no declared schema** (**[but...](https://github.com/aldeed/meteor-simple-schema)**)
              </section>
              <section data-markdown>
                  # JSON and MongoDB
                  
                  Recall that these value types are supported by JSON (and MongoDB!):
                  
                  - object (nested documents!)
                  - array (with any combo of legal values)
                  - string
                  - number
                  - boolean
                  - null
              </section>
              <section data-markdown>
                  # BSON?
                  
                  Any valid JSON can be easily imported and queried in MongoDB. It also **[supports additional data types too](https://docs.mongodb.com/manual/reference/operator/query/type/#available-types)**, like a date field. 
                  
                  But ultimately, MongoDB stores data as **BSON** (binary JSON).
                  
                  BSON is **a binary serialization of JSON-like objects**. Documents are essentially JSON objects that MongoDB stores in binary.
                  
                  Luckily, MongoDB drivers take care of automatically converting and storing data in BSON for you.
              </section>
              <section data-markdown>
                  # Get Started
                  
                  To start-up the MongoDB server, enter this in your terminal:
                  
                  ```bash
                  mongod
                  ```
                  
                  **Open another terminal window** and type the following to launch the Mongo shell:
                  
                  ```bash
                  mongo
                  ```
                  
                  Try typing `help` in the Mongo shell to see what you can do now that you're in there...
              </section>
              <section data-markdown>
                  # Mongo Shell
                  
                  The Mongo shell is a fully functional Mongo client application, so all CRUD operations are supported here.
                  
                  In the shell, the `db` variable is global variable that refers to the database we are currently using. To use a database, type:
                  
                  ```
                  use <DB_NAME>
                  ```
                  
                  The database will now be accessible through the `db` variable.
                  
                  We can even `use` a database that doesn't exist yet, and MongoDB will lazily create it when we insert our first document in there.
              </section>
              <section data-markdown>
                  # Basic CRUD
                  
                  MongoDB allows us to perform all essential CRUD operations on a database:
                  
                  - Create (**insert** documents)
                  - Read (**query** documents)
                  - Update (**update** or **upsert** documents)
                  - Delete (**remove** documents)
              </section>
              <section data-markdown>
                  # Inserting Documents
                  
                  **Create a document:**
                  
                  ```bash
                  use adp
                  db.students.insertOne({name: "Bob", cohort: 6, passing: true});
                  ```
                  
                  We get a **return document** showing us our new document's ID.
                  
                  Every document is assigned a unique ID in a Mongo database in the `_id` field. We can manually set this ID if we want to (but no dupes allowed!).
              </section>
              <section data-markdown>
                  # Inserting Documents
                  
                  Add a couple more documents to your `students` collection that adhere to this field pattern now...
                  
                  Note that you can also use `insertMany()` and pass it an array of documents to insert multiple documents at once:
                  
                  ```bash
                  db.students.insertMany([
                    {name: "Anne", cohort: 6, passing: true},
                    {name: "Joe", cohort: 6, passing: false, teachers: ['Jill', 'Mary']},
                  ]);
                  ```
              </section>
              <section data-markdown>
                  # Querying Documents
                  
                  **Read a document:**
                  
                  Try running each of the following commands. What can you infer is happening with each?
                  
                  ```bash
                  db.students.find();
                  db.students.find().pretty();
                  db.students.findOne();
                  db.students.find({name: "Anne"});
                  db.students.find({cohort: 6, passing: true});
                  ```
                  
                  In MongoDB, the first argument passed to `.find()` is known as the **query document**, which specifies the shape of the documents we want to find. If we specify no constraints, the we get back all documents.
              </section>
              <section data-markdown>
                  # Sidebar: Cursors
                  
                  Note that what `.find()` returns isn't actually an array of documents, it's a **cursor**. The cursor is **what we use to extract results** from the database (because loading all results into memory right away wouldn't be efficient). 
                  
                  We **[call methods on our cursor](https://docs.mongodb.com/manual/reference/method/js-cursor/)** to actually extract results and do things with those results. Try one out:
                  
                  ```bash
                  db.students.find().forEach( (doc) => print( doc.name ) );
                  ```
                  
                  A cursor will typically retrieve a **batch of up to 101 results** for you to iterate through before retrieving another batch (or 20 results in the shell if not assigned to a variable).
                  
                  ???
                  
                  - Cursors are a control structure in a database for querying the results that we want, not the results thmeslves
              </section>
              <section data-markdown>
                  # Querying Documents
                  
                  **Comparison Operators:**
                  
                  `$eq`, `$gt`, `$gte`, `$lt`, `$lte`, `$ne`, `$in`, and `$nin`
                  
                  ```bash
                  db.students.find({ cohort: { $gte: 5 } });
                  
                  db.students.find({ cohort: { $in: [5, 6] } });
                  ```
                  
                  Note that `db.students.find({ cohort: { $eq: 6 } });` is the same as `db.students.find({ cohort: 6 });`.
                  
                  Also note the `$in` operator selects the documents where the value of a field equals any value in the specified array. 
              </section>
              <section data-markdown>
                  # Querying Documents
                  
                  **Logical Operators**
                  
                  `$and`, `$or`, `$not`, and `$nor`
                  
                  ```bash
                  # These do the same thing...
                  
                  db.students.find({ $and: [ { cohort: 6 }, { passing: true } ] });
                  db.students.find({ cohort: 6, passing: true }); # implicit $and
                  
                  # These also do the same thing...
                  
                  db.students.find({ $or: [ { name: "Bob" }, { name: "Anne" } ] });
                  db.students.find({ name: { $not: { $eq: "Joe" } } });
                  ```
              </section>
              <section data-markdown>
                  # Querying Documents
                  
                  **Finding Matching Elements in Arrays:**
                  
                  The `$elemMatch` operator matches documents that contain an array field with at least one element that matches all the specified query criteria:
                  
                  ```bash
                  db.students.find(
                     { teachers: { $elemMatch: { $eq: "Mary", $eq: "Jill" } } }
                  );
                  ```
              </section>
              <section data-markdown>
                  # Sidebar: Projections
                  
                  As a second argument to `.find()` we can pass another object known as a **projection**.
                  
                  ```bash
                  db.students.find({ cohort: 6, passing: true }, { _id: 0, name: 1 });
                  ```
                  
                  Projections allow us to only request the fields/data we need from a document over the wire&mdash;performance FTW.
                  
                  The `_id` field is **included by default**, and must be explicitly set to `0` to exclude it. All other fields must be implicitly included by setting them to `1`.
              </section>
              <section data-markdown>
                  # Sidebar: Skip, Limit, Sort
                  
                  MongoDB provides cursor methods for skipping, limiting, and sorting results:
                  
                  ```bash
                  var cursor = db.students.find();
                  
                  cursor.skip(3); # skip the first three results
                  cursor.limit(10); # then get the next 10 only
                  cursor.sort({ cohort: 1 }); # -1 for descending
                  ```
                  
                  We can also pass an array of sort criteria to `.sort()`.
                  
                  **Note:** It doesn't matter what order you call these methods on a cursor. Sort will always be applied first, skip will be applied second, and limit will be applied last.
              </section>
              <section data-markdown>
                  # Updating Documents
                  
                  **Update a document:**
                  
                  We can also `updateOne()` and `updateMany()` in MongoDB:
                  
                  ```bash
                  db.students.updateMany(
                    { name : "Bob" },
                    { $set: { passing : false } }
                  );
                  
                  db.students.updateOne(
                    { name : "Alice" },
                    { $set: { cohort: 6, passing: true } },
                    { upsert: true }
                  );
                  ```
                  
                  Update commands can also result in documents being created in the database. These commands are called **upserts**.
              </section>
              <section data-markdown>
                  # Deleting Documents
                  
                  **Delete a document:**
                  
                  Lastly, we have `deleteOne()` and `deleteMany()` to remove documents:
                  
                  ```bash
                  # Will delete the first document that matches
                  db.students.deleteOne({ _id : ObjectId("5892ce85ebd5c3837116cdec") });
                  
                  # Delete all the Joes!
                  db.students.deleteMany({ name : "Joe" });
                  ```
                  
                  You can use `db.students.drop()` to drop the entire collection. But use with caution!
              </section>
              <section data-markdown>
                  # Shell DB Cheatsheet
                  
                  A few helpful commands to use the Mongo shell:
                  
                  ```bash
                  show dbs           # show all databases
                  use <DB_NAME>      # assign database to db global
                  db                 # show me which db I'm using
                  show collections   # show all collections in db
                  db.dropDatabase(); # delete a database (make sure it's the right one!)
                  ```
                  
                  Quickly import a JSON file as a MongoDB:
                  
                  ```bash
                  # Use the --jsonArray flag if you are importing an array of objects
                  mongoimport --drop -d adp -c students students.json --jsonArray
                  ```
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Let's practice importing and querying data in MongoDB. Outside of the Mongo shell, import the **[sample data set](/public//exercises/people.json).**
                  
                  - How many people are humans from Tatooine?
                  - How many people appear in The Empire Strikes Back?
                  - How many people are taller than than 170cm?
                  - How many people fly some form of X-Wing?
                  - Return the names and masses of humans, ordered in descending order by known mass. Skip the first two results and limit your results to only four people.
              </section>
              <section data-markdown>
                  # Using Mongo Collections in Meteor
              </section>
              <section data-markdown>
                  # Mongo in Meteor
                  
                  MongoDB collections are Meteor's way to **persist data in the application**.
                  
                  The cool thing about Meteor though is that collections are available on both the client and the server.
              </section>
              <section data-markdown>
                  # Minimongo?
                  
                  While Meteor gives **the database everywhere**, on the client side of an app you actually interacting with a cache of the database.
                  
                  This is made possible by **Minimongo**, which is an in-memory, all JS implementation of the MongoDB API.
                  
                  The way we get data from the server is through Meteor's pub/sub system, and we write it back with Meteor methods (more on that tomorrow).
              </section>
              <section data-markdown>
                  # Create a Collection
                  
                  Create a new file `imports/api/todo.js` and add this code:
                  
                  ```js
                  import { Mongo } from 'meteor/mongo';
                  
                  export const ToDos = new Mongo.Collection('todos');
                  ```
                  
                  But this isn't doing much for us yet! Create another file `imports/start-up/server/index.js` and import it into `server/main.js` (the main server entry point for our app).
                  
                  Create another file in `imports/start-up/server/` called `register-api.js` and import your `todos.js` there.
                  
                  In `imports/start-up/server/index.js`, now import `register-api.js`. Done, phew!
              </section>
              <section data-markdown>
                  # Meteor Mongo Shell
                  
                  Meteor has it's own implementation of the Mongo shell. To enter it, run:
                  
                  ```bash
                  meteor mongo
                  ```
                  
                  Try adding a todo:
                  
                  ```bash
                  db.todos.insert({ id: 0, title: 'Learn React', complete: false });
                  ```
                  
                  Run `db.todos.find()`. What do you notice about the `id`?
                  
                  Let's remove our manually generated IDs everywhere now, and just use the ID Mongo generates for each to-do document.
              </section>
              <section data-markdown>
                  # Cleaning Up
                  
                  Once this is done, stop your Meteor server and run:
                  
                  ```bash
                  meteor reset # blows up your database!
                  ```
                  
                  Then add your to-do again in the `meteor mongo` shell:
                  
                  ```bash
                  meteor mongo
                  db.todos.insert({ title: 'Learn React', complete: false });
                  ```
                  
                  Run `db.todos.find()` to confirm everything is OK.
              </section>
              <section data-markdown>
                  # Meteor/React Set-up
                  
                  In order to use our `ToDos` collection data inside of a React component and take advantage of Meteor's reactivity, we need to install a couple new packages:
                  
                  ```bash
                  # magical reactive pixie dust for our components
                  meteor add react-meteor-data
                  
                  # dep of react-meteor-data
                  meteor npm install --save react-addons-pure-render-mixin 
                  ```
              </section>
              <section data-markdown>
                  # Using Collection Data
                  
                  Next, we need to import our `ToDos` collection into our `App` component, and wrap `App` in the `createContainer` HOC:
                  
                  ```js
                  import { ToDos } from '../../../api/todos';
                  
                  // ...other code
                  
                  export default createContainer(() => {
                    return {
                      todos: ToDos.find({}).fetch()
                    };
                  }, App);
                  ```
                  
                  Notice **[the method](https://docs.meteor.com/api/collections.html#Mongo-Cursor-fetch)** we are calling on our cursor.
              </section>
              <section data-markdown>
                  # CRUD, etc. in Meteor
                  
                  We don't have all of the same CRUD methods and cursor methods available in Meteor's implementation of Mongo. Let's compare and contrast:
                  
                  - [MongoDB CRUD Operations](https://docs.mongodb.com/manual/crud/)
                  - [Meteor Guide - Collections](https://docs.meteor.com/api/collections.html)
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Anywhere you are working with `todos` in your state object, change that to work with the `todos` in your `App` component `props`.
                  
                  Be sure to remove any remaining references to `id` in your `App` code (as we will use the document `_id` now instead).
                  
                  Don't forget to add some prop type validation as we are now passing collection data into our component as a prop.
                  
                  You may also want to set `defaultProps` for `todos` as an empty array so your app doesn't break when there's no todos in the database.
              </section>
              <section data-markdown>
                  # A Default To-Do
                  
                  Meteor can create a default to-do on start-up if none exist.
                  
                  Create `imports/server/fixtures.js` and import it into `imports/server/index.js`. Add this code to `fixtures.js`:
                  
                  ```js
                  import { Meteor } from 'meteor/meteor';
                  import { ToDos } from '../../api/todos';
                  
                  Meteor.startup(() => {
                    if ( ToDos.find().count() === 0 ) {
                      ToDos.insert({
                        title: 'Learn React', 
                        complete: false,
                      });
                    }
                  });
                  ```
                  
                  Kill your server, run `meteor reset` and see what happens.
              </section>
              <section data-markdown>
                  # CRUD Time!
                  
                  We need to convert our `addToDo`, `toggleComplete`, `removeToDo`, and `removeCompleted` methods to write data to MongoDB instead of simply updating the state of `App`.
                  
                  What Meteor collection CRUD methods will we need to call to take the appropriate write action in each of our existing methods?
              </section>
              <section data-markdown>
              # Inserting To-dos
              
              Our `insert` method will look like this:
              
              ```js
              ToDos.insert({		
                title: this.state.inputValue,		
                complete: false
              });
              ```
              
              Where do we put this code? What are we replacing?</section>
              <section data-markdown>
                  # Exercise 3
                  
                  Now refactor the `toggleComplete()`, `removeToDo()`, and `removeCompleted()` methods to contain the `update()` and `remove()` methods, however appropriate.
                  
                  The `removeCompleted()` method will be the trickiest...how will you check to see which to-dos are marked as complete now, and then remove those to-dos from the database based on their `_id`?
              </section>
              <section data-markdown>
                  # User Accounts in Meteor
              </section>
              <section data-markdown>
                  # For Free!
                  
                  Meteor offers packages to that give you a lot of account-related functionality in your app for free, including:
                  
                  - secure password authentication
                  - integration with third party login services
                  - a pre-built user interface.
                  
                  So most of the hard work of implementing user accounts will already be done for us!
              </section>
              <section data-markdown>
                  # Add Accounts
                  
                  To add user accounts to our app simply add these packages:
                  
                  ```bash
                  meteor add accounts-ui-unstyled accounts-password
                  ```
                  
                  **Note:** DDP provides us the `userId` field on a connection, which means that you always have access to `this.userId` inside methods and publications (even on the client). This will be helpful for us to know tomorrow.
              </section>
              <section data-markdown>
                  # Adding UI
                  
                  In `ui/components/AccountsWrapper/index.js` add:
                  
                  ```js
                  import React, { Component } from 'react';
                  import ReactDOM from 'react-dom';
                  import { Template } from 'meteor/templating';
                  import { Blaze } from 'meteor/blaze';
                   
                  export default class AccountsUIWrapper extends Component {
                    componentDidMount() {
                      // Use Meteor Blaze to render login buttons
                      this.view = Blaze.render(Template.loginButtons,
                        ReactDOM.findDOMNode(this.refs.container));
                    }
                    componentWillUnmount() {
                      Blaze.remove(this.view); // Clean up Blaze view
                    }
                    render() {
                      return <span ref="container" />; // Render a placeholder
                    }
                  }
                  ```
              </section>
              <section data-markdown>
                  # Exercise 4
                  
                  Import the `<AccountsUIWrapper />` component into `App.js`. 
                  
                  Add this component to the top of your `App` `render` method. Wrap it in a `<div>` with a class of `login-wrapper`. 
                  
                  Now wrap your existing to-do list `<div>` and your new accounts component in a new parent `<div>` will a class of `app-wrapper` (we'll need this for the CSS...).
                  
                  Now **[add this CSS](https://gist.github.com/mandiwise/29e4be3fbb737b883042ce7c92a87176)** to your `<AccountsUIWrapper />` component.
              </section>
              <section data-markdown>
                  # User To-Dos
                  
                  To access information about our current user, we'll need to pass some new props from our HOC to `App`:
                  
                  ```js
                  export default createContainer(() => {
                    return {
                      currentUser: Meteor.user(), // NEW!
                      currentUserId: Meteor.userId(), // NEW!
                      todos: ToDos.find({}).fetch() 
                    };
                  }, App);
                  ```
                  
                  Update your `propTypes` too!
              </section>
              <section data-markdown>
                  # Exercise 5
                  
                  Let's wrap all of the components in our to-do list that should only be visible to logged in users (i.e. the input, to-do list, the to-do count, and clear button) in a `<div>`. Leave the `<h1>` visible.
                  
                  When a user is not logged in, alternatively display the following:
                  
                  ```html
                  <div className="logged-out-message">
                    <p>Please sign in to see your todos.</p>
                  </div>
                  ```
              </section>
              <section data-markdown>
                  # Assigning to Users
                  
                  From now on when we add a new to-do, we'll want to assign it to a user:
                  
                  ```js
                  ToDos.insert({
                    title: this.state.inputValue,
                    complete: false,
                    owner: currentUserId, // NEW!
                  });
                  ```
                  
                  Now how can we use our new `currentUserId` prop to filter the to-dos so that the ones that display are only relevant to the logged in user?
              </section>
              <section data-markdown>
                  # Add a Default User
                  
                  ```js
                  // In fixtures.js...other imports above here
                  import { Accounts } from 'meteor/accounts-base';
                  
                  Meteor.startup(() => {
                    let user = {};
                  
                    if ( Meteor.users.find().count() === 0 ) {
                      user = Accounts.createUser({
                        email : 'm@wise.com',
                        password : 'password',
                      });
                    }
                  
                    if ( ToDos.find().count() === 0 ) {
                      ToDos.insert({
                        title: 'Learn React', 
                        complete: false,
                        owner: user,
                      });
                    }
                  });
                  ```
              </section>
              <section data-markdown>
                  # Wrapping Up...
                  
                  Do another `meteor reset` and re-start Meteor to confirm that your new start-up code works.
                  
                  Try logging, add new to-dos, log out, and create new user. Is everything working as expected?
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - What MongoDB is and how it differs from SQL databases
                  - How to add a collection to a meteor app and add documents to it
                  - How to easily add user accounts to a Meteor app
              </section>
          </section>


          <section>
              <section data-markdown>
                  # Pub-Sub and Security in Meteor
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Create Meteor Methods & DDP
                  2. Set up Pub/Sub
              </section>
              <section data-markdown>
                  # Meteor Methods
              </section>
              <section data-markdown>
                  .large[
                  Think of Meteor Methods as an **API for your server**.
                ]
                
                ???
                
                - Methods are Meteor’s remote procedure call (RPC) system, used to save user input events and data that come from the client
                - You can think of them like POST requests to your server, but with many nice features optimized for building a modern web application
                - At its core, a Method is an API endpoint for your server
                - Methods is usually capitalized to distinguish from JS methods
              </section>
              <section data-markdown>
                  # Typical Client/Server Relationship
                  
                  - Server implements a REST API in language X
                  - Someone has to write a library for accessing that API in the client's language
                  - The client uses the library to interact with the server
              </section>
              <section data-markdown>
                  # Meteor Client/Server Relationship
                  
                  - Methods are written on the server
                  - Client uses the Meteor interface to call the Method
              </section>
              <section data-markdown>
                  # DDP
                  
                  - Stands for **D**istributed **D**ata **P**rotocol
                  - **Server:** define a realtime queries using `Meteor.publish`
                  - **Client:** you call `Meteor.subscribe` to connect to a publication endpoint
                  - DDP then intelligently polls your database to pick up changes and push them down to the client
                  
                  ???
                  
                  - DDP is a standard way to solve the biggest problem facing client-side JavaScript developers: querying a server-side database, sending the results down to the client, and then pushing changes to the client whenever anything changes in the database
                  - Uses websockets
                  - DDP messages are JSON objects
              </section>
              <section data-markdown>
                  .inline-images[
                  ![Meteor pub/sub diagram](/public/img/slide-assets/meteor-pub-sub.png)
                ]
                
                .footnote.right[
                  Source: [GeekyAnts](https://blog.geekyants.com/meteor-react-native-simplicity-productivity-a62559a1a570)
                ]
              </section>
              <section data-markdown>
                  .large[
                  Our app is insecure right now. Why?
                ]
              </section>
              <section data-markdown>
                  # Getting Started
                  
                  The first step toward securing our app is to remove the default `insecure` package from the Meteor app:
                  
                  ```bash
                  meteor remove insecure
                  ```
                  
                  Congrats! You have now revoked the client-side permissions from your app, and will no longer be able to update your to-dos, or add new ones...let's fix that.
              </section>
              <section data-markdown>
                  # Where to Put Methods
                  
                  In our `imports/api/todos.js` we'll make a call to `Meteor.methods()`. Add a Method for `toggleComplete`:
                  
                  ```js
                  // in todos.js...
                  
                  Meteor.methods({
                    'todos.toggleComplete' (todo) {
                      if (todo.owner !== this.userId) {
                        throw new Meteor.Error('todos.toggleComplete.not-authorized',
                          'You are not allowed to update to-dos for other users.');
                      }
                  
                      ToDos.update(todo._id, {
                        $set: { complete: !todo.complete },
                      });
                    },
                  });
                  ```
              </section>
              <section data-markdown>
                  # Use the Method
                  
                  To use the new toggling Method, we'll use `Meteor.call()` in our component:
                  
                  ```js
                  // in App.js...
                  
                  toggleComplete(todo) {
                    // REMOVE THIS!
                    // ToDos.update(todo._id, {
                    //   $set: { complete: !todo.complete },		
                    // });
                  
                    Meteor.call('todos.toggleComplete', todo); // NEW!
                  }
                  ```
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Your turn! Add Meteor Methods for `addToDo`, `removeToDo`, and `removeCompleted` now.
                  
                  Call these new Methods in your `App` component where appropriate. When you're done, all of your `App` component's methods should work again as they did before.
              </section>
              <section data-markdown>
                  # Publications and Subscriptions in Meteor
              </section>
              <section data-markdown>
                  .large[
                  &ldquo;Database everywhere&rdquo; probably isn't a hot idea in a production app either...
                ]
              </section>
              <section data-markdown>
                  # Data on the Client
                  
                  We will want to a little more explicit about what data the server sends to the client in our app. To begin, start by removing this default Meteor package:
                  
                  ```bash
                  meteor remove autopublish
                  ```
                  
                  Congrats again! You can no longer view your to-dos, even when logged into your account. Let's also fix this...
              </section>
              <section data-markdown>
                  # Simple Fix: Part 1
                  
                  On the server side, we'll need to create a publication for our to-dos in `imports/api/todos.js`
                  
                  ```js
                  // in todos.js again...
                  
                  if (Meteor.isServer) {
                    Meteor.publish('todos', function todosPublication() {
                      return ToDos.find({ owner: this.userId });
                    });
                  }
                  ```
              </section>
              <section data-markdown>
                  # Simple Fix: Part 2
                  
                  One last step...we must subscribe to our publication within our the HOC wrapping the `App` component:
                  
                  ```js
                  export default createContainer(() => {
                    Meteor.subscribe('todos'); // NEW!
                  
                    return {
                      currentUser: Meteor.user(),
                      currentUserId: Meteor.userId(),
                      todos: ToDos.find({}).fetch()
                    };
                  }, App);
                  ```
                  
                  **Note:** We can now remove the call to `filter()` in our `App` component's render method as the server will only provide us with the to-do documents for the currently logged-in user now.
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - How Methods allow us to securely create endpoints on our server to complete various actions in our app
                  - How to use publications and subscriptions in Meteor to selectively choose what data is made available to the the client, and then import that data into a React component as props
              </section>
          </section>


          <section>
              <section data-markdown>
                  
                              # Intro to TDD
                  
                              .title-logo[![Red logo](/public/img/red-logo-white.svg)]
                            </section>
                            <section data-markdown>
                                # Agenda
                                
                                1. Coding interviews
                                2. Code completion
                                3. Intro to TDD
                                4. Write failing tests
                                5. Red Green Refactor
                            </section>
                            <section data-markdown>
                                # Coding Interviews
                            </section>
                            <section data-markdown>
                                ### Coding Interviews
                                
                                **Fun Fact**: The code you'll actually be writing on the job is not at all like the code you'll be asked to write for an interview.
                            </section>
                            <section data-markdown>
                                # Coding Interviews
                                
                                - Often computer science-heavy (less so for juniors)
                                - Focus on devil-in-the-details problems
                                - Are as much about **how you write code** as they are about **what code you write**
                            </section>
                            <section data-markdown>
                                # Format
                                
                                - First interview: usually with HR or Recruitment for **fit**
                                - **Take-home programming task**, due within 1-3 days
                                - Second interview, **whiteboarding/live coding**
                                - Depending on the company, they might have more live coding interviews
                                - Meeting with CEO or CTO for **final decision**
                            </section>
                            <section data-markdown>
                                .large[
                                This week, we're going to focus on tools to help you with the take-home and in-interview coding challenges.
                              ]
                            </section>
                            <section data-markdown>
                                # Test Driven Development
                            </section>
                            <section data-markdown>
                                .large[
                                How do you know when your code is **done**?
                              ]
                              
                              ???
                              
                              The discussing here should be around getting some way of 'testing' whether code is done.
                              
                              - Are you logging to the console?
                              - Are you rendering UI and checking it?
                              - Are either of the above efficient? Can they be automated?
                            </section>
                            <section data-markdown>
                                .large[
                                How do you know if code that you've changed **works**?
                              ]
                              
                              ???
                              
                              When you refactor existing code, how do you know it works?
                            </section>
                            <section data-markdown>
                                .inline-images[
                                ![Feedback loop](/public/img/slide-assets/feedback-loop-green.png)
                              ]
                              
                              .large[
                                **Feedback!**
                              ]
                              
                              ???
                              
                              Basically what we're talking about is the feedback loop.
                              
                              - You write or change code
                              - You run the code in whatever environment you've built
                              - You get feedback as to whether or not it works
                            </section>
                            <section data-markdown>
                                .large[
                                So how do we make that feedback loop smaller?
                              ]
                              
                              ???
                              
                              We're going to learn how to run **unit tests**, which mean that we are only executing the code that we're writing, and nothing else. This makes the feedback loop tiny, we can run hundreds of tests in a couple seconds.
                              
                              Let's start with an exercise...
                            </section>
                            <section data-markdown>
                                # Example Question
                                
                                *This is an example coding test question...*
                                
                                A frog wants to get to the other side of the road. The frog is currently located at position `start` and wants to get to a position greater than or equal to `end`. The frog always jumps a fixed distance, `jumpLength`.
                                
                                Write a function to count the minimal number of jumps that the frog must perform to reach its target.
                            </section>
                            <section data-markdown>
                                # Exercise 1
                                
                                In groups:
                                
                                - Use the whiteboard to draw out some examples of the jumping frog algorithm
                                - Write out a specification for the `frogJumps` function **in plain English**. Use the format:
                                
                                ```
                                [Function name]
                                
                                When [given some input(s)] it should [return something].
                                When [given some other input(s)] it should [return something else].
                                ...etc
                                ```
                            </section>
                            <section data-markdown>
                                # Testing Playground
                                
                                Build a testing playground:
                                
                                ```bash
                                mkdir tdd-playground
                                cd tdd-playground
                                
                                mkdir lib
                                mkdir __tests__
                                
                                npm init -y
                                npm i --save-dev jest-cli
                                ```
                                
                                Then, [install the RED Academy ESlint](https://www.npmjs.com/package/eslint-config-redacademy).
                            </section>
                            <section data-markdown>
                                # Our First Unit Test
                                
                                We've talked about how `frogJumps` works.
                                
                                Let's use TDD to write it! 
                                
                                Step 1 is to write a test. Here's an example:
                                
                                ```js
                                // __tests__/frog-jumps.spec.js
                                const frogJumps = require('../lib/frog-jumps.js');
                                
                                describe('frogJumps', () => {
                                
                                  describe('when start is equal to end', () => {
                                    it('should return 0', () => {
                                      const result = frogJumps(10, 10, 5);
                                      expect(result).toEqual(0);
                                    });
                                  });
                                
                                });
                                ```
                                
                                ???
                                
                                This might look like a lot of syntax right off the bat, but you'll get used to the pattern.
                            </section>
                            <section data-markdown>
                                # Anatomy of a Test
                                
                                We're using **[Jest](https://facebook.github.io/jest/)** to write tests. Read the docs!
                                
                                To make our tests match our Plain English specs, we use nested `describe` blocks. The `describe` takes a callback function as its second argument, allowing us to group tests with a similar context.
                                
                                ```js
                                describe('Outer context', () => {
                                  // Code/Tests specific to outer context
                                
                                  describe('Middle context', () => {
                                    // Code/Tests specific to middle context
                                
                                    describe('Inner context', () => {
                                      // Code/Tests specific to inner context
                                    });
                                  });
                                });
                                ```
                            </section>
                            <section data-markdown>
                                # Anatomy of a Test
                                
                                Nesting callbacks is generally considered bad practice outside of writing tests, so you'll need to get used to the difference.
                                
                                If your code is indented properly, you will see a series of closing parens/braces in a 45 degree angle at the end of a file.
                                
                                 ```js
                                    // Good
                                    });
                                  });
                                });
                                
                                    // Probably a bug
                                    });
                                });
                                ```
                            </section>
                            <section data-markdown>
                                # Anatomy of a Test
                                
                                When we pass strings to `describe` (other than the outermost `describe`) we use the format `when [some context]`:
                                
                                ```js
                                describe('functionName', () => {
                                  describe('when passed a certain type of argument', () => {
                                    // Test here
                                  });
                                });
                                ```
                            </section>
                            <section data-markdown>
                                # Anatomy of a Test
                                
                                We write our actual tests (aka **assertions**) using `it` blocks. It blocks are given a string of the format `should [return something]`.
                                
                                Within an `it`, we use the `expect` function with various **matchers**:
                                
                                ```js
                                it('should return true', () => {
                                  // 'toBe' matcher
                                  expect(result).toBe(true);
                                });
                                
                                it('should return 100', () => {
                                  // 'toEqual' matcher
                                  expect(result).toEqual(100);
                                });
                                ```
                            </section>
                            <section data-markdown>
                                # Anatomy of a Test
                                
                                Bringing it together:
                                
                                ```js
                                // __tests__/frog-jumps.spec.js
                                const frogJumps = require('../lib/frog-jumps.js');
                                
                                // Outer describe
                                describe('frogJumps', () => {
                                
                                  // Inner describe 'context'
                                  describe('when start is equal to end', () => {
                                
                                    // Test
                                    it('should return 0', () => {
                                
                                      // Assertion
                                      expect(frogJumps(10, 10, 5)).toEqual(0);
                                    });
                                  });
                                
                                });
                                ```
                            </section>
                            <section data-markdown>
                                # Running Your Test
                                
                                The test on the previous slide uses the **[Jest](https://facebook.github.io/jest/)** testing library.
                                
                                Jest has a command line tool, but in order to execute it in the proper environment we need to execute it as a node script.
                                
                                In your `package.json`:
                                
                                ```js
                                {
                                  ...
                                  "scripts": {
                                    "test": "jest --verbose"
                                  }
                                }
                                
                                ```
                            </section>
                            <section data-markdown>
                                # Code Along
                                
                                Run your test:
                                
                                ```bash
                                npm run test
                                
                                # or
                                npm test
                                
                                # or even
                                npm t
                                ```
                                
                                *The test will fail, obviously!*
                            </section>
                            <section data-markdown>
                  
                              .large[
                              <strong><span style="color: red">FAIL</span> -> <span style="color: green">PASS</span></strong>
                              ]
                  
                              ???
                  
                              What we need to do now is write the minimal amount of code in order to get the test to pass.
                  
                              - Start by running the test. It will fail because the file doesn't exist
                              - Add the file, run the test again, it will fail because the function is undefined
                              - Add a function with the correct name, but no body, it will fail because the return value is undefined
                              - Write minimal code to get the scenario to pass, then run the test
                            </section>
                            <section data-markdown>
                                # Add Another Test
                                
                                ```js
                                describe('when destination is exactly one jump away', () => {
                                  it('should return 1', () => {
                                    expect(frogJumps(5, 15, 10)).toEqual(1);
                                  });
                                });
                                ```
                                
                                Run your tests, and fix the errors.
                                
                                ???
                                
                                - Make sure the students follow TDD step by step: only do things that error messages tell you to do
                                - You can take shortcuts once you're better at this
                                - Once all the tests pass, you KNOW your code is done
                            </section>
                            <section data-markdown>
                                ### Red, Green, Refactor
                                
                                .inline-images[
                                  ![Red Green Refactor](/public/img/slide-assets/red-green-refactor.png)
                                ]
                                
                                ???
                                
                                The process we've been going through is called red-green-refactor
                                
                                - We write a failing test (RED)
                                - We write MINIMAL code to make it pass (GREEN)
                                - We refactor the code to make it better, and run our tests to make sure it still works
                            </section>
                            <section data-markdown>
                                # Exercise 2
                                
                                Implement unit tests for each of the specifications you wrote for `frogJumps`.
                                
                                Think about the **Edge Cases**
                                
                                - Zero Arguments
                                - Perfect match
                                - Maximum Match
                                - No Match
                                
                                ???
                                
                                - Give them maybe 30 minutes of supported work
                                - They will struggle with the syntax, so make sure you help out a lot
                                - Encourage them to run tests after every change
                                
                                Solution in [adp-exercise-solutions](https://github.com/redacademy/adp-exercise-solutions/blob/master/adp-testing-week/lib/frog-jump.js).
                            </section>
                            <section data-markdown>
                                # Exercise 3
                                
                                A palindrome is a string that is the same when written forwards and backwards.
                                **Mom**, **racecar**, and **never odd or even** are all palindromes.
                                
                                Write a function that takes a string and returns whether it is a palindrome. Take these steps to do so:
                                
                                - Whiteboard the algorithm
                                - Write out plain English specs
                                - Convert specs to tests
                                - Implement your algorithm
                                
                                ???
                                
                                - Get them to work on this by themselves
                                - Get them to each read out a test scenario
                                
                                Once they start working, start hinting at complexity of algorithms.
                                
                                This is something that can be solved in `n/2` operations, but you can also use JS library functions to do it for you, at about `3n`.
                                
                                Naive and efficient solutions in [adp-exercise-solutions](https://github.com/redacademy/adp-exercise-solutions/blob/master/adp-testing-week/lib/palindrome.js)
                            </section>
                            <section data-markdown>
                                # What We've Learned
                                
                                - How a typical coding interview goes
                                - What code completion is
                                - What TDD is
                                - How to write tests with Jest
                                
                            </section>
          </section>


          <section>
              <section data-markdown>
                  # More on TDD
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Review of yesterday's lab
                  2. More TDD practice
                  3. Time complexity
                  4. Big O
                  5. Using data structures to increase performance
                  6. EVENT MORE TDD PRACTICE!
              </section>
              <section data-markdown>
                  # Review: <br />String Compression Lab
              </section>
              <section data-markdown>
                  # More TDD Practice
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Using TDD, write a function that **returns the first unique character** in a string.
                  
                  Examples:
                  
                  - `'dddeeefggghhh'` => `'f'`
                  - `'terfg'` => `'t'`
                  - `'frof'` => `'r'`
                  - `'ttttt'` => `undefined'`
                  
                  ???
                  
                  The most obvious way to solve this problem is by using a nested loop. For each character (c) in the string, check every other character in the string to see if c is unique.
                  
                  This has a big O if n^2. [The solution is here.](https://github.com/redacademy/adp-exercise-solutions/blob/master/adp-testing-week/lib/first-unique.js)
              </section>
              <section data-markdown>
                  # Time Complexity & Big O Notation
              </section>
              <section data-markdown>
                  .large[
                  How long did your algorithm take to execute?
                ]
                
                ???
                
                - They won't know what this means!
                - Might be helpful to write out the function's output by hand, or in the console, so we can count iterations
                - [Example](https://github.com/redacademy/adp-exercise-solutions/blob/master/adp-testing-week/lib/first-unique.js)
                - We should be able to show n^2 iterations for a nested loop
              </section>
              <section data-markdown>
                  # Time Complexity
                  
                  Counts the (worst case) number of operations:
                  
                  ```js
                  const numbers = [1, 2, 3, 4, 5, 6, 7];
                  numbers.length; // 7
                  
                  // 1 operation
                  return numbers[0];
                  
                  // n (7) operations
                  numbers.forEach(number => {
                    console.log(number);
                  });
                  
                  //  n^2 (49) operations
                  numbers.forEach(number => {
                    console.log(`outer: ${number}`);
                  
                    numbers.forEach(number => {
                      console.log(`inner: ${number}`);
                    });
                  });
                  ```
                  
                  ???
                  
                  - Differentiate between **worst case** and **average case** scenarios
                  - Worst case: everything goes wrong so every iteration has to occur
                  - Average case: most of the time a medium amount of operations occurs
                  - Best case: nailed it.
              </section>
              <section data-markdown>
                  # Time Complexity
                  
                  Grouped by orders of magnitude, defined using **Big O Notation**:
                  
                  - Constant `O(1)`
                  - N Operations `O(n)`
                  - N*N Operations `O(n^2)`
                  - N^N Operations `O(n^n)`
                  - N! Operations `O(n!)`
                  
                  We read O(1) as "has an O of 1", O(n) as "has an O of n", etc.
                  
                  ???
                  
                  - Use the whiteboard to show how orders of magnitude differ as iterations approach infinity.
                  - [Figure 2 in lesson pre-work](https://justin.abrah.ms/computer-science/big-o-notation-explained.html)
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Figure out the time complexity of your solution to Exercise 1.
                  
                  ???
                  
                  - It will be n^2 because of the nested loop
              </section>
              <section data-markdown>
                  # Strategies for Handling Time Complexity
              </section>
              <section data-markdown>
                  # Using Data Structures for Counting
                  
                  
                  What if the first thing you do when iterating over an array is to 'count' the elements within it? 
                  
                  How could this apply to the **First Unique Character** problem?
                  
                  ???
                  
                  - What would be useful to count for solving this problem? (number of instances of any character)
                  - How might we do that?
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Refactor your Exercise 1 solution for O(n).
                  
                  ???
                  
                  - [The solution is available here](https://github.com/redacademy/adp-exercise-solutions/blob/master/adp-testing-week/lib/first-unique.js)
              </section>
              <section data-markdown>
                  # Exercise 4
                  
                  Write a function that, given an array of `n` integers, returns the minimal positive integer (greater than 0) that does not occur in the array.
                  
                  For example, given:
                  
                  ```
                  [1, 3, 6, 4, 1, 2]
                  ```
                  
                  The function should return `5`.
                  
                  ???
                  
                  - Start with the **Brute Force** method. 
                  - [The solution is available here](https://github.com/redacademy/adp-exercise-solutions/blob/master/adp-testing-week/lib/missing-integer.js).
              </section>
              <section data-markdown>
                  # Code Along: Missing Integer
                  
                  **Using data structures for counting:**
                  
                  - Iterate over array, counting the occurence of each integer
                  - Store the count in an array
                  - The index of the array element is the number being counted
                  
                  *What's our new time complexity?*
                  
                  ???
                  
                  - [The solution is available here](https://github.com/redacademy/adp-exercise-solutions/blob/master/adp-testing-week/lib/missing-integer.js).
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - What time complexity is
                  - How to use Big O Notation
                  - How to use data structure to improve performance
              </section>
          </section>


          <section>
              <section data-markdown>
                  # Units with Dependencies
                  .large[How do we test doMath()?]
              </section>
              <section data-markdown>
                  # Mocks, Stubs, and Fakes
              </section>
              <section data-markdown>
                  ## Managing Dependencies
                  
                  Let's start by writing an impure unit test for doMath.
                  
                  ```js
                  // __tests__/do-math.spec.js
                  const doMath = require('../lib/do-math');
                  
                  describe('doMath', () => {
                    describe('when I pass in 1, 2, 3', () => {
                      it('should return 6', () => {
                        const result = doMath(1, 2, 3);
                        expect(result).toEqual(6);
                      });
                    });
                  });
                  
                  
                  ```
                  
                  This currently tests `doMath`, `sum`, `min`, and `max`.
                  
              </section>
              <section data-markdown>
                  ## Managing Dependencies
                  
                  Jest makes is easy to mock dependencies.
                  
                  ```js
                  jest.mock('../lib/maths', () => ({
                    sum: () => 10,
                    min: () => 2,
                    max: () => 7
                  }));
                  ```
              </section>
              <section data-markdown>
                  ## Managing Dependencies
                  
                  When you mock the dependencies, the test becomes much clearer:
                  
                  ```js
                  const doMath = (a, b, c) => {
                    return sum(a, b, c) - min(c, b) + max(a, b);
                  };
                  ```
                  
                  Becomes:
                  
                  ```js
                  const doMath = (a, b, c) => {
                    return 10 - 2 + 7; // 15
                  };
                  ```
              </section>
              <section data-markdown>
                  ## Testing what is passed to dependencies
                  
                  Often you need to test whether parameters are being properly created and passed to dependencies.
                  Jest can do this.
                  
                  ```js
                  // Update your mocks to use 'spies'
                  jest.mock('../lib/maths', () => ({
                    sum: jest.fn(() => 10)),
                    min: jest.fn(() => 2)),
                    max: jest.fn(() => 7))
                  }));
                  
                  // Get access to the mocks
                  const maths = require('../lib/maths');
                  
                  // Test them!
                  it('should pass correct params to sum', () => {
                    doMath(1, 2, 3);
                    expect(maths.sum).toHaveBeenCalledWith(1, 2, 3);
                  });
                  ```
              </section>
              <section data-markdown>
                  ## Exercise
                  
                  Test what is passed to the `min` and `max` dependencies.
              </section>
              <section data-markdown>
                  ## Lab Activity: Rojo
                  
                  You're going to write version 0.0.1 of __Rojo__, the RED Academy personal assistant.
                  You can ask Rojo any question, and it will give you an appropriate response.
                  Example:
                  
                  ```
                  You: What time can I start drinking beer on Friday?
                  Rojo: 4:30pm, amigo!
                  ```
                  
                  Writing Rojo is a perfect use-case for TDD. You can define question/response pairs in your tests.
                  
                  It will help to keep your code modular.
                  __Rojo__ itself will likely have dependencies on other modules that you will write.
                  Use what you learned about mocking dependencies to make it work!
              </section>
          </section>



          <section>
              <section data-markdown>
                  # Behaviour Driven Development
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. TDD versus BDD
                  2. Stakeholders
                  3. Stories
                  4. Outside-in
                  5. Interface discovery
                  6. Practice!
              </section>
              <section data-markdown>
                  # TDD versus BDD
              </section>
              <section data-markdown>
                  .large[
                  Step. Away. From. Computer.
                ]
                
                ???
                
                - BDD allows us to think about our functionality in terms of how it affects our users. 
                - It is a plain-text formalized method for describing how we expect our code to work.
              </section>
              <section data-markdown>
                  .large[
                  In order for software to be meaningful, its features have to provide benefit to its stakeholders.
                ]
              </section>
              <section data-markdown>
                  # Stakeholders
              </section>
              <section data-markdown>
                  .large[
                  Believe it or not, programmers don't call all the shots
                ]
                
                ???
                
                - CEOs, product managers, CTOs, designers, sales, marketing, etc. all have their needs, too!
                
                ---
                
                # BDD
                
                A way of writing human-readable tests in the form of **stories**.
                
                BDD stories have a recognizable structure:
                
                - Title
                - Narrative
                - Scenarios
              </section>
              <section data-markdown>
                  # BDD
                  
                  **Title:**
                  
                  ```bash
                  A [stakeholder] performs some action.
                  ```
                  
                  **Narrative:**
                  
                  ```bash
                  As a [stakeholder] I want [feature] so that [benefit].
                  In order to [benefit], a [stakeholder] wants [feature].
                  ```
                  
                  **Scenario:**
                  ```sh
                  Given [some environment]
                  When [something happens]
                  And [optionally something else happens]
                  Then [expected result]
                  And [optionally more things are expected]
                  ```
              </section>
              <section data-markdown>
                  .large[
                  Iteration *before* coding.
                ]
                
                ???
                
                Let's practice with an example. Remember than we want to be able to understand our functionality before we start implementing.
                
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  You've just been hired on as a big data consultant for a coding school called Rouge Academie. Management wants to understand more about their students!
                  
                  Here's their **[data set](/public/exercises/bdd-dummy-data.json)**. Write 2 stories (each with at least 2 scenarios) about how you can provide them with insight.
                  
                  For your reference:
                  
                  .condensed[
                  - [What's in a Story?](https://dannorth.net/whats-in-a-story/)
                  - [A practical blog on how to write Scenarios using BDD](https://elabor8.com.au/a-practical-blog-on-how-to-write-scenarios-using-bdd/)
                  ]
                  
                  ???
                  
                  - Get the students to look at each property of each student's data object
                  - What might we want to know the average of? (Age, Experience)
                  - Would we want to know the percentage passing each project?
                  - How about the satisfaction of those who pass vs the satisfaction of those who fail?
                  - We could also look at years experience vs. pass percentage to see if there's a correlation
                  - **Note:** The solutions are in the `adp-exercise-solutions` repo in the `bdd-student-data` directory. Solutions were written to process average age, average experience, the pass/fail percentage for each project, the satisfaction of those who passed, and the satisfaction of those who failed. Fill your boots!
              </section>
              <section data-markdown>
                  # What Now?
                  
                  Now that we have our human-readable acceptance criteria, we can start using TDD.
                  Set up environment:
                  
                  ```sh
                  mkdir student-stats
                  cd student-stats
                  
                  mkdir src
                  touch src/student-stats.js
                  
                  mkdir __tests__
                  touch __tests__/student-stats.spec.js
                  
                  npm init -y
                  npm i --save-dev jest-cli
                  ```
                  
                  ```js
                  // package.json
                  "scripts": {
                    "test": "jest --verbose"
                  }
                  ```
              </section>
              <section data-markdown>
                  # Outside-in Testing
                  
                  ???
                  
                  - What is the difference between outside-in and inside-out approaches?
                  - Inside out gets us to start with the smallest possible functions and build outwards
                  - Outside in gets us to mock dependencies as we work our way in
              </section>
              <section data-markdown>
                  # Code Along: Outside-in
                  
                  This is where TDD gets interesting. We're going to convert our BDD scenarios into unit tests, then write the _minimal possible code_ to make them pass.
                  
                  Our process will be:
                  
                  - Start with unit tests
                  - Mock all dependencies
                  - Make the tests pass
                  
                  ???
                  
                  - Outside-in allows us to start coding from the perspective of the user - in this case, our tests best represent the user
                  - We start with the functions that user events might trigger
                  
                  For the code along:
                  
                  - See the `student-stats.spec.js` file for guidance
                  - The key here is that we're ONLY building the interface, and mocking the actual data processing to start
                  - Talk about the interface. Should we make a class, a function?
                  - Let's make a class called StudentStats. What's the interface? `.get`? `.process`?
                  - What about `getAverageAge`? or `getAverageSatisfaction`?
                  - Make sure to iterate on the interface while writing the tests.
                  
                  NOTE: The solution passes in a data object, mocks the `processData` function, and exposes the `queryCohort`, `queryExperience` and `queryProject` methods.
              </section>
              <section data-markdown>
                  # Interface Discovery
                  
                  ???
                  
                  - What is an interface?
                  - An interface is what we're given to interact with another class, object, function, etc.
                  - A good metaphor is the pedals and wheel of a car. Through that interface we're able to control the complex machinery of the car.
              </section>
              <section data-markdown>
                  # Interface Discovery
                  
                  When we start our implementation by writing tests, we get to iterate on its **interface** before having to care about its **implementation**.
                  
                  This is considerably more flexible than iterating on an interface while writing the actual code.
              </section>
              <section data-markdown>
                  ### Now, let's implement!
                  
                  The trick is to write the smallest amount of code possible to allow the tests to pass.
                  
                  ???
                  
                  Start by building an object of what you'd expect the processed data to look like. It'll probably be something like:
                  
                  ```js
                  const processedData = {
                    demographics: {
                      averageAge: 32,
                      averageExperience: 3.2,
                    },
                    projects: {
                      [projectName]: {
                        passPercentage: 56,
                        passSatisfaction: 5.6,
                        failSatisfaction: 3.1,
                      }
                    }
                  }
                  ```
                  
                  Then we can make sure that the `processData` method returns that object using `jest.mock` (see solution file). After that, we write the simplest possible code to get those tests to pass.
              </section>
              <section data-markdown>
                  # ProcessData TDD
                  
                  We've defined the **output** of `processData`.
                  
                  Let's use TDD to start implementing that function.
                  
                  ???
                  
                  For the code-along:
                  
                  - Solutions in the `process-data.spec.js` file.
                  - Write the tests first
                  - The function we are testing, `processData`, will take the data object and return another object with processed data.
                  - The key here is to make a mock data object of only 3-4 students. That way it is easy to calculate the expected processed results.
                  - `processData` should return an object with a couple properties, `demographics` and `projects`.
                  - Start with `demographics`, it's much easier
                  - Once you've written a reasonable amount of tests, do the skeleton of the actual function, and make a few tests pass. They'll do the rest in the lab.
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - What BDD is in relation to TDD
                  - Who stakeholders are and what stories are
                  - What outside-in testing is
                  - What interface discovery is
              </section>
          </section>





          <section>
              <section data-markdown>
                  # Introducing React Native
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. What is React Native?
                  2. Dev environment config and debugging
                  3. Basic mobile components
                  4. Styling components
                  5. Lists and data
                  6. Project organization
              </section>
              <section data-markdown>
                  # What Is React Native?
              </section>
              <section data-markdown>
                  # What It Is Not...
                  
                  RN is **not like Cordova** (PhoneGap, Ionic, etc.), which allows you to build something that looks like a native app wrapped in a chromeless web browser in webview inside of a native app (these are known as hybrid apps).
                  
                  RN is also **not an HTML5 app or progressive web app**.
                  
                  And it's **not the only non-webview-based cross-platform** game in town, for example, you could also use also NativeScript (AngularJS/free), Xamarin (#C/freemium), and Appcelerator (JS/paid).
              </section>
              <section data-markdown>
                  # So What Is It?
                  
                  React Native is an open-source (BSD-licensed) framework developed by Facebook.
                  
                  It uses the same fundamental UI building blocks as regular iOS and Android apps, but we get to **use JS and React to build truly native mobile apps** (instead of Objective-C, Swift, or Java).
                  
                  On top of that, RN also offers an (arguably) **better developer experience** and **cross-platform potential** than entirely native approaches.
              </section>
              <section data-markdown>
                  # How Does It Work?
                  
                  RN works because its **bridge** creates an interface between React and the host platform's native UI elements and APIs:
                  
                  .inline-images[
                    ![React Native bridge diagram](/public/img/slide-assets/rn-bridge.jpg)  
                  ]
                  
                  ???
                  
                  - The bridge is all about native call JS and JS calling native
                  - So an RN iOS app, the browser's DOM is replaced with UIKit
                  - Characteristics of the bridge:
                    - Asynchronous
                    - Batched (the native calls)
                    - Serializable (the messages between JS and native)
              </section>
              <section data-markdown>
                  .large[
                  ![React Native threads diagram](/public/img/slide-assets/rn-threads.svg)  
                ]
                
                ???
                
                - The main/native thread launches app and deals with native UI
                - The JS thread is where the JS VM runs entirely
                - There's also a shadow queue (GCD Queue) where some layout concerns are take care of (e.g. flexbox properties, height, width)
                - Native modules can also create their own threads
                
                - Everything always starts on the native side
                - Native decides "I want to run this application now" and sends a call across the bridge to the app entry point
                - The call is serialized via a custom protocol
                - It kicks off `AppRegistry.registerComponent()`
                - Leads to a bunch of calls in JS, which can be calls back into native, e.g. the `UIManager` module
                
                - Touch events always start in native too
                - Call goes across bridge to JS thread to run application code to handle the event and set state, render, etc.
                - The JS side then dispatches view updates
                - The UI updates then happen on the main thread (this can happen at 60fps too)
                
                - The key here is that **JS is driving all the interactions and describing the UI**...because all events are routed through JS
                - And this is the point of React! (`UI = f(data)`)
              </section>
              <section data-markdown>
                  # Rendering to the DOM
                  
                  Recall that when we use React, we also need to include the `ReactDOM` module to render our components to the DOM:
                  
                  ```js
                  import React, { Component } from 'react';
                  import ReactDOM from 'react-dom';
                  
                  class App extends Component {
                     render() {
                        return (
                           <h1 id="title">Hello, world!</h1>
                        );
                     }
                  }
                  
                  ReactDOM.render(<App />, document.getElementById('root'));
                  ```
              </section>
              <section data-markdown>
                  # Rendering with RN
                  
                  Our approach to building a React Native components is noticeably similar, but we import the `AppRegistry` module instead of `ReactDOM`:
                  
                  ```js
                  import React, { Component } from 'react';
                  import { AppRegistry, View, Text } from 'react-native';
                  
                  class App extends Component {
                    render() {
                      return (
                        <View>
                          <Text>Welcome to React Native!</Text>
                        </View>
                      );
                    }
                  }
                  
                  AppRegistry.registerComponent('App', () => App);
                  ```
              </section>
              <section data-markdown>
                  # Why Do It This Way?
                  
                  - You can build **cross-platform** native apps using your existing JS/React skills (no Objective-C, Swift, or Java required!)
                  - Maximizes potential **code re-use** (even between web apps)
                  - There's a large (and growing!) **community** around it
                  - RN allows you to **recompile your apps instantly** (With HMR! And a better debugging experience!!)
                  - You can still **drop into native code** if you need to (e.g. to leverage APIs that aren't exposed in RN by default)
              </section>
              <section data-markdown>
                  # Dev Environment Config and Debugging
              </section>
              <section data-markdown>
                  # Dev Environment
                  
                  Before we can create our first React Native app, we must ensure we have the following tools installed:
                  
                  1. [Xcode](https://developer.apple.com/xcode/)
                  2. [Homebrew](http://brew.sh/)
                  3. [Node](https://nodejs.org/en/)
                  
                  You will likely also want to install a VS Code extension called **[React Native Tools](https://github.com/Microsoft/vscode-react-native)** and the **[React Native Debugger](https://github.com/jhen0409/react-native-debugger)**.
              </section>
              <section data-markdown>
                  # Your First RN App
                  
                  Then we can run:
                  
                  ```bash
                  brew install watchman # a tool for watching changes in the filesystem
                  npm install -g react-native-cli # the React Native CLI
                  ```
                  
                  Now we're ready to create our first RN app!
                  
                  ```bash
                  react-native init HelloWorld # go get a coffee now...
                  cd HelloWorld
                  ```
              </section>
              <section data-markdown>
                  # Your First RN App
                  
                  You're now ready to open your new project in VS Code.
                  
                  You can start the RN Packager Server from with VS Code by typing `⌘ + ⇧ + P` and picking **React Native: Start Packager**.
                  
                  From your project directory, now run:
                  
                  ```bash
                  react-native run-ios
                  ```
                  
                  You can also add the `--simulator="iPhone SE"` flag to that command to launch your app on a specific device.
                  
                  ???
                  
                  - The "packager" is a Node.js server (on localhost:8081 by default)
                  - It's is a local dev server that serves all of the JS you need to run your app
                  - Because you don't need to rebuild the native code in your app when you make a change to your JS, this approach allows you to rebundle and refresh your app very quickly
              </section>
              <section data-markdown>
                  # What's in There?
                  
                  The generated directory structure for your project will include:
                  
                  ```bash
                  |-- __tests__        # for Jest tests
                  |-- android/         # boilerplate for Android
                  |-- index.android.js # entry point for your app
                  |-- index.ios.js     # entry point for your app
                  |-- ios/             # boilerplate for iOS
                  |-- node_modules     # yes, we can use npm packages with RN!
                  |-- package.json     # obviously...don't leave home without it
                  |-  # ...            # other RN config files...
                  ```
                  
                  For now, we will work primarily in `index.ios.js`, but will talk more in depth about project organization later in the lesson.
              </section>
              <section data-markdown>
                  # Digging Deeper
                  
                  But how does RN know what component to bind to the view when our app launches? In our `index.ios.js` file we have:
                  
                  ```js
                  AppRegistry.registerComponent('HelloWorld', () => HelloWorld);
                  ```
                  
                  And if we look in `ios/AppDelegate.m` we'll see:
                  
                  ```objective-c
                  RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                    moduleName:@"HelloWorld"
                    initialProperties:nil
                    launchOptions:launchOptions];
                  ```
                  
                  For Android, we would see the Java equivalent in the `MainActivity.java` file.
              </section>
              <section data-markdown>
                  # Debugging Tools
                  
                  .left-column[
                    ![React Native debugging](/public/img/slide-assets/rn-ios-debugging.png)
                  ]
                  
                  .right-column[
                    React Native provides a handy suite of built-in dev tools. 
                    
                    By pressing `⌘ + D` inside of the iOS simulator, you'll see that you can enable remote JS debugging (in Chrome). Go to [localhost:8081/debugger-ui](localhost:8081/debugger-ui) and open your browser dev tools to view the console output.
                  ]
              </section>
              <section data-markdown>
                  # Debugging Tools
                  
                  - RN has a built-in inspector, perf monitor, etc.
                  - To view iOS simulator logs from the CLI, you can run `react-native log-ios`
                  - The red screen of death will often point you in the right direction...but not always
                  - The third-party [React Native Debugger](https://github.com/jhen0409/react-native-debugger) is essential for debugging your React and Redux code
              </section>
              <section data-markdown>
                  # Basic Mobile Components
              </section>
              <section data-markdown>
                  # Mobile Components
                  
                  In React, we can use any HTML element we like to structure our components. But with RN we are no longer dealing with the browser DOM. We must use RN's special, built-in components to create mobile interface elements, such as:
                  
                  - `<View>` (like `<div>`)
                  - `<Image>` (like `<img>`)
                  - `<Text>` (like `<p>` or `<span>`)
                  - [...and more!](https://facebook.github.io/react-native/docs/getting-started.html)
              </section>
              <section data-markdown>
                  # Mobile Components
                  
                  *Before we proceed...*
                  
                  Unlike HTML elements, RN's built-in mobile UI components are modules we must selectively import from `react-native` wherever we want to use them in our own components:
                  
                  ```js
                  import React, { Component } from 'react';
                  import { Image, Text, View } from 'react-native';
                  
                  // ...your component goes here
                  ```
              </section>
              <section data-markdown>
                  # View and Text
                  
                  The `<View>` [(ref)](https://facebook.github.io/react-native/docs/view.html) component is a general container to support layout, while `<Text>` [(ref)](https://facebook.github.io/react-native/docs/text.html) is an all-purpose component for displaying text.
                  
                  ```js
                  <View>
                    <Text>RN for life.</Text>
                  </View>
                  ```
                  
                  Note that there are no analogous components for `<em>` and `<strong>`, so adding bold and italics to text will require the application of actual styles (more on that to come...)
              </section>
              <section data-markdown>
                  # Image
                  
                  The `source` prop of an `<Image>` [(ref)](https://facebook.github.io/react-native/docs/image.html) component can point to an image asset bundled with your app, or an external image. 
                  
                  Be sure to supply `@2x` and `@3x` versions if possible for static image resources. For network images **you must specify the height and width**.
                  
                  ```js
                  <Image
                    style={% raw %}{{ width: 300, height: 200, }}{% endraw %}
                    resizeMode={"contain"}
                    source={% raw %}{{uri:'https://unsplash.it/600/400/?random'}}{% endraw %}
                    // source={require('./img/puppies.png')} A LOCAL IMAGE!
                  />
                  ```
                  
                  **[Read more on using images in RN here.](https://facebook.github.io/react-native/docs/images.html)**
              </section>
              <section data-markdown>
                  # Image
                  
                  Also note that `<Image>` components do not need to be self-closing in RN! 
                  
                  You wrap opening and closing `<Image>` tags around another component, then easily absolutely position the inner component on top of the image.
                  
                  ```js
                  <Image
                    style={% raw %}{{ width: 300, height: 200, }}{% endraw %}
                    source={% raw %}{{uri:'https://unsplash.it/600/400/?random'}}{% endraw %}
                  >
                    <Text>Some text...</Text>
                  </Image>
                  ```
              </section>
              <section data-markdown>
                  # TextInput
                  
                  We may also want users to enter text into a `<TextInput>` [(ref)](https://facebook.github.io/react-native/docs/textinput.html) at some point...
                  
                  ```js
                  <TextInput
                    style={% raw %}{{ height: 30, width: 100, borderWidth: 1, 
                      borderColor: "rgba(0,0,0,0.5)"}}{% endraw %}
                    placeholder={'Type here'}
                    placeholderTextColor={"rgba(198,198,204,1)"}
                    onChangeText={(text) => {this.setState({text})}}
                    onSubmitEditing={() => {this.setState({text: ''})}}
                    value={(this.state && this.state.text) || ''}
                  />
                  ```
                  
                  Notice the built-in props that are available on listening to changes on the component.
              </section>
              <section data-markdown>
                  # TouchableOpacity
                  
                  To change reduce an element's opacity on press, `<TouchableOpacity>` [(ref)](https://facebook.github.io/react-native/docs/touchableopacity.html):
                  
                  ```js
                  <TouchableOpacity
                    onPress={() => {}}
                    activeOpacity={75 / 100}>
                    <Text>Press me!</Text>
                  </TouchableOpacity>
                  ```
              </section>
              <section data-markdown>
                  # TouchableHighlight
                  
                  To highlight an element on press, use `<TouchableHighlight>` [(ref)](https://facebook.github.io/react-native/docs/touchablehighlight.html):
                  
                  ```js
                  <TouchableHighlight
                    onPress={() => {}}
                    activeOpacity={75 / 100}
                    underlayColor={"rgb(210,210,210)"}
                  >
                    <Text>Press me!</Text>
                  </TouchableHighlight>
                  ```
                  
                  This differs from `<TouchableOpacity>` because an underlay colour is added that tints the view. The underlay comes from adding a view to the view hierarchy, which can cause visual weirdness sometimes.
              </section>
              <section data-markdown>
                  # ScrollView
                  
                  By default your views will not be scrollable (i.e. they will be limited to the fixed size of the mobile device screen). 
                  
                  You will need a `<ScrollView>` [(ref)](https://facebook.github.io/react-native/docs/scrollview.html) component to create scrolling views:
                  
                  ```js
                  <ScrollView>
                    <Text style={% raw %}{{fontSize:96}}{% endraw %}>Scroll me plz</Text>
                    <Text style={% raw %}{{fontSize:96}}{% endraw %}>i haz</Text>
                    <Text style={% raw %}{{fontSize:96}}{% endraw %}>so much big txt</Text>
                  </ScrollView>
                  ```
                  
                  **[Read more on using scrolling containers in RN here.](https://facebook.github.io/react-native/docs/using-a-scrollview.html)**
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Your turn! Go to the [React Native Docs](https://facebook.github.io/react-native/docs/getting-started.html) and find at least one other mobile component that we haven't discussed yet to try out. Add it to your `HelloWorld` app.
                  
                  Be creative and come up with a cool demo for the class.
              </section>
              <section data-markdown>
                  # Styling Components
              </section>
              <section data-markdown>
                  # How Styles Work
                  
                  There is no CSS in RN per se&mdash;but we will style components using JS that looks a lot like the CSS we're used to though.
                  
                  RN also supports a **smaller subset of properties** than normal CSS. You can see a [list of those properties here](https://github.com/vhpoet/react-native-styling-cheat-sheet).
                  
                  In RN, we have a few options for adding styles to components:
                  
                  - Inline styles
                  - Styling with objects
                  - `StyleSheet.create`
              </section>
              <section data-markdown>
                  # Inline Styles
                  
                  We can use inline styles with RN just as we can with React:
                  
                  ```js
                  render() {
                    return (
                      <View style={% raw %}{{flex: 1, alignItems: 'center'}}{% endraw %}>
                        <Text>Hello, world!</Text>
                      </View>
                    );
                  }
                  ```
                  
                  Generally, inline styles should be **avoided as much as possible** because they are less efficient than other options (as these styles will be recreated with each render pass).
              </section>
              <section data-markdown>
                  # Styling with Objects
                  
                  We can also create objects that contain blocks of re-usable styles to keep things more organized and modular:
                  
                  ```js
                  let styles = {
                    container: {
                      flex: 1,
                      justifyContent: 'center',
                      alignItems: 'center',
                    }
                  }
                  
                  <View style={styles.container}>
                    <Text>Hello, world!</Text>
                  </View>
                  ```
              </section>
              <section data-markdown>
                  # StyleSheet.create
                  
                  RN also provides us `StyleSheet.create` as bit of optional syntactic sugar for creating our style objects (but this is likely the way we'll usually want to do it).
                  
                  The previous style objects occasionally offer an advantage over the `StyleSheet.create` though, because style objects allow our style to be mutable (which may be desirable when using modules such as the `PanResponder`).
              </section>
              <section data-markdown>
                  # StyleSheet.create
                  
                  **Example:**
                   
                  ```js
                  import React, { Component } from 'react';
                  import { StyleSheet, Text, View } from 'react-native';
                  
                  export default class HelloWorld extends Component {
                    render() {
                      return (
                        <View style={styles.container}>
                          <Text>Hello, world!</Text>
                        </View>
                      );
                    }
                  }
                  
                  const styles = StyleSheet.create({
                    container: {
                      flex: 1,
                      alignItems: 'center',
                    },
                  });
                  ```
              </section>
              <section data-markdown>
                  # Layouts with RN
                  
                  RN supports Flexbox for layouts, with some small differences:
                  
                  - `flexDirection` column defaults to `column` (not `row`)
                  - `alignItems` defaults to `stretch` (not `flex-start`)
                  - the `flex` property only supports a single number (e.g. `flex: 1`)
                  
                  We also use CSS positioning in our layouts (e.g. `absolute`), but floats are not supported. The usual box model properties are available as well.
                  
                  **[You can read more on layouts here.](https://facebook.github.io/react-native/docs/flexbox.html)**
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Time for an RN layout challenge!
                  
                  See the [lesson page](/lesson/01-intro-to-react-native/) for more details...
                  
              </section>
              <section data-markdown>
                  # Lists and Data
              </section>
              <section data-markdown>
                  # Lists and RN
                  
                  React Native provides three different components for tranforming data into lists in your app UI:
                  
                  - [ListView](https://facebook.github.io/react-native/docs/listview.html) (older)
                  - [FlatList](https://facebook.github.io/react-native/docs/flatlist.html) (simpler)
                  - [SectionList](https://facebook.github.io/react-native/docs/sectionlist.html) (more features)
              </section>
              <section data-markdown>
                  # FlatList & SectionList
                  
                  A list view (generally) is a common UI pattern in mobile apps. Think of it like a `<ScrollView>` with benefits.
                  
                  The `<FlatList>` [(ref)](https://facebook.github.io/react-native/docs/flatlist.html) or `<SectionList>` [(ref)](https://facebook.github.io/react-native/docs/sectionlist.html) expects you to insert some kind of (potentially very large) data blob into it, and it will display that data much more efficiently than a basic `<ScrollView>` could. Performance FTW.
                  
                  To use either, you will need some data (in array format), a component to render each list item, and way to apply a unique key to each list item.
              </section>
              <section data-markdown>
                  <iframe width="640" height="360" src="https://www.youtube.com/embed/-VPM6ICgCk8?rel=0" frameborder="0" allowfullscreen></iframe>
              </section>
              <section data-markdown>
                  # FlatList
                  
                  Setting up `<FlatList>` in a component:
                  
                  ```js
                  constructor() {
                    super();
                    this.state = { data: ['Thing 1', 'Thing 2'] };
                  }
                    
                  render() {
                    return (
                      <FlatList
                        data={this.state.data}
                        renderItem={({ item }) => <View><Text>{item}</Text></View>}
                        keyExtractor={(item, index) => index}
                      />
                    );
                  }
                  ```
                  
                  Note that `item` is destructured out of the **[info object parameter](http://facebook.github.io/react-native/docs/flatlist.html#renderitem)** of `renderItem`.
              </section>
              <section data-markdown>
                  # Fetching Data
                  
                  We often want to populate a list view with external data.
                  
                  Let's start by setting a state property to hold the data for the `FlatList` once fetched:
                  
                  ```js
                  constructor() {
                    super();
                  
                    this.state = {
                      data: [],
                      isLoading: true,
                    };
                  }
                  ```
              </section>
              <section data-markdown>
                  # Fetching Data
                  
                  Then we'll fetch our data, and update state with it:
                  
                  ```js
                  componentDidMount() {
                    let endpoint = 'https://api.github.com/users/octocat/repos';
                  
                    fetch(endpoint)
                      // if fetch is successful, read our JSON out of the response
                      .then(response => response.json())
                      .then(data => {
                        this.setState({ data });
                      })
                      .catch(error => console.log(`Error fetching JSON: ${error}`));
                  }
                  
                  componentDidUpdate() {
                    if ( this.state.data && this.state.isLoading ) {
                      this.setState({ isLoading: false });
                    }
                  }
                  ```
              </section>
              <section data-markdown>
                  # Fetching Data
                  
                  Finally, we'll render our data in our component:
                  
                  ```js
                  render() {
                   if (this.state.isLoading) {
                    return (
                     <ActivityIndicator animating={true} size="small" color="black" />
                    );
                   } else {
                    return (
                     <FlatList
                      data={this.state.data}
                      renderItem={({ item }) => <View><Text>{item.name}</Text></View>}
                      keyExtractor={item => item.id}
                     />
                    );
                   }
                  }
                  ```
              </section>
              <section data-markdown>
                  # Other Features
                  
                  Customizable things in a `<FlatList>` (or `<SectionList>`):
                  
                  - Add a separator (between list items, excluding the last)
                  - Add a header (or sticky header) to the top of your list (a search box maybe?)
                  - Add a footer (perhaps a Load More button?)
                  - Add pull to refresh or scroll loading functionality
                  - `SectionList` only: add a sticky header for each section of your list (where have we seen this pattern?)
                  
              </section>
              <section data-markdown>
                  # SectionList Data
                  
                  The `<SectionList>` component is very similar to the `<FlatList>`, but the data will need to be a different shape, and will be set on the `sections` prop instead:
                  
                  ```js
                  <SectionList
                    sections={[
                      {title: 'ADP', data: ['Bob', 'Alice']},
                      {title: 'WDP', data: ['Anne', 'Mary', 'Joe']},
                    ]}
                    renderItem={({ item }) => <Text>{item}</Text>}
                    renderSectionHeader={({ section }) => <Text>{section.title}</Text>}
                  />
                  ```
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Now you're going to build a slightly more complex `<FlatList>` in your `HelloWorld` app to display a list of users.
                  
                  See the [lesson page](/lesson/01-intro-to-react-native/) for more details...
              </section>
              <section data-markdown>
                  # Project Organization
              </section>
              <section data-markdown>
                  # Thinking Ahead
                  
                  Our project organization plan of attack:
                  
                  - Reuse as much code as possible (esp. cross-platform)
                  - Keep configuration out of code
                  - Follow the container/presentational component pattern and keep our components as dumb as possible
              </section>
              <section data-markdown>
                  # Project Folder
                  
                  We won't want to depend on `index.ios.js` and `index.android.js` exclusively as our app grows. Let's add a directory to house all of our RN code called `app`:
                  
                  ```bash
                  |-- __tests__
                  |-- android/
                  |-- js/ # <----------- ADD THIS DIR!
                  |-- index.android.js
                  |-- index.ios.js
                  |-- ios/
                  |-- node_modules
                  |-- package.json
                  ```
              </section>
              <section data-markdown>
                  # Project Folder
                  
                  Inside the `app` folder...
                  
                  ```bash
                  |-- js/
                  |   |-- components # smaller chunks of reusable, stateless UI
                  |   |-- config     # keep configuration out of code!
                  |   |-- assets     # static image assets and custom fonts
                  |   |-- lib        # general functions (code re-use FTW!)
                  |   |-- redux      # store and reducers go here
                  |   |-- navigation # define routes and nav components
                  |   |-- scenes     # container components that render each scene
                  |   |-- index.js   # single entry point of a cross-platform app
                  ```
                  
                  You will import `index.js` into `index.ios.js` and `index.android.js` and pass your top-level component into `AppRegistry.registerComponent()` to register your app.
              </section>
              <section data-markdown>
                  # Example
                  
                  In `index.ios.js` and `index.androids.js`:
                  
                  ```js
                  import { AppRegistry } from 'react-native';
                  import HelloWorld from './app';
                  
                  AppRegistry.registerComponent('HelloWorld', () => HelloWorld);
                  ```
                  
                  In `app/index.js`:
                  
                  ```js
                  import React, { Component } from 'react';
                  import { View, Text } from 'react-native';
                  
                  export default class HelloWorld extends Component {
                    render() {
                      return (
                        <View><Text>Welcome to React Native!</Text></View>
                      );
                    }
                  }
                  ```
              </section>
              <section data-markdown>
                  # Configuration
                  
                  What to put in your `config` folder:
                  
                  ```bash
                  |-- config/
                  |   |-- models.js # for defining our Realm db schema later
                  |   |-- api.js    # for API details, etc.
                  |   |-- styles.js # for shared styles (typography, colours, etc.)
                  ```
                  
                  **Note:** In RN, we typically want to **reuse styled components**, rather than reusing styles. 
                  
                  However, it usually make sense to set some base styles for our colours and typography (etc.) that can be imported into components throughout our app.
              </section>
              <section data-markdown>
                  # Scenes
                  
                  Each scene of your app will be a container/presentational component combo:
                  
                  ```bash
                  |-- scences/
                  |   |-- User
                  |   |   |-- index.js
                  |   |   |-- styles.js
                  |   |   |-- User.js
                  |   |   |-- UserContainer.js
                  ```
                  
                  And in the `index.js` we follow this pattern:
                  
                  ```js
                  import UserContainer from './UserContainer';
                  import User from './User';
                  
                  export { User };
                  export default UserContainer;
                  ```
              </section>
              <section data-markdown>
                  # Components
                  
                  Use can use a similar directory structure for our reusable, stateless UI components:
                  
                  ```bash
                  |-- components/
                  |   |-- UserAvatar
                  |   |   |-- index.js
                  |   |   |-- styles.js
                  |   |   |-- UserAvatar.js
                  ```
                  
                  In `index.js`:
                  
                  ```js
                  import UserAvatar from './UserAvatar';
                  
                  export default UserAvatar;
                  ```
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - What React Native is and why it is awesome
                  - How to configure our dev environments and debug RN apps
                  - How to use and style RN's mobile UI components
                  - How to use the ListView component to display fetched data 
                  - How to organize an RN project effectively
              </section>
          </section>



          <section>
              <section data-markdown>
                  # Navigation and Dependencies
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Reasoning about mobile navigation
                  2. Navigation options in React Native
                  3. Managing state with Redux in React Native (with a navigator!)
                  4. Using third-party modules and linking dependencies in an iOS RN app
              </section>
              <section data-markdown>
                  # Navigation in Mobile Apps
              </section>
              <section data-markdown>
                  # Browserless Nav
                  
                  What we don't have:
                  
                  - The usual back and forward buttons
                  - Browser history
                  - Hypertext and URLs
                  
                  What we do have:
                  
                  - Established **platform-specific patterns** that people are accustomed to when navigating around native mobile apps
              </section>
              <section data-markdown>
                  ### iOS Human Interface Guidelines:
                  
                  People tend to be unaware of an app's navigation until it doesn't meet their expectations.
                  
                  *So while mobile nav may seem simple on the surface, we have to put a bit of thought into it to build it out well.*
              </section>
              <section data-markdown>
                  # Basic Infrastructure
                  
                  A basic navigation infrastructure for our apps will hold a **navigation stack**.
                  
                  The stack will hold **screens**, and those screens will hold **components** and **data**.
                  
                  We can also **nest** navigation stacks within one another.
                  
                  We may also use **tab bars** and **drawer-style navigation**.
              </section>
              <section data-markdown>
                  .inline-images[
                  ![Nav stack screens](/public/img/slide-assets/nav-stack-screens.png)
                ]
              </section>
              <section data-markdown>
                  .inline-images[
                  ![Nav stack screens stacked](/public/img/slide-assets/nav-stack-stacked.png)
                ]
              </section>
              <section data-markdown>
                  .inline-images[
                  ![Tabs can have nav stacks](/public/img/slide-assets/nav-tab-stacks.png)
                ]
                
              </section>
              <section data-markdown>
                  # Navigation Components
              </section>
              <section data-markdown>
                  .large[
                  React Native comes with a few built-in navigation components out of the box...
                ]
              </section>
              <section data-markdown>
                  # NavigatorIOS
                  
                  See the docs: [NavigatorIOS](https://facebook.github.io/react-native/docs/navigatorios.html)
                  
                  - Integrated with UIKit (leverages its animation)
                  - Built on top of `UINavigationController`
                  - Uses routes to represent scenes
                  - Very stateful
                  - No Android support
              </section>
              <section data-markdown>
                  # Navigator
                  
                  See the docs: [Navigator](https://facebook.github.io/react-native/docs/navigator.html)
                  
                  - Pure JS implementation of a nav stack (so you may bump into performance issues in some implementations)
                  - Cross-platform
                  - Also uses routes to represent scenes
                  - Also very stateful
              </section>
              <section data-markdown>
                  # NavigationExperimental
                  
                  See the docs: [NavigationExperiemental](https://facebook.github.io/react-native/docs/navigation.html#navigationexperimental)
                  
                  - Uses a Redux-like pattern for managing navigator state
                  - Cross-platform
                  - Allows more complex navigation animations than Navigator
                  - Supports the tab bar
                  - Supports nested navigation
                  - But API is kind of scary (and is deprecated)
              </section>
              <section data-markdown>
                  # Third-Party Solutions
                  
                  Some of third-party solutions wrap the JS navigator or `NavigationExperimental`, others expose the platform's native navigation. Some popular options include:
                  
                  - [wix/react-native-navigation](https://github.com/wix/react-native-navigation)
                  - [aksonov/react-native-router-flux](https://github.com/aksonov/react-native-router-flux)
                  - [expo/ex-navigation](https://github.com/expo/ex-navigation)
                  - [react-community/react-navigation](https://github.com/react-community/react-navigation) (still beta...)
              </section>
              <section data-markdown>
                  .large[
                  So what do we use...?
                ]
              </section>
              <section data-markdown>
                  # What We Want
                  
                  Ideally, we want an all-in-one navigation solution with:
                  
                  - Support for **Android back button**
                  - Integration with the a (potentially cross-platform) **tab bar**
                  - Support for **nested nav stacks** without creating state management headaches for ourselves
                  - Good **performance** (uses native animation)
                  
              </section>
              <section data-markdown>
                  # ExNavigation
                  
                  - A higher level of abstraction on `NavigationExperimental`
                  - Provides a set of defaults that can be customized
                  - Supports tab navigation, sliding drawer navigation, the Android back button, and modals
                  - Your routes are your React Components
                  - Easily nests stack navigation within tab navigation
                  - Can integrate its navigation state with your own Redux store if you want (but this is totally optional)
              </section>
              <section data-markdown>
                  # Configuration
                  
                  - `createRouter` will be used to map route name to components
                  - The `<NavigationProvider>` will wrap our navigation scheme at the top level of our app only
                  - `<StackNavigation>` represents a single stack of screens (and each tab in a tab bar can contain its own stack)
                  - We define our route configuration with the component itself using `static route = {}`
                  
                  See the **[minimal navigation set up example](https://github.com/expo/ex-navigation#a-minimal-navigation-set-up).**
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Follow the [installation instructions](https://github.com/expo/ex-navigation#installation) for ExNavigation and add it to your project.
                  
                  Define your routes in `navigation/routes.js`. Define `static route = {}` in each of your scene container components to configure a nav bar title for each scene.
                  
                  In your `js/index.js` file, add the `<NavigationProvider>` with a single `<StackNavigation>`, and set the `initialRoute` to your Schedule scene.
                  
                  Try swapping your `initialRoute` to your About scene and see if it works also.
              </section>
              <section data-markdown>
                  .large[
                  Adding Redux...<br />worth the effort.
                ]
              </section>
              <section data-markdown>
                  # Install Redux
                  
                  We can use Redux in a React Native app just like a regular web-based React app.
                  
                  Begin by installing Redux and related dependencies:
                  
                  ```bash
                  npm install --save redux react-redux redux-thunk
                  ```
                  
                  We will use the `redux-thunk` middleware make it possible to do asynchronous work in our action creators.
                  
                  Next, we'll create our `store.js` file in a `redux` directory...
              </section>
              <section data-markdown>
                  # The Store
                  
                  ```js
                  import { createNavigationEnabledStore } from '@expo/ex-navigation';
                  import { compose, createStore, applyMiddleware } from 'redux';
                  import thunk from 'redux-thunk';
                  
                  import rootReducer from './reducers'; // we haven't made these yet...
                  
                  const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; // definitely enable Redux dev tools!
                  
                  const createStoreWithNavigation = createNavigationEnabledStore({
                    createStore,
                    navigationStateKey: 'navigation',
                  }); // as per the ExNavigation docs...
                  
                  const store = createStoreWithNavigation(
                    rootReducer,
                    {}, // initial state
                    composeEnhancers(
                      applyMiddleware(thunk)
                    ) // enhancers
                  );
                  
                  export default store;
                  ```
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Now set up the `reducers.js` file in the `redux` directory.
                  
                  Be sure to import `combineReducers` into this file, as well as the named `NavigationReducer` export from ExNavigation. Export your combined reducers from this file.
                  
                  Next, provide the `NavigationContext`, directly to the `NavigationProvider` component in your app's main `index.js` file. You'll also need to wrap everything in the `Provider` component from `react-redux`, just like usual.
                  
                  Please refer to the **[ExNavigation docs](https://github.com/expo/ex-navigation#integrate-with-your-existing-redux-store)** for assistance completing this exercise.
              </section>
              <section data-markdown>
                  # Next Steps
                  
                  For our purposes it will be best to leave this navigator defined at the highest level of our app, and then nest our tab bar navigation (or drawer navigation for Android) within it.
                  
                  Why do it this way? Eventually, when we add our lightbox-style scene for viewing one photo at a time, we will need to push this scene onto our top-level `StackNavigation`.
                  
                  If we were to simply push this scene onto the stack inside the tab bar, we would have tab fixed on top of the lightbox (which does not adhere to the prototype).
              </section>
              <section data-markdown>
                  # Exercise 3
                  
                  Time to add a tab bar to our iOS app. Create a file called `NavigationLayout.js` in your `js/navigation` directory. Use this file to build out a component where the `render` function returns ExNavigator's `<TabNavigation>` component.
                  
                  Create a `<TabNavigationItem>` for your About and Schedule routes. What do you need to change in your top-level `initialRoute` now?
                  
                  Thinking ahead, each `<TabNavigationItem>` should have its own `<StackNavigation>` component nested inside of it too.
              </section>
              <section data-markdown>
                  # Linking Dependencies
              </section>
              <section data-markdown>
                  # Dependencies
                  
                  Sometimes we need to install additional libraries in our apps, and these libraries will have native dependencies.
                  
                  There are two way we can do this:
                  
                  1. Automatic linking with `react-native link`
                  2. Manual linking (in Xcode or the Android directory)
              </section>
              <section data-markdown>
                  # Automatic Linking
                  
                  RN now has a built-in way to link dependencies from the CLI (was previously a separate package called `rnpm`).
                  
                  To use it, you'll need to install a package that requires linking:
                  
                  ```bash
                  npm install <library-with-native-dependencies> --save
                  ```
                  
                  React Native will link your libs based on `dependencies` and `devDependencies` in your `package.json` file. Then you can link up your dependencies for iOS and Android by running:
                  
                  ```bash
                  react-native link
                  ```
                  
                  Voila! That's it.
              </section>
              <section data-markdown>
                  # Exercise 4
                  
                  Our app is going to need some icons, so for that we're going to add the **[React Native Vector Icons package](https://github.com/oblador/react-native-vector-icons)**.
                  
                  Note that this package's native dependencies can be automatically linked with `react-native link`.
                  
                  Once this is done, write yourself a helper `renderIcon` function in your `NavigationLayout.js` to render the appropriate Ionicon icon for each of the tabs in your tab bar. An icon should be `white` if selected, and `#999999` if not.
                  
                  Add your helper function as the `renderIcon` prop on each `<TabNavigationItem>`.
              </section>
              <section data-markdown>
                  # Manual Linking
                  
                  Sometimes we may need to manually link native dependencies in Xcode.
                  
                  For instance, React Native includes a `CameraRoll` module bundled with it, but if we want to use this library (to allow users to save images from the app to their camera roll) we need to manually link it. To do that, we need to open our project folder and navigate to `node_modules/react-native/Librares/...` and also open Xcode.
                  
                  **[Instructions for manual linking](https://facebook.github.io/react-native/docs/linking-libraries-ios.html#manual-linking)** are available in the React Native docs.
              </section>
              <section data-markdown>
                  # Exercise 5
                  
                  We want to use Montserrat as a custom font in our app, and `react-native link` can help with this too.
                  
                  Inside of the app's `package.json` file, add the following:
                  
                  ```js
                  "rnpm": {
                    "assets": [
                      "js/assets/fonts"
                    ]
                  }
                  ```
                  
                  Move your project's fonts into the above directory and run `react-native link` again. You should now be able to set the `fontFamily` to `Montserrat` and `Montserrat-Light` in your app...without crashing it :)
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - Special considerations for building out user-friendly navigation in mobile apps
                  - What navigation options are built into React Native, and what third-party options are available
                  - How to Redux-ify our React Native app
                  - How to use a navigator and tab bar
                  - How to add third-party libraries and link their dependencies both automatically and manually
              </section>
          </section>



          <section>
              <section data-markdown>
                  # Realm Databases
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Whats and whys of embedded databases
                  2. Adding Realm to a React Native project and defining schema
                  3. Saving and retrieving Realm data in an app
              </section>
              <section data-markdown>
                  # Mobile Databases
              </section>
              <section data-markdown>
                  .large[
                  Do you need actually need an embedded database in your mobile app?
                ]
                
              </section>
              <section data-markdown>
                  # AsyncStorage
                  
                  If you just need a basic key-value store for a small amount of data, the `AsyncStorage` [(ref)](https://facebook.github.io/react-native/docs/asyncstorage.html) library built into React Native may do the trick.
                  
                  Think of `AsyncStorage` as being the React Native equivalent of a web brower's local storage API.
                  
                  Note that data stored in `AsyncStorage` won't be encrypted.
              </section>
              <section data-markdown>
                  # Use Cases
                  
                  - Personal preferences and other user-specific data
                  - Offline data access
                  - Some kinds of local caching
              </section>
              <section data-markdown>
                  # What's Out There
                  
                  **SQLite:**
                  
                  - Popular (fast!) cross-platform embedded database
                  - Written in C (and must write queries, unless you use a library to abstract this away)
                  
                  **Core Data:**
                  
                  - An ORM abstraction on top of SQLite (with a learning curve)
                  - iOS/Mac Only
              </section>
              <section data-markdown>
                  # So...Realm!
                  
                  What [Realm](https://realm.io/) is:
                  
                  - It's **not an ORM** built on something that already exists
                  - "It's objects all the way down"
                  - It avoids expensive operations when trying to map a relational model to an object-focused model by design (so it's super fast)
                  - It was designed specifically to be used in phones and tablets and it's insanely easy to add and use in an app
              </section>
              <section data-markdown>
                  # Setting Up Realm
              </section>
              <section data-markdown>
                  # Installing Realm
                  
                  There are two steps to add Realm to your project. First, add the npm package:
                  
                  ```bash
                  npm install --save realm
                  ```
                  
                  Then link it up:
                  
                  ```bash
                  react-native link realm
                  ```
                  
                  Congratulations, you have now added an embedded a mobile database in your app, and linked all of its native dependencies.
              </section>
              <section data-markdown>
                  # Supported Data Types
                  
                  Realm supports the following basic types: **bool**, **int**, **float**, **double**, **string**, **data**, and **date**:
                  
                  - `bool` (maps to JavaScript `Boolean` objects)
                  - `int`, `float`, `double` (maps to JavaScript `Number` objects)
                  - `string` (maps to `string`)
                  - `data` (maps to `ArrayBuffer`)
                  - `date` (maps to `Date`)
              </section>
              <section data-markdown>
                  # Defining Data Models
                  
                  Creating a new data model with Realm couldn't be easier:
                  
                  ```js
                  import Realm from 'realm';
                  
                  const Dog = {
                    name: 'Dog',
                    properties: {
                      id: 'int',
                      name:  'string',
                      breed: 'string',
                      birthday: {type: 'date', optional: true},
                    }
                  };
                  
                  export default new Realm({schema: [Dog]});
                  ```
              </section>
              <section data-markdown>
                  # Defining Data Models
                  
                  What else can we do with our model?
                  
                  - Selectively index properties
                  - Set a primary key (but no there's auto-incrementing of primary keys out-of-the-box yet...)
                  - Set a default value
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  If you haven't already, create a `config/model.js` file in your project.
                  
                  In this file, define the model for a `Fave` object. Our `Fave` objects should have an `id` string property and a `faved_on` date property. 
                  
                  Set the `id` as the `primaryKey` for your model.
                  
                  Be sure to initialize your new Realm with its `Fave` model, and export it so its available in your Faves scene later.
              </section>
              <section data-markdown>
                  # Writing, Retrieving, and Displaying Data
              </section>
              <section data-markdown>
                  # Writing
                  
                    Writing data to your Realm database is easy too. All database writes must be wrapped in the following method:
                  
                    ```js
                    realm = new Realm({schema: [Dog]});
                  
                    realm.write(() => {
                      // we create/update and delete our data here
                    });
                    ```
                  
                    From there, we can call the `realm.create()` and `realm.delete()` methods create/update and delete data from our database.
              </section>
              <section data-markdown>
                  # Creating and Updating
                  
                  We can use `realm.create()` to both create and update data:
                  
                  ```js
                  realm = new Realm({schema: [Dog]});
                  
                  realm.write(() => {
                    // Create a dog object
                    realm.create('Dog', {id: 1, name: 'Gomez', breed: 'Shih Tzu'});
                  
                    // Passing "true" intelligently updates the object keyed off the id
                    realm.create('Dog', {id: 1, name: 'Gomer Pile'}, true);
                  });
                  ```
              </section>
              <section data-markdown>
                  # Deleting
                  
                  And use `realm.delete()` to remove data:
                  
                  ```js
                  realm.write(() => {
                    let dog = realm.create('Dog', {id: 2, name: 'Dexter', breed: 'Boston'});
                  
                    realm.delete(dog); // delete Dexter :(
                      
                    let allDogs = realm.objects('Dog');
                    realm.delete(allDogs); // delete all dogs :( :( :(
                  });
                  ```
              </section>
              <section data-markdown>
                  # Querying
                  
                  The final piece of the CRUD puzzle is reading data from the database.
                  
                  ```js
                  let dogs = realm.objects('Dog'); // get all the dog objects
                  ```
                  
                  Get specific dog objects with filtering:
                  
                  ```js
                  let dogId = 1;
                  let gomez = dogs.filtered('id == $0', dogId);
                  let dexter = dogs.filtered('breed = "Boston" AND name BEGINSWITH "D"');
                  ```
                  
                  And sort our results too:
                  
                  ```js
                  let ascDogs = dogs.sorted('name'); 
                  let descDogs = dogs.sorted('name', true); // reverses the order 
                  ```
              </section>
              <section data-markdown>
                  # Pro Tip!
                  
                  You can install **[Realm Browser](https://github.com/realm/realm-browser-osx)** as a GUI for managing your Realm databases.
                  
                  To find out where your Realm database is stored locally, you can log the path to the file in your console:
                  
                  ```js
                  realm = new Realm({schema: [Dog]});
                  console.log('the path is: ', realm.path);
                  ```
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Inside your `config/models.js` file, write three functions (which you will export) to perform CRUD operations in related "faves" action creators later:
                  
                  1. A function that **adds a Fave object** to the database
                  2. A function that **removes a Fave object** from the database
                  3. A function that **queries** the database for **all Fave objects**
                  
                  *Where (and how) will you use these functions?*
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - What an embedded database is in the context of a mobile app, and when its appropriate to use one
                  - How to add Realm to a React Native app
                  - How to define a schema with Realm
                  - How to perform basic CRUD operations on a Realm database in React Native
              </section>
          </section>



          <section>
              <section data-markdown>
                  # Android Apps with React Native
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Set up our Android dev environment
                  2. Explore RN's cross-platform capabilities
                  3. Use the `Platform` module
                  4. Use platform-specific file extensions
                  
              </section>
              <section data-markdown>
                  # Android Dev Environment
              </section>
              <section data-markdown>
                  # Set-up
                  
                  Developing React Native apps for Android takes a bit more set-up work than installing Xcode.
                  
                  To begin, please ensure that you have completed all of the **[pre-work for this lesson](/lesson/04-android/)**, including installing/upgrading Java, installing Android Studio and the Android SDK, and adding at least one emulator.
              </section>
              <section data-markdown>
                  # Starting Your App
                  
                  Before you can run your app, you need to power up the emulator to run it on. You must launch an Android emulator from **within Android Studio first**.
                  
                  Finally, you can `cd` into your RN app directory and run:
                  
                  ```bash
                  react-native run-android
                  ```
              </section>
              <section data-markdown>
                  # Debugging Tools
                  
                  .left-column[
                    ![React Native debugging](/public/img/slide-assets/rn-android-debugging.png)
                  ]
                  
                  .right-column[
                    We have a similar set of RN dev tools available when running the Android emulator.
                    
                    However, we will have to press `⌘ + M` to open them. To manually reload an app in the emulator, press `R + R`.
                  ]
              </section>
              <section data-markdown>
                  # Debugging Tools
                  
                  Debugging Android-related issues may often require looking at some logs. To dump a log of all system messages (including stack traces and errors) run:
                  
                  ```bash
                  adb logcat
                  ```
                  
                  To view your RN-related console logs run:
                  
                  ```bash
                  react-native log-android
                  # or run: adb logcat *:S ReactNative:V ReactNativeJS:V
                  ```
              </section>
              <section data-markdown>
                  # Cross-Platform Capabilities
              </section>
              <section data-markdown>
                  # The Beauty of RN
                  
                  React Native makes very easy to build cross-platform apps, basically by default. 
                  
                  With that in mind, we'll want to **re-use as much code as possible** when building a cross-platform app.
                  
                  When we view the [React Native docs](https://facebook.github.io/react-native/docs/getting-started.html) we can see that most of the components and APIs listed there are inherently cross-platform.
              </section>
              <section data-markdown>
                  # Be A Little More Specific
                  
                  But sometimes the occasion rises to run code on only iOS **or** Android devices.
                  
                  Luckily, RN provides with two different ways to do this:
                  
                  1. The `Platform` module
                  2. Platform-specific file extensions
                  
              </section>
              <section data-markdown>
                  # The Platform Module
                  
              </section>
              <section data-markdown>
                  # Platform Module
                  
                  We can use the `Platform` modules to conditionally render components or styles for our components. For example:
                  
                  ```js
                  import { Platform, Text, View} from 'react-native';
                  
                  const App = () => {
                    return(
                      <View>
                        <Text>I can be seen an all platforms.</Text>
                        {Platform.OS === 'ios' &&
                          <Text>You'll only see me on iOS devices.</Text>
                        }
                        {Platform.Version === 24 &&
                          <Text>And I'm only on Android devices running Nougat.</Text>
                        }
                      </View>
                    );
                  };
                  ```
                  
              </section>
              <section data-markdown>
                  # Platform Module
                  
                  We also have access to a `Platform.select` method:
                  
                  ```js
                  import { Platform, StyleSheet } from 'react-native';
                  
                  const styles = StyleSheet.create({
                    container: {
                      flex: 1,
                      ...Platform.select({
                        ios: {
                          backgroundColor: 'red',
                        },
                        android: {
                          backgroundColor: 'blue',
                        },
                      }),
                    },
                  });
                  ```
                  
                  This method will return the value for the platform you are on.
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Using what you learned about the `Platform` modules, make two adjustments to your R10 project:
                  
                  1. Conditionally render the heart icon in the Schedule, Session, and Faves scenes to use the Ionicon `md-heart` instead of `ios-heart`.
                  2. To get Montserrat (Regular) working on Android, you'll need to set your main font to `Montserrat-Regular` for that platform (rather than `Montserrat`, as we did on iOS). Use `Platform.select` for this.
                  
              </section>
              <section data-markdown>
                  # Platform Specific File Extensions
              </section>
              <section data-markdown>
                  # File Extensions
                  
                  We've already seen an example of this in action with `index.ios.js` and `index.android.js`, which are the main entry points of our apps on each platform.
                  
                  Each platform specific-file is invisible to the other platform thanks to the infix.
                  
                  We can extend this pattern to our own components too when our platform-specific code is too complex to manage with the `Platform` module.
              </section>
              <section data-markdown>
                  # File Extensions
                  
                  What this looks like in practice:
                  
                  ```bash
                  |-- components/
                  |   |-- Widget/
                  |   |   |-- Widget.android.js
                  |   |   |-- Widget.ios.js
                  |   |   |-- index.js
                  |   |   |-- styles.js
                  ```
                  
                  And in `index.js`:
                  
                  ```js
                  // automatically imports the right file!
                  import Widget from './Widget';
                  
                  export default Widget;
                  ```
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Time to make R10's navigation UI more platform-appropriate for Android...
                  
                  To do that, you're going to use platform-specific file extensions for the `NavigationLayout` component, and implement `DrawerNavigation` (from the ExNavigation module) for Android in lieu of the `TabNavigation` component that we've used for the iOS app.
                  
                  Create your platform specific files, and read-up on the `DrawerNavigation` component in the **[ExNavigation docs](https://github.com/exponentjs/ex-navigation#drawernavigation)** to implement this for Android only.
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - How to configure a dev environment for Android development
                  - How to use the `Platform` module in React Native components
                  - How to use file extensions to build entirely platform-specific components
                  
              </section>
          </section>



          <section>
              <section data-markdown>
                  # React Native Animations
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Explore the `LayoutAnimation` module
                  2. Explore the `Animated` module
              </section>
              <section data-markdown>
                  # LayoutAnimation Module
              </section>
              <section data-markdown>
                  # LayoutAnimation
                  
                  - The **easiest option** for basic animation
                  - Can get up and running with one line of code, and all the interpolation is taken care of for you
                  - Great for animating heights and widths, or transitioning between visible "tabs"
                  - But the [official documentation](https://facebook.github.io/react-native/docs/layoutanimation.html) is a bit sparse [(source code)](https://github.com/facebook/react-native/blob/master/Libraries/LayoutAnimation/LayoutAnimation.js)
              </section>
              <section data-markdown>
                  # An Example
                  
                  The following code would apply the `spring` animation preset to any layout changes that occur during the next render cycle:
                  
                  ```js
                  onPress = () => {
                    // LayoutAnimation.configureNext(LayoutAnimation.Presets.spring);
                  
                    LayoutAnimation.spring(); // SHORT-HAND VERSION OF ABOVE LINE
                    this.setState({ fontSize: this.state.fontSize * 1.25 });
                  }
                  
                  render() {
                    return (
                      <View>
                        <TouchableOpacity onPress={this.onPress}>
                          <Text style={% raw %}{{fontSize: this.state.fontSize}}{% endraw %}>Resize me!</Text>
                        </TouchableOpacity>
                      </View>
                    );
                  }
                  ```
              </section>
              <section data-markdown>
                  # Presets
                  
                  `LayoutAnimation` comes with three ready-made `Presets`:
                  
                  - `easeInEaseOut`
                  - `linear`
                  - `spring`
                  
                  *We can roll our own custom animation with this module too...*
                  
              </section>
              <section data-markdown>
                  # Custom Config Object
                  
                  How to create a custom config object for `LayoutAnimation`:
                  
                  ```js
                  const animationConfig = {
                    duration: 2000,
                    update: {
                      type: 'spring', 
                      springDamping: 0.1, // lower == more dramatic spring 
                    },
                  };
                  
                  LayoutAnimation.configureNext(animationConfig);
                  ```
                  
                  The `type` can als be set to `easeIn`, `easeInEaseOut`, `easeOut`, `linear`, or `keyboard`.
              </section>
              <section data-markdown>
                  # Custom Config Object
                  
                  We can also add `create` and `delete` properties to this object to animate views as they are added or removed:
                  
                  ```js
                  const animationConfig = {
                    duration: 2000,
                    create: {
                      type: 'spring', 
                      property: 'scaleXY',
                      springDamping: 0.7,
                    },
                    delete: {
                      type: 'linear',
                      property: 'opacity', // also scaleXY
                    },
                  };
                  
                  LayoutAnimation.configureNext(animationConfig);
                  ```
              </section>
              <section data-markdown>
                  # Config Helper Function
                  
                  ```js
                  const config = LayoutAnimation.create(400, 'linear', 'opacity');
                  ```
                  
                  What's stored in `config` would then look like this:
                  
                  ```js
                  {
                    duration: 400,
                    create: {
                      type: 'linear',
                      property: 'opacity',
                    },
                    update: {
                      type: 'linear',
                    },
                    delete: {
                      type: 'linear',
                      property: 'opacity',
                    },
                  }
                  ```
              </section>
              <section data-markdown>
                  # On Android
                  
                  Note that to make our `LayoutAnimation` work on Android, we will need some additional modules and config:
                  
                  ```js
                  import {
                    LayoutAnimation,
                    Platform,
                    UIManager,
                    // ...other imports
                  } from 'react-native';
                  
                  constructor() {
                    if (Platform.OS === 'android') {
                      UIManager.setLayoutAnimationEnabledExperimental 
                      && UIManager.setLayoutAnimationEnabledExperimental(true);
                    }
                  }
                  ```
              </section>
              <section data-markdown>
                  # Exercise 1
                  
                  Using what you just learned about `LayoutAnimation`, add animation to your About scene to toggle of the visibility of each Code of Conduct item when they are tapped.
                  
                  Each Code of Conduct item should be closed by default.
                  
                  Note that you can use one of the built-in `Presets` for this exercise, or create your own custom configuration object to control the animation if you like.
              </section>
              <section data-markdown>
                  # Animated Module
              </section>
              <section data-markdown>
                  # Animated
                  
                  - Allows more complex, finer-grained animation than `LayoutAnimation`
                  - Some knowledge of how CSS animation works can be helpful, as we will be animating style properties
                  - Great for animating anything that you would animate with a CSS transform (e.g. `rotate`, `translateX`, or `translateY`, `scale`, etc.)
                  
              </section>
              <section data-markdown>
                  # Animation Types
                  
                  React Native support three different **animation types**:
                  
                  - `spring`: simple spring physics model that you can set `friction` (bounciness) and `tension` (speed) on
                  - `decay`: starts with an initial velocity and slows to a stop, and you can set the `velocity` (required) and `deceleration` (rate of decay) 
                  - `timing`: maps time range to easing value, and allows you to set the `duration` (default is 500ms), `easing` (type of curve), and `delay` (in milliseconds)
              </section>
              <section data-markdown>
                  # Animated Components
                  
                  RN also supports three types of **animated UI components**:
                  
                  - `<Animated.View />`
                  - `<Animated.Image />`
                  - `<Animated.Text />`
                  
                  There's also an easy way to turn any component into an animated component:
                  
                  ```js
                  let AnimatedButton = Animated.createAnimatedComponent(Button);
                  ```
              </section>
              <section data-markdown>
                  # Basic Example
                  
                  **Step 1:** Add a new `Animated.ValueXY()` to our state
                  
                  ```js
                  this.state = {
                    translateValue: Animated.ValueXY()
                  }
                  ```
                  
                  Note that `Animated.ValueXY` is **for vectors only** (in other words, 2D animations, and it works well when responding to gestures with the `PanResponder` module).
                  
                  We will use `Animated.Value()` for animating all other types of values (more on that to come...).
              </section>
              <section data-markdown>
                  # Basic Example
                  
                  **Step 2:** Create an animation method
                  
                  ```js
                  animateCircle = () => {
                    Animated.spring(
                      this.state.translateValue, 
                      { toValue: {x: 50, y: 100} },
                    ).start();
                  }
                  ```
                  
                  Note that the first argument to `Animated.spring()` is the value we want to drive, and the second is the configuration for the animation.
              </section>
              <section data-markdown>
                  # Basic Example
                  
                  **Step 3:** Update the `render` method
                  
                  ```js
                  render() {
                    let animatedStyles = { 
                      transform: [
                        { translateX: this.state.translateValue.x },
                        { translateY: this.state.translateValue.y }
                      ] 
                    };
                  
                    return (
                      <View>
                        <TouchableWithoutFeedback onPress={this.onCirclePress}>
                          <Animated.View style={[styles.circle, animatedStyles]} />
                        </TouchableWithoutFeedback>
                      </View>
                    );
                  }
                  ```
              </section>
              <section data-markdown>
                  .large[
                  Now let's animate different styles at the same time...
                ]
              </section>
              <section data-markdown>
                  # Parallel Animations
                  
                  Set a new `Animated.Value()` in the `constructor`:
                  
                  ```js
                  this.state = { 
                    translateValue: new Animated.ValueXY(),
                    color: new Animated.Value(0)
                  }
                  ```
                  
                  What you pass into `Animated.Value()` can range from `0` to `1`. This value represents the percentage of the animation's completion (from 0% to 100%).
              </section>
              <section data-markdown>
                  # Parallel Animations
                  
                  To animate the colour of the component at the same time as the translate animation, we can use `Animated.parallel()`:
                  
                  ```js
                  Animated.parallel([
                    Animated.spring(
                      this.state.translateValue, 
                      { toValue: {x: 50, y: 100} },
                    ),
                    Animated.timing(
                      this.state.color,
                      { 
                        toValue: 1,
                        duration: 600,
                      }
                    )
                  ]).start();
                  ```
              </section>
              <section data-markdown>
                  # Parallel Animations
                  
                  Then update the `render` method again:
                  
                  ```js
                  render() {
                    let color = this.state.color.interpolate({
                      inputRange: [0, 1],
                      outputRange: ['red', 'pink']
                    });
                  
                    let animatedStyles = { 
                      transform: [
                        { translateX: this.state.translateValue.x },
                        { translateY: this.state.translateValue.y }
                      ],
                      backgroundColor: color
                    };
                  
                    // our other code...
                  }
                  
                  ```
              </section>
              <section data-markdown>
                  # Interpolation?
                  
                  - How we fill in frames between the "key frames"
                  - Also known as "inbetweening" (the overall process is "keyframe animation")
                  - Historically, junior animators would fill in the frames between key frames that the master animator had drawn
                  - Today, the in-betweens are the results of the computer interpreting what needs to be filled in between key frames
                  - Key to nice, smooth, natural animation
              </section>
              <section data-markdown>
                  # Interpolation
                  
                  The `.interpolate` method creates a new animation based on an existing one by mapping its values to a different range. We define how a style property is changed in our `render` method using `interpolate()`.
                  
                  We can map an `inputRange` of `[0, 1]` to an `outputRange` of `[0, 100]`, or map strings like degrees of rotation, or even colours like `['red', 'pink']`:
                  
                  ```js
                  const spin = this.state.spinValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: ['0deg', '360deg']
                  });
                  ```
              </section>
              <section data-markdown>
                  # Make it Loop!
                  
                  ```js
                  animateCircle = () => {
                    this.state.translateValue.setValue({x: 0, y: 0})
                    this.state.color.setValue(0);
                    
                    Animated.parallel([
                      Animated.spring(
                        this.state.translateValue, 
                        { toValue: {x: 50, y: 100} },
                      ),
                      Animated.timing(
                        this.state.color,
                        { 
                          toValue: 1,
                          duration: 600,
                        }
                      )
                    ]).start((animation) => {
                      if (animation.finished) {
                        this.animateCircle();
                      }
                    }); // just pass a callback in here and recursively call the method
                  }
                  ```
              </section>
              <section data-markdown>
                  # Sequenced Animations
                  
                  Rather than running our animation at the same time, we can run the one after another using `Animated.sequence()`:
                  
                  ```js
                  Animated.sequence([
                    Animated.spring(
                      this.state.translateValue, 
                      { toValue: {x: 50, y: 100} },
                    ),
                    Animated.timing(
                      this.state.color,
                      { 
                        toValue: 1,
                        duration: 600,
                        easing: Easing.linear
                      }
                    )
                  ]).start();
                  ```
              </section>
              <section data-markdown>
                  # Exercise 2
                  
                  Using what you just learned about the `Animated` module, create a `spin` method in your Code of Conduct item component to rotate the "+" sign 360 degrees when the item is toggled open using `Animated.timing()`.
                  
                  Be sure to also change the "+" to a "-" when the item toggles open (and back again when it is closed).
              </section>
              <section data-markdown>
                  # What We've Learned
                  
                  - How to use the `LayoutAnimation` module for basic UI animations
                  - How to use the `Animated module` for more complex animations
                  
              </section>
          </section>



          <section>
              <section data-markdown>
                  # Cloud Deployment
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Introduction
                  2. Deep-dive
                  3. ...
              </section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
              <section data-markdown></section>
          </section>




          <section>
              <section data-markdown>
                  # Git for teams
                  
                  .title-logo[![Red logo](/public/img/red-logo-white.svg)]
              </section>
              <section data-markdown>
                  # Agenda
                  
                  1. Define what makes a good team?
                  2. How can Git be used to make your team more efficient 
                  3. Understand common errors with Git Teams
              </section>
              <section data-markdown>
                  #Discussion
                  
                  What is the best team you have been apart of?
                  
                  What was the worst team you have been apart of?
                  
                  What characteristics did they have the made it different?
                  
              </section>
              <section data-markdown>
                  #Synergy 
                  
                  Is where the sum of the parts is greater than the whole.
                  
              </section>
              <section data-markdown>
                  #Exercise 1
                  
                  Everyone is tasked with making a website for our class. This site must be about Git and the benefits of using it. Everyone must collaborate on it. 
                  
                  The process will consist of 4 separate 5 minute stages. 
                  1. Everyone is working on creating the site separately.
                  2. Everyone will zip their files over to an elected person. This person will work on merging all the files into one. The remaining people will continue on improving the site. 
                  3. Rotate until everyone has had a chance to merge.
              </section>
              <section data-markdown>
                  #Discuss
                  
                  What are a few things everyone would do in order to make this process easier?
              </section>
              <section data-markdown>
                  #Exercise 2
                  
                  How would you create version control?
                  
                  Spend a few minutes writing down all the features you would like your version control to have. Specifically tailor it to a team environment. 
                  
              </section>
              <section data-markdown>
                  #Workflow
                  
                  Would this flow be useful?
                  
                  https://i.ytimg.com/vi/gLWSJXBbJuE/maxresdefault.jpg
              </section>
              <section data-markdown>
                  #Contributing
                  
                  Problem - You have a project that you want contribution from other people. What features would you include, how would it work?
                  
                  1. Will this work for a group of 5 and a group of 1000?
                  2. Does everyone have write access? How are patches reviewed?
              </section>
              <section data-markdown>
                  #Pull Requests
              </section>
              <section data-markdown>
                  #Code Review
              </section>
              <section data-markdown>
                  #Advanced GIT MACK
              </section>
              <section data-markdown>
                  #Stash
              </section>
              <section data-markdown>
                  #Rebase - interactive
              </section>
              <section data-markdown>
                  #Hooks
                  - pre commit
              </section>
              <section data-markdown>
                  #Git cherry-pick
              </section>
              <section data-markdown>
                  #permissions
              </section>
          </section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
